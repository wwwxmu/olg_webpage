<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="rdT17EW0Kh1apJgjy5BF3U5QQQKPSnklJwhpzY5TAi4">
  <meta name="msvalidate.01" content="C8AEF300145F614C5139D7CA80541E48">
  <meta name="baidu-site-verification" content="mOm9MG2oP2">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script data-ad-client="ca-pub-7960294795324770" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="//dup.baidustatic.com/js/ds.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weiweiblog.cn","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。">
<meta property="og:type" content="article">
<meta property="og:title" content="互联网校招面试必备——Java多线程">
<meta property="og:url" content="https://weiweiblog.cn/thread/index.html">
<meta property="og:site_name" content="尾尾部落">
<meta property="og:description" content="本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNbRwgy1fvao00n1s4j30zk0i8jvt.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg">
<meta property="article:published_time" content="2018-09-18T09:06:52.000Z">
<meta property="article:modified_time" content="2020-05-17T07:27:05.335Z">
<meta property="article:author" content="www">
<meta property="article:tag" content="java">
<meta property="article:tag" content="同步">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws4.sinaimg.cn/large/006tNbRwgy1fvao00n1s4j30zk0i8jvt.jpg">

<link rel="canonical" href="https://weiweiblog.cn/thread/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>互联网校招面试必备——Java多线程 | 尾尾部落</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-75337338-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-75337338-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c0cf4eed151bf6c4a0aab22fe95b7495";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="尾尾部落" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">尾尾部落</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">永远年轻，永远热泪盈眶！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">108</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">131</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/wwwxmu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weiweiblog.cn/thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="www">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="尾尾部落">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          互联网校招面试必备——Java多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-18 17:06:52" itemprop="dateCreated datePublished" datetime="2018-09-18T17:06:52+08:00">2018-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-17 15:27:05" itemprop="dateModified" datetime="2020-05-17T15:27:05+08:00">2020-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法&amp;数据结构</span></a>
                </span>
            </span>

          
            <span id="/thread/" class="post-meta-item leancloud_visitors" data-flag-title="互联网校招面试必备——Java多线程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/thread/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/thread/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。</p>
<blockquote>
<p>什么是进程，什么是线程？为什么需要多线程编程？</p>
</blockquote>
<blockquote>
<p>进程间的通信方式、线程间的通信方式</p>
</blockquote>
<blockquote>
<p>实现多线程的三种方法</p>
</blockquote>
<blockquote>
<p>三种创建多线程方法的对比</p>
</blockquote>
<blockquote>
<p>线程状态</p>
</blockquote>
<blockquote>
<p>线程控制</p>
</blockquote>
<blockquote>
<p>wait、notify、notifyAll的区别</p>
</blockquote>
<blockquote>
<p>sleep() 和 wait() 有什么区别?</p>
</blockquote>
<blockquote>
<p>锁类型</p>
</blockquote>
<blockquote>
<p>什么是乐观锁和悲观锁</p>
</blockquote>
<blockquote>
<p>乐观锁的实现方式（CAS）</p>
</blockquote>
<blockquote>
<p>CAS的缺点</p>
</blockquote>
<blockquote>
<p>实现一个死锁</p>
</blockquote>
<blockquote>
<p>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</p>
</blockquote>
<blockquote>
<p>volatile</p>
</blockquote>
<blockquote>
<p>volatile使用建议</p>
</blockquote>
<blockquote>
<p>volatile和synchronized区别</p>
</blockquote>
<blockquote>
<p>synchronized</p>
</blockquote>
<blockquote>
<p>synchronized的三种应用方式</p>
</blockquote>
<blockquote>
<p>Lock</p>
</blockquote>
<blockquote>
<p>Lock接口中获取锁的方法</p>
</blockquote>
<blockquote>
<p>Condition类</p>
</blockquote>
<blockquote>
<p>Condition与Object中的wait, notify, notifyAll区别</p>
</blockquote>
<blockquote>
<p>synchronized和lock的区别</p>
</blockquote>
<blockquote>
<p>锁的状态</p>
</blockquote>
<blockquote>
<p>偏向锁、轻量级锁、重量级锁、自旋锁、自适应自旋锁</p>
</blockquote>
<blockquote>
<p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</p>
</blockquote>
<blockquote>
<p>AQS</p>
</blockquote>
<blockquote>
<p>线程池</p>
</blockquote>
<blockquote>
<p>使用线程池的好处</p>
</blockquote>
<blockquote>
<p>线程池都有哪几种工作队列 </p>
</blockquote>
<h2 id="什么是进程，什么是线程？为什么需要多线程编程？"><a href="#什么是进程，什么是线程？为什么需要多线程编程？" class="headerlink" title="什么是进程，什么是线程？为什么需要多线程编程？"></a>什么是进程，什么是线程？为什么需要多线程编程？</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它占用了更多的 CPU 资源。</p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><ul>
<li>锁机制：包括互斥锁、条件变量、读写锁 <ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
</ul>
<blockquote>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 </p>
</blockquote>
<h2 id="实现多线程的三种方法"><a href="#实现多线程的三种方法" class="headerlink" title="实现多线程的三种方法"></a>实现多线程的三种方法</h2><ul>
<li>继承Thread类，重写父类run()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class thread1 extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;我是线程&quot;+this.getId());</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                thread1 th1 &#x3D; new thread1();</span><br><span class="line">                thread1 th2 &#x3D; new thread1();</span><br><span class="line">                th1.start();</span><br><span class="line">                th2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现runnable接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class thread2 implements Runnable &#123;</span><br><span class="line">        public String ThreadName;</span><br><span class="line">        public thread2(String tName)&#123;</span><br><span class="line">                ThreadName &#x3D; tName;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(ThreadName);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建一个Runnable接口实现类的对象</span><br><span class="line">                thread2 th1 &#x3D; new thread2(&quot;线程A:&quot;);</span><br><span class="line">                thread2 th2 &#x3D; new thread2(&quot;线程B:&quot;);</span><br><span class="line">                &#x2F;&#x2F; 将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程</span><br><span class="line">                Thread myth1 &#x3D; new Thread(th1);</span><br><span class="line">                Thread myth2 &#x3D; new Thread(th2);</span><br><span class="line">                &#x2F;&#x2F; 调用start()方法，启动线程并执行run()方法</span><br><span class="line">                myth1.start();</span><br><span class="line">                myth2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Callable和Future创建线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for(;i&lt;100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        CallableThreadTest ctt &#x3D; new CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);</span><br><span class="line">            if(i&#x3D;&#x3D;20)&#123;</span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());</span><br><span class="line">        &#125; catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种创建多线程方法的对比"><a href="#三种创建多线程方法的对比" class="headerlink" title="三种创建多线程方法的对比"></a>三种创建多线程方法的对比</h3><p>1、采用实现Runnable、Callable接口的方式创建多线程时，线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。缺点是编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2、使用继承Thread类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。缺点是线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>3、Runnable和Callable的区别</p>
<p>(1) Callable规定重写call()，Runnable重写run()。</p>
<p>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</p>
<p>(3) call方法可以抛出异常，run方法不可以。</p>
<p>(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvao00n1s4j30zk0i8jvt.jpg" alt=""></p>
<ul>
<li>新建状态：新建线程对象，并没有调用start()方法之前</li>
<li>就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。</li>
<li>运行状态：线程被设置为当前线程，获得CPU后，开始执行run()方法，就是线程进入运行状态。</li>
<li>阻塞状态：处于运行的状态的线程，除非执行时间非常非常非常短，否则它会因为系统对资源的调度而被中断进入阻塞状态。比如说调用sleep()方法后线程就进入阻塞状态。</li>
<li>死亡状态：处于运行状态的线程，当它主动或者被动结束，线程就处于死亡状态。结束的形式，通常有以下几种：1. 线程执行完成，线程正常结束；2. 线程执行过程中出现异常或者错误，被动结束；3. 线程主动调用stop方法结束线程。</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><ul>
<li>join()：等待。让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。</li>
<li>sleep()：睡眠。让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。</li>
<li>yield()：线程让步。将线程从运行状态转换为就绪状态。当某个线程调用 yiled() 方法从运行状态转换到就绪状态后，CPU 会从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。</li>
<li>setPriority()：改变线程的优先级。每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值：MAX_PRIORITY：10；MIN_PRIORITY：1；NORM_PRIORITY：5。</li>
</ul>
<blockquote>
<p>PS: 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 </p>
</blockquote>
<ul>
<li>setDaemon(true)：设置为后台线程。后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。当所有的前台线程都进入死亡状态时，后台线程会自动死亡。</li>
</ul>
<blockquote>
<p>sleep() 和 yield() 两者的区别：</p>
</blockquote>
<blockquote>
<p>① sleep()方法会给其他线程运行的机会，不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会。yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</p>
</blockquote>
<blockquote>
<p>② 当线程执行了 sleep(long millis) 方法，将转到阻塞状态，参数millis指定睡眠时间。当线程执行了yield()方法，将转到就绪状态。</p>
</blockquote>
<blockquote>
<p>③ sleep() 方法声明抛出InterruptedException异常，而 yield() 方法没有声明抛出任何异常。 </p>
</blockquote>
<h2 id="wait、notify、notifyAll的区别"><a href="#wait、notify、notifyAll的区别" class="headerlink" title="wait、notify、notifyAll的区别"></a>wait、notify、notifyAll的区别</h2><p>wait、notify、notifyAll是java同步机制中重要的组成部分，结合synchronized关键字使用，可以建立很多优秀的同步模型。这3个方法并不是Thread类或者是Runnable接口的方法，而是Object类的3个本地方法。</p>
<p>调用一个Object的wait与notify/notifyAll的时候，必须保证调用代码对该Object是同步的，也就是说必须在作用等同于synchronized(obj){&#8230;&#8230;}的内部才能够去调用obj的wait与notify/notifyAll三个方法，否则就会报错：<code>java.lang.IllegalMonitorStateException:current thread not owner</code></p>
<blockquote>
<p>先说两个概念：锁池和等待池</p>
</blockquote>
<blockquote>
<p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
</blockquote>
<blockquote>
<p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</p>
</blockquote>
<blockquote>
<p>@知乎&#8211;<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">文龙</a> </p>
</blockquote>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>wait：线程自动释放其占有的对象锁，并等待notify</p>
</li>
<li><p>notify：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁</p>
</li>
<li><p>notifyAll：唤醒所有正在wait当前对象锁的线程</p>
<p>notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。</p>
</li>
</ul>
<h4 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h4><p>sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用 sleep 不会释放对象锁。wait() 是 Object 类的方法，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><ul>
<li>可重入锁：广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。即在执行对象中所有同步方法不用再次获得锁。ReentrantLock和synchronized都是可重入锁。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</li>
<li>可中断锁：在等待获取锁过程中可中断。synchronized就不是可中断锁，而Lock是可中断锁。</li>
<li>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利。非公平锁即无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。synchronized是非公平锁，它无法保证等待的线程获取锁的顺序。对于ReentrantLock和ReentrantReadWriteLock，默认情况下是非公平锁，但是可以设置为公平锁。</li>
<li>读写锁：对资源读取和写入的时候拆分为2部分处理，一个读锁和一个写锁。读的时候可以多线程一起读，写的时候必须同步地写。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li>
</ul>
<h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><p>（1）乐观锁：很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会去判断在此期间有没有人去更新这个数据（可以使用版本号等机制）。如果因为冲突失败就重试。乐观锁适用于写比较少的情况下，即冲突比较少发生，这样可以省去了锁的开销，加大了系统的整个吞吐量。像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>（2）悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，因此每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁，效率比较低。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<h3 id="乐观锁的实现方式（CAS）"><a href="#乐观锁的实现方式（CAS）" class="headerlink" title="乐观锁的实现方式（CAS）"></a>乐观锁的实现方式（CAS）</h3><p>乐观锁的实现主要就两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p>
<p>CAS：CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<blockquote>
<p>乐观锁是一种思想，CAS是这种思想的一种实现方式。 </p>
</blockquote>
<h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><ol>
<li><p>ABA问题</p>
<blockquote>
<p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。ava并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
</blockquote>
</li>
<li><p>循环时间长开销很大</p>
<blockquote>
<p>自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p>
</blockquote>
</li>
<li><p>只能保证一个共享变量的原子操作。</p>
<blockquote>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
</blockquote>
</li>
</ol>
<h2 id="实现一个死锁"><a href="#实现一个死锁" class="headerlink" title="实现一个死锁"></a>实现一个死锁</h2><p>什么是死锁：两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<p>产生死锁的四个必要条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>考虑如下情形：</p>
<p>（1）线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。</p>
<p>（2）线程A试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2释放。</p>
<p>（3）如果此时线程B也在试图获取lock1，同理线程也会阻塞。</p>
<p>（4）两者都在等待对方所持有但是双方都不释放的锁，这时便会一直阻塞形成死锁。</p>
<p>死锁的解决方法:</p>
<p>a 撤消陷于死锁的全部进程；</p>
<p>b 逐个撤消陷于死锁的进程，直到死锁不存在；</p>
<p>c 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</p>
<p>d 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态</p>
<h3 id="如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><a href="#如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？" class="headerlink" title="如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？"></a>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>　　对于过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>
<ul>
<li><p>防止重排序</p>
<blockquote>
<p>问题：操作系统可以对指令进行重排序，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果</p>
</blockquote>
<blockquote>
<p>解决原理：volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
</blockquote>
<blockquote>
<p>1、在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</p>
</blockquote>
<blockquote>
<p>2、在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 </p>
</blockquote>
</li>
<li><p>实现可见性</p>
<blockquote>
<p>问题：可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到</p>
</blockquote>
<blockquote>
<p>解决原理：（1）修改volatile变量时会强制将修改后的值刷新的主内存中。</p>
</blockquote>
<blockquote>
<p>（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 </p>
</blockquote>
</li>
<li><p>注：volatile并不保证变量更新的原子性</p> </p>
</li>
</ul>
<h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p>
<p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</p>
<p>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><p>1、volatile不会进行加锁操作：</p>
<p>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<p>2、volatile变量作用类似于同步变量读写操作：</p>
<p>从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p>
<p>3、volatile不如synchronized安全：</p>
<p>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</p>
<p>4、volatile无法同时保证内存可见性和原子性：</p>
<p>加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。</p>
<p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>
<p>1、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</p>
<p>2、该变量没有包含在具有其他变量的不变式中。</p>
<p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Synchronized主要有以下三个作用：保证互斥性、保证可见性、保证顺序性。</p>
<h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><ul>
<li><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。实现原理：指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。实现原理：使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static AccountingSync instance&#x3D;new AccountingSync();</span><br><span class="line">synchronized(instance)&#123;</span><br><span class="line">    for(int j&#x3D;0;j&lt;1000000;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock是一个接口，它的的实现类提供了比synchronized更广泛意义上锁操作，它允许用户更灵活的代码结构，更多的不同特效。Lock的实现类主要有ReentrantLock和ReentrantReadWriteLock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock&#x3D;new ReentrantLock()；</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    &#x2F;&#x2F; 如果有return要写在try块中</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock接口中获取锁的方法"><a href="#Lock接口中获取锁的方法" class="headerlink" title="Lock接口中获取锁的方法"></a>Lock接口中获取锁的方法</h3><ul>
<li>void lock()：lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。在发生异常时，它不会自动释放锁，要记得在finally块中释放锁，以保证锁一定被被释放，防止死锁的发生。</li>
<li>void lockInterruptibly()：可以响应中断，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。</li>
<li>boolean tryLock()：有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true；如果获取失败（即锁已被其他线程获取），则返回false。</li>
<li>boolean tryLock(long time, TimeUnit unit)：和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。</li>
</ul>
<h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>Condition是Java提供来实现等待/通知的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
<p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。</p>
<p>其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h4 id="Condition与Object中的wait-notify-notifyAll区别"><a href="#Condition与Object中的wait-notify-notifyAll区别" class="headerlink" title="Condition与Object中的wait, notify, notifyAll区别"></a>Condition与Object中的wait, notify, notifyAll区别</h4><p>1.Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。</p>
<p>不同的是，Object中的这些方法是和同步锁捆绑使用的；而Condition是需要与互斥锁/共享锁捆绑使用的。</p>
<p>2.Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</p>
<p>例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒&#8221;读线程&#8221;；当从缓冲区读出数据之后，唤醒&#8221;写线程&#8221;；并且当缓冲区满的时候，&#8221;写线程&#8221;需要等待；当缓冲区为空时，&#8221;读线程&#8221;需要等待。</p>
<p>如果采用Object类中的wait(),notify(),notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒&#8221;读线程&#8221;时，不可能通过notify()或notifyAll()明确的指定唤醒&#8221;读线程&#8221;，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。 但是，通过Condition，就能明确的指定唤醒读线程。</p>
<h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存在层次</td>
<td align="center">Java的关键字</td>
<td align="center">是一个接口</td>
</tr>
<tr>
<td align="center">锁的释放</td>
<td align="center">1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td>
<td align="center">在finally中必须释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td align="center">锁的获取</td>
<td align="center">假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td>
<td align="center">Lock可以让等待锁的线程响应中断</td>
</tr>
<tr>
<td align="center">锁状态</td>
<td align="center">无法判断</td>
<td align="center">可以判断有没有成功获取锁</td>
</tr>
<tr>
<td align="center">锁类型</td>
<td align="center">可重入 不可中断 非公平</td>
<td align="center">可重入 可中断 公平/非公平</td>
</tr>
</tbody></table>
<p>性能方面，JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。多线程环境下，synchronized的吞吐量下降的非常严重，而ReentrankLock则能基本保持在同一个比较稳定的水平上。</p>
<p>到了JDK1.6，synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p>
<h2 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h2><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。轻量级锁是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p>自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p>
<h3 id="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"><a href="#偏向锁、轻量级锁、重量级锁适用于不同的并发场景" class="headerlink" title="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"></a>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</h3><p>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</p>
<p>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</p>
<p>重量级锁：有实际竞争，且锁竞争时间长。</p>
<p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p>
<p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p>
<blockquote>
<p>锁膨胀的过程：只有一个线程进入临界区（偏向锁），多个线程交替进入临界区（轻量级锁），多线程同时进入临界区（重量级锁）。 </p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AbstractQueuedSynchronizer是一个抽象类，主要是维护了一个int类型的state属性和一个非阻塞、先进先出的线程等待队列；其中state是用volatile修饰的，保证线程之间的可见性，队列的入队和出对操作都是无锁操作，基于自旋锁和CAS实现；另外AQS分为两种模式：独占模式和共享模式，像ReentrantLock是基于独占模式模式实现的，CountDownLatch、CyclicBarrier等是基于共享模式。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>线程池的产生和数据库的连接池类似，系统启动一个线程的代价是比较高昂的，如果在程序启动的时候就初始化一定数量的线程，放入线程池中，在需要是使用时从池子中去，用完再放回池子里，这样能大大的提高程序性能，再者，线程池的一些初始化配置，也可以有效的控制系统并发的数量，防止因为消耗过多的内存，而把服务器累趴下。</p>
<p>通过Executors工具类可以创建各种类型的线程池，如下为常见的四种：</p>
<ul>
<li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li>
<li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li>
<li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
<li>对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li>
</ul>
<h3 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h3><p>1、ArrayBlockingQueue</p>
<p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
<p>2、LinkedBlockingQueue</p>
<p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p>
<p>3、SynchronousQueue</p>
<p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>
<p>4、PriorityBlockingQueue</p>
<p>一个具有优先级的无限阻塞队列。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/java-interview-bible/multi-thread.html" target="_blank" rel="noopener">Java 多线程</a></p>
<p><a href="http://www.importnew.com/23535.html" target="_blank" rel="noopener">Java并发：volatile内存可见性和指令重排</a></p>
<p><a href="https://juejin.im/post/5a43ad786fb9a0450909cb5f" target="_blank" rel="noopener">并发编程的锁机制：synchronized和lock</a></p>
<p><a href="https://juejin.im/post/5a5c09d051882573282164ae" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁</a></p>
<blockquote>
<p>获取最新资讯，请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.JPG" alt="www 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.JPG" alt="www 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>www
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://weiweiblog.cn/thread/" title="互联网校招面试必备——Java多线程">https://weiweiblog.cn/thread/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag"><i class="fa fa-tag"></i> 同步</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
              <a href="/tags/%E9%94%81/" rel="tag"><i class="fa fa-tag"></i> 锁</a>
          </div>
        <div class="_9ijahrma7rg"></div>
        <script type="text/javascript">
            (window.slotbydup = window.slotbydup || []).push({
                id: "u6046082",
                container: "_9ijahrma7rg",
                async: true
            });
        </script>
        <!-- 多条广告如下脚本只需引入一次 -->
        <script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async="async" defer="defer" >
        </script>
        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/collections/" rel="prev" title="一文搞定BAT面试——Java 集合类">
      <i class="fa fa-chevron-left"></i> 一文搞定BAT面试——Java 集合类
    </a></div>
      <div class="post-nav-item">
    <a href="/databases/" rel="next" title="互联网校招面试必备——数据库">
      互联网校招面试必备——数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是进程，什么是线程？为什么需要多线程编程？"><span class="nav-number">1.</span> <span class="nav-text">什么是进程，什么是线程？为什么需要多线程编程？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间的通信方式"><span class="nav-number">1.1.</span> <span class="nav-text">进程间的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间的通信方式"><span class="nav-number">1.2.</span> <span class="nav-text">线程间的通信方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现多线程的三种方法"><span class="nav-number">2.</span> <span class="nav-text">实现多线程的三种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三种创建多线程方法的对比"><span class="nav-number">2.1.</span> <span class="nav-text">三种创建多线程方法的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态"><span class="nav-number">3.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制"><span class="nav-number">4.</span> <span class="nav-text">线程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait、notify、notifyAll的区别"><span class="nav-number">5.</span> <span class="nav-text">wait、notify、notifyAll的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">5.0.1.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-和-wait-有什么区别"><span class="nav-number">5.0.2.</span> <span class="nav-text">sleep() 和 wait() 有什么区别?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁类型"><span class="nav-number">6.</span> <span class="nav-text">锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是乐观锁和悲观锁"><span class="nav-number">6.1.</span> <span class="nav-text">什么是乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁的实现方式（CAS）"><span class="nav-number">6.2.</span> <span class="nav-text">乐观锁的实现方式（CAS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS的缺点"><span class="nav-number">6.3.</span> <span class="nav-text">CAS的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个死锁"><span class="nav-number">7.</span> <span class="nav-text">实现一个死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><span class="nav-number">7.1.</span> <span class="nav-text">如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字"><span class="nav-number">8.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile使用建议"><span class="nav-number">8.1.</span> <span class="nav-text">volatile使用建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile和synchronized区别"><span class="nav-number">8.2.</span> <span class="nav-text">volatile和synchronized区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">9.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized的三种应用方式"><span class="nav-number">9.0.1.</span> <span class="nav-text">synchronized的三种应用方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">10.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock接口中获取锁的方法"><span class="nav-number">10.1.</span> <span class="nav-text">Lock接口中获取锁的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition类"><span class="nav-number">10.2.</span> <span class="nav-text">Condition类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition与Object中的wait-notify-notifyAll区别"><span class="nav-number">10.2.1.</span> <span class="nav-text">Condition与Object中的wait, notify, notifyAll区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized和lock的区别"><span class="nav-number">10.3.</span> <span class="nav-text">synchronized和lock的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的状态"><span class="nav-number">11.</span> <span class="nav-text">锁的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">11.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">11.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-number">11.3.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">11.4.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应自旋锁"><span class="nav-number">11.5.</span> <span class="nav-text">自适应自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁、轻量级锁、重量级锁适用于不同的并发场景"><span class="nav-number">11.6.</span> <span class="nav-text">偏向锁、轻量级锁、重量级锁适用于不同的并发场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">12.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">13.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用线程池的好处"><span class="nav-number">13.1.</span> <span class="nav-text">使用线程池的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池都有哪几种工作队列"><span class="nav-number">13.2.</span> <span class="nav-text">线程池都有哪几种工作队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">14.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="www"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">www</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wwwxmu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wwwxmu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:www@xmu.edu.cn" title="E-Mail → mailto:www@xmu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1007705782" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1007705782" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/weiweiblog" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;weiweiblog" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom icon-zhihu"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/20836937" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;20836937" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom icon-bilibili-line"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/67eb7ed414d3" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;67eb7ed414d3" rel="noopener" target="_blank"><i class="fa fa-fw fa-custom icon-CN_jianshu"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
       (  •̆ ᵕ •̆ )◞♡ 您是小站的第 <i class="fa fa-user"></i>
      </span>
         <span class="site-uv" title="总访客量">
       <span id="busuanzi_value_site_uv"></span> 
      </span> 位客人
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        小站已经曝光 <i class="fa fa-eye"></i>
      </span>
       <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span> 
      </span> 次啦 (ง •̀o•́)ง  
    </span>
</div>








        

<div class="copyright">
  <div id="days"></div>


<span class="post-meta-divider">|</span>

  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尾尾部落</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">273k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

 <span class="post-meta-divider">|</span>
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备16006719号 </a>
  </div>


<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("09/15/2016 02:02:02");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="小站已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>

      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : false,
      appId      : 'AoNMPudz1mpjgJhxQ2aJ7M5N-gzGzoHsz',
      appKey     : 'vIyRaCfth6iGX9lizTpIc2HY',
      placeholder: "开始讨论...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fa fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fa fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button" onclick="moonMenuClick()">
    <svg class="moon-menu-svg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
      <g class="moon-menu-points">
        <circle class="moon-menu-point" r=".2rem" cx="0" cy="-.8rem"></circle>
        <circle class="moon-menu-point" r=".2rem"></circle>
        <circle class="moon-menu-point" r=".2rem" cx="0" cy=".8rem"></circle>
      </g>
    </svg>
    <div class="moon-menu-icon">
    </div>
    <div class="moon-menu-text">
    </div>
  </div>
</div>
<script src="/js/injector.js"></script>
</body>
</html>
