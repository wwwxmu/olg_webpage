<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>尾尾部落</title>
  
  <subtitle>永远年轻，永远热泪盈眶！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weiweiblog.cn/"/>
  <updated>2020-05-17T07:27:05.251Z</updated>
  <id>https://weiweiblog.cn/</id>
  
  <author>
    <name>www</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【李宏毅-机器学习】RNN的梯度消失和梯度爆炸及其解决方案</title>
    <link href="https://weiweiblog.cn/ML_lecture21-2_RNN/"/>
    <id>https://weiweiblog.cn/ML_lecture21-2_RNN/</id>
    <published>2020-05-24T16:00:00.000Z</published>
    <updated>2020-05-17T07:27:05.251Z</updated>
    
    <content type="html"><![CDATA[<p>RNN在使用过程中会出现两种问题，一种是梯度消失，一种是梯度爆炸。</p><p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505133932.png" alt=""></p><p>有一个方法可以直观地知道一个gradient的大小是什么样的：<br>我们把某一个参数做小小的变化，看它对网络输出的变化有多大，你就可以测出这个参数的gradient的大小。</p><p>如上图，假设w是我们要学习的参数，我们想要知道当改变w值的时候对网络的输出有多大的影响。假设w=1,y的1000次方等于1，假设w=1.01，y的1000次方约等于20000，所以w有很大的gradient，这就会导致梯度爆炸；而如果让w=0.99，这时候y的1000次方约等于0，w的gradient就很小，导致梯度消失。</p><p>当出现梯度爆炸的时候，梯度值会变成NaN，导致程序崩溃，所以梯度爆炸容易发现。对于梯度爆炸的问题可以通过梯度裁剪来缓解，即当梯度的范式大于某个给定值时，对梯度进行等比收缩。</p><p>而梯度消失问题相对比较棘手，它不会像梯度爆炸那样明显被发现，同时也比较不好处理。LSTM或者GRU等模型通过加入门控机制，很大程度上弥补了梯度消失所带来的损失。</p><p>在RNN中，在每个时间点，memory里面的信息都会被覆盖掉，但是在LSTM里面，它是把原来memory里面的值乘上一个值再把input的值加起来放到cell里面去，所以它的memory和input是相加的。在LSTM中，如果w可以影响到memory里面的值话，一旦发生影响，这个影响会永远都存在（除非forget门开启），不像RNN在每个时间的值都会被覆盖掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RNN在使用过程中会出现两种问题，一种是梯度消失，一种是梯度爆炸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://weiweiblog.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="RNN" scheme="https://weiweiblog.cn/tags/RNN/"/>
    
      <category term="LSTM" scheme="https://weiweiblog.cn/tags/LSTM/"/>
    
      <category term="gradient" scheme="https://weiweiblog.cn/tags/gradient/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Action自动部署Hexo到Gihub和Coding</title>
    <link href="https://weiweiblog.cn/github_action/"/>
    <id>https://weiweiblog.cn/github_action/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-05-17T07:27:05.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍我这个小站的持续集成方案（Continuous integration，简称CI）。什么是持续集成呢，简单说，就是把我写完文章后，markdown源代码的提交、Hexo静态网页的生成、Hexo网页的发布这一整个流程使用自动化的工具串起来，通过一个命令来触发这一系列的动作，从而使用户专注于写作，不用管后续一堆的事情。</p><p>以前用过Travis CI将Hugo自动部署到服务器上，而这次我选择当下比较火的Github Action，不为别的，代码都托管在Github上了，亲儿子Action不用应该是脑袋有坑了。</p><p>我的方案是<code>Github Action</code> + <code>Github</code> + <code>Coding</code>。就是通过Github Action把网页自动部署在Github和Coding上。这个方案其实网络上早就有挺多人实现的了，但是试了一圈，一直卡在自动部署到Coding上，最后才发现Coding最近改版了，原来的方案都不能拿来直接就用，需要稍微改下域名才可以。</p><h3 id="基本流程如下："><a href="#基本流程如下：" class="headerlink" title="基本流程如下："></a>基本流程如下：</h3><ol><li>创建密钥</li><li>创建Github源代码仓库（私有），并上传私钥</li><li>创建Github静态网页仓库（开启GitPage）,并上传公钥</li><li>创建Coding静态网页仓库，开上传私钥</li><li>在Github源代码仓库中编写Github Action代码，完成自动部署</li></ol><h3 id="1-创建密钥"><a href="#1-创建密钥" class="headerlink" title="1. 创建密钥"></a>1. 创建密钥</h3><p>在命令行窗口中输入下面一行（其中<a href="mailto:your_email@example.com">your_email@example.com</a>换成你的邮箱）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</span><br></pre></td></tr></table></figure><p>然后一直回车就会在你的<code>~/.ssh/</code>目录下生成<code>id_rsa.pub</code>公钥和<code>id_rsa</code>私钥两个文件，这两个文件的内容待会要复制到git仓库中作为通关密码。</p><h3 id="2-创建Github源代码仓库"><a href="#2-创建Github源代码仓库" class="headerlink" title="2. 创建Github源代码仓库"></a>2. 创建Github源代码仓库</h3><p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505225127.png" alt=""><br>在Github上创建一个私有仓库，注意选择<code>Private</code>，然后将Hexo整个项目的代码上传上到该仓库下：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505225412.png" alt=""></p><blockquote><p>注意: 上传的时候可能会遇到报错，原因是theme下的next模板中也是一个git项目，简单粗暴的解决方案就是把next文件夹中的.git文件都删除了，但是这样做也有个坏处，就是当next官方发布更新时，你就无法直接拉取更新了</p></blockquote><p>创建好了源代码仓库后，就可以设置私钥：在<code>Settings</code>-&gt;<code>Secrets</code>中选择<code>Add a new secret</code>:<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505230131.png" alt=""></p><p>然后填写<code>Name</code>和<code>Value</code>，其中Name可以自己设定（后面编写自动部署的代码时会用到），比如我设为<code>ACTION_DEPLOY_KEY</code>，而Value就是你刚才生成的密钥了，你可以在命令行窗口运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>就可以得到如下的输出<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505230523.png" alt=""><br>将输出的内容全部（包括<code>-----BEGIN OPENSSH PRIVATE KEY-----</code>和<code>-----END OPENSSH PRIVATE KEY-----</code>）复制到Value输入框中即可。</p><h3 id="3-创建Github静态网页仓库"><a href="#3-创建Github静态网页仓库" class="headerlink" title="3. 创建Github静态网页仓库"></a>3. 创建Github静态网页仓库</h3><p>在Github上创建另一个仓库，用于存放静态网页文件，并开启GitPage的功能。</p><p>创建的步骤就不用多说了，创建一个公开的仓库即可，然后把源代码的public文件中的内容上传到静态网页仓库。接着上传公钥，在<code>Settings</code>-&gt;<code>Deploy keys</code>中选择<code>Add deploy key</code>:</p><p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231415.png" alt=""><br>其中<code>Title</code>可以随便取名，<code>key</code>的内容来源于第一步设置的公钥，在命令行窗口中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231638.png" alt=""><br>然后将输出的内容复制到key中即可。</p><p>同时，不要忘记开启GitHub Pages的功能，在<code>Settings</code>-&gt;<code>Options</code>中，往下拉找到GitHub Pages并启用它，如果你用自己的域名，还可以顺带设置Custom domain：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231945.png" alt=""></p><h3 id="4-创建Coding静态网页仓库"><a href="#4-创建Coding静态网页仓库" class="headerlink" title="4. 创建Coding静态网页仓库"></a>4. 创建Coding静态网页仓库</h3><p>在Coding中创建一个项目，选择<code>DevOps项目</code><br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232217.png" alt=""><br>填写项目名称、项目地址等信息后，把静态网页的代码也上传到该仓库中<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232407.png" alt=""><br>然后在<code>代码仓库</code>的<code>设置</code>栏目中设置<code>部署公钥</code>，公钥名称可自定义，公钥内容内同第3步。<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232541.png" alt=""></p><p>之后在<code>持续部署</code>的<code>静态网站</code>中新建静态网站：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232838.png" alt=""></p><h3 id="5-在Github源代码仓库中编写Github-Action代码"><a href="#5-在Github源代码仓库中编写Github-Action代码" class="headerlink" title="5. 在Github源代码仓库中编写Github Action代码"></a>5. 在Github源代码仓库中编写Github Action代码</h3><p>在Github源代码仓库的<code>Action</code>页面中<code>New workflow</code>，然后选择<code>set up a workflow yourself</code><br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505233228.png" alt=""><br>接着在代码编辑框中输入自动部署的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">name: CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: macOS-latest  # 配置代码运行操作系统环境</span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions&#x2F;checkout@v1</span><br><span class="line">    - name: Use Node.js 12.x # 配置Node环境</span><br><span class="line">      uses: actions&#x2F;setup-node@v1 </span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;12.16.1&quot;</span><br><span class="line">    - name: Setup Hexo env  # 配置Hexo环境</span><br><span class="line">      env:</span><br><span class="line">        ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125;  # ACTION_DEPLOY_KEY在第2步中设置</span><br><span class="line">      run: |</span><br><span class="line">        # set up private key for deploy</span><br><span class="line">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">        echo &quot;$ACTION_DEPLOY_KEY&quot; | tr -d &#39;\r&#39; &gt; ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class="line">        ssh-keyscan e.coding.net &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts  # 注意，Coding的地址已经改成e.coding.net，很多教程中使用的地址都是旧的，导致无法完成部署</span><br><span class="line">        git config --global user.name &#39;wwwxmu&#39;  # 这里要将wwwxmu改为你的github和Coding的用户名（注意github和Coding的用户名必须相同）</span><br><span class="line">        git config --global user.email &#39;www@stu.xmu.edu.cn&#39; # 这里要将www@stu.xmu.edu.cn改为你的邮箱</span><br><span class="line">        npm i -g hexo-cli</span><br><span class="line">        npm i</span><br><span class="line">    - name: Deploy</span><br><span class="line">      run: |</span><br><span class="line">        # publish</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">        hexo deploy # 执行部署程序</span><br></pre></td></tr></table></figure><p>至此，所有设置都已经完成。接下来，你只要安心写作。写完之后，在源代码的根目录下依次运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m'修改哪些内容'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样，新的文章会自动推到github的源代码仓库，同时触发Github Action，将其发布到Github Page和Coding中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍我这个小站的持续集成方案（Continuous integration，简称CI）。什么是持续集成呢，简单说，就是把我写完文章后，markdown源代码的提交、Hexo静态网页的生成、Hexo网页的发布这一整个流程使用自动化的工具串起来，通过一个命令来触发这一系列的动作，从而使用户专注于写作，不用管后续一堆的事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站建设" scheme="https://weiweiblog.cn/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="hexo" scheme="https://weiweiblog.cn/tags/hexo/"/>
    
      <category term="Github Action" scheme="https://weiweiblog.cn/tags/Github-Action/"/>
    
      <category term="Coding" scheme="https://weiweiblog.cn/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>博客更新【2020-03-26】</title>
    <link href="https://weiweiblog.cn/new_blog/"/>
    <id>https://weiweiblog.cn/new_blog/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-05-17T07:27:05.324Z</updated>
    
    <content type="html"><![CDATA[<p>2019年9月，阿里云的学生优惠到期了，当时想着等双十一做活动的时候再买个服务器，给小站续命。奈何双十一的时候，这些大厂太不给力了，针对老用户的服务器动辄就要500+，真的是下不了手，于是乎小站就无限期下线。</p><p>今年疫情期间，稍微有点时间，于是想着稍微整理一下，把小站重新上线。</p><p>由于之间的网站是用Wordpress搭的，wordpress这个开源的工具搭起来很简单，但是它太重了，一个小小的网站，还需要php环境和mysql数据库，为此就得买一台服务器。本着节省的理念，这次就打算通过免费的方案来上线小站。</p><p>既然想要免费，那就不可能再去买台服务器了，那么Github Pages的服务就是首选了。Github Pages可以免费发静态网页，我们用Markdown写作，然后使用一些开源的工具将其转换成静态网页，最到上传到Github上，整个流程操作起来很顺手，重点是<code>免费</code>。</p><p>说到静态网站生成器，那好东西真的不要太多，随便一抓就是一大把，像是<code>Hexo</code>，<code>Hugo</code>，<code>Pelican</code>等等。一开始，我是比例倾向于选择<code>Pelican</code>的，就因为它是Python开发的，毕竟：</p><blockquote class="blockquote-center">            <p>人生苦短，我用Python</p>          </blockquote><p>Python这么火，我怎么能弃它而不用呢？于是我就开始选主题了，但是把Github上的Pelican主题看了一遍，真的是太丑了。作为一个这么看重颜值的人，怎么能忍，于是就想着从其它地方的主题挑一个来改造迁移。最后选了hexo的next，然后看了Jinja2的语法就开始干，写着写着发现真TM太难了，没什么前端技能树的我只好半途放弃。。。</p><p>排除Pelican后，我最看好Hexo和Hugo，对比了一下，大家都在说Hexo很慢，Hugo超快。于是就打算使用Hugo了，然后又开始挑主题，Hugo的主题相对于Pelican真的是好很多了，但是看了一圈还是没有能让我很满意的。</p><p>最后，我把目光锁定在了Hexo，然后选重了<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a>这个Github上有<code>5.3k</code>start的主题，更新还很频繁。经过一翻折腾，跟着说明文档进行配置，对几个不是很满意的地方通过代码硬改，终于有了你现在看到的这个小站。</p><p>啰嗦了一堆，就当记流水账了，后面会把配置过程中踩过的一些坑记录一下，让大家在部署的过程中可以节约点时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年9月，阿里云的学生优惠到期了，当时想着等双十一做活动的时候再买个服务器，给小站续命。奈何双十一的时候，这些大厂太不给力了，针对老用户的服务器动辄就要500+，真的是下不了手，于是乎小站就无限期下线。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站建设" scheme="https://weiweiblog.cn/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="hexo" scheme="https://weiweiblog.cn/tags/hexo/"/>
    
      <category term="next" scheme="https://weiweiblog.cn/tags/next/"/>
    
      <category term="SEO" scheme="https://weiweiblog.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Facebook 推出PyTorch Hub，使模型的复现不再困难</title>
    <link href="https://weiweiblog.cn/pytorchhub/"/>
    <id>https://weiweiblog.cn/pytorchhub/</id>
    <published>2019-06-13T07:27:47.000Z</published>
    <updated>2020-05-17T07:27:05.329Z</updated>
    
    <content type="html"><![CDATA[<p>可复现性是机器学习研究的重要组成部分，它能够验证所提出的模型是否达到了承诺的性能。当研究人员提交新论文时，他们通常会在GitHub上开源其预训练模型的代码和参数，以便其他人了解他们是否能够实现已发布的实验结果。然而，在加载模型以进行复现测试时涉及许多耗时的步骤。</p><p>为了提供更流畅的复制体验，Facebook宣布推出PyTorch Hub，这是一个新的预训练模型库，旨在促进模型的可复现性。由于其无与伦比的灵活性和强大功能，PyTorch是最受青睐的机器学习框架之一。 Facebook在上个月的F8开发者大会上发布了PyTorch v1.1，其中包括TensorBoard和JIT编译器等主要功能。</p><p>PyTorch Hub允许用户通过发送拉取请求来发布模型，并仅使用一行代码加载模型。以下是PyTorch Hub的主要功能的具体描述：</p><ol><li>发布模型：PyTorch Hub支持通过添加一个简单的hubconf.py文件将预训练模型（模型定义和预训练权重）发布到GitHub存储库，该文件提供运行模型所需的受支持模型和依赖项列表。</li></ol><p>在研究人员发送拉取请求后，Facebook PyTorch团队将帮助完善他们的拉取请求并决定是否接受它。接受的发布模型最终会出现在PyTorch Hub网页上。</p><ol start="2">  <li>    加载模型：用户可以使用torch.hub.load（）API加载预先训练的模型。下面是从pytorch / vision repo加载resnet18入口点的代码。  </li></ol><p>model = torch.hub.load（&#8217;pytorch / vision&#8217;，&#8217;resnet18&#8217;，pretrained = True）</p><p>PyTorch Hub目前可容纳18种备受瞩目的机器学习模型，包括谷歌的BERT，由Hugging Face重新实现，以及由Facebook AI Research推出的PGANs。用户还可以在Colab和Papers With Code上查看这些和其他模型。 Facebook表示，PyTorch Hub将很快为开发人员提供即插即用型号，以进一步加速机器学习模型的可重复性测试和开发。</p><p>有关PyTorch Hub项目页面的更多信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可复现性是机器学习研究的重要组成部分，它能够验证所提出的模型是否达到了承诺的性能。当研究人员提交新论文时，他们通常会在GitHub上开源其预训练模型的代码和参数，以便其他人了解他们是否能够实现已发布的实验结果。然而，在加载模型以进行复现测试时涉及许多耗时的步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://weiweiblog.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>开源的Rufus，史上最好用的系统盘制作工具</title>
    <link href="https://weiweiblog.cn/rufus/"/>
    <id>https://weiweiblog.cn/rufus/</id>
    <published>2019-06-06T22:59:35.000Z</published>
    <updated>2020-05-17T07:27:05.332Z</updated>
    
    <content type="html"><![CDATA[<p>好像没有重装系统了，以前重装的时候都是使用windows提供的 USB/DVD Download Tool，这个工具是挺方法便的，安装上就可以用，但是win10安装这个工具就比较蛋疼，还要先安装.net framework2.0。于是我就寻思有没有更方便的系统盘刻录工具，还真让我找着了。</p><p>Rufus 是一个可以帮助格式化和创建可引导USB闪存盘的工具，比如 USB 随身碟，记忆棒等等。</p><p>在如下场景中会非常有用：</p><ul><li>你需要把一些可引导的ISO格式的镜像（Windows，Linux，UEFI等）创建成USB安装盘的时候</li><li>你需要使用一个还没有安装操作系统的设备的时候</li><li>你需要从DOS系统刷写BIOS或者其他固件的时候</li><li>你需要运行一个非常底层的工具的时候</li></ul><p>Rufus 麻雀虽小，五脏俱全，体积虽小，功能全面。</p><p>我选择Rufus，主要有两个原因</p><p>一、它不需要安装，拆箱即用。</p><p>二、它的速度还很快，飞一般的感觉。</p><p>Rufus刻录系统u盘的步骤很简单，</p><p><img src="https://cdn.weiweiblog.cn/20190607144800.png" alt=""></p><p>插上u盘，打开Rufus后，它会自动选中你的u盘，然后选择要事先下载好的系统，最后，也是最重要的一步，要选择分区类型和目标系统类型。这需要根据你的电脑的启动方案来选，如果是比较旧的电脑，一般选择MBR就可以，如果比较新的电脑，就选GPT。</p><p>关于MBR和GPT有什么区别，MBR只能支持4个主分区，而GPT则本身无限制，MBR不支持2TB以上的硬盘，GPT则最多支持到18EB。GPT是一种新的标准，会逐渐取代MBR。具体的差别可以自行Google了解。</p><p>选完之后点开始就可即刻录了，等待进度条跑完就可以拔出u盘，开始愉快地重装了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像没有重装系统了，以前重装的时候都是使用windows提供的 USB/DVD Download Tool，这个工具是挺方法便的，安装上就可以用，但是win10安装这个工具就比较蛋疼，还要先安装.net framework2.0。于是我就寻思有没有更方便的系统盘刻录工具，还真让我找着了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="搞事情" scheme="https://weiweiblog.cn/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
  </entry>
  
  <entry>
    <title>互联网校招面试必备——计算机网络</title>
    <link href="https://weiweiblog.cn/network/"/>
    <id>https://weiweiblog.cn/network/</id>
    <published>2018-09-24T21:11:31.000Z</published>
    <updated>2020-05-17T07:27:05.323Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OSI，TCP-IP，五层协议的体系结构"><a href="#OSI，TCP-IP，五层协议的体系结构" class="headerlink" title="OSI，TCP/IP，五层协议的体系结构"></a>OSI，TCP/IP，五层协议的体系结构</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvinzmukkaj30ib08tq4b.jpg" alt=""></p><h4 id="每一层的作用："><a href="#每一层的作用：" class="headerlink" title="每一层的作用："></a>每一层的作用：</h4><ul><li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li><li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li><li>网络层：负责数据包从源到宿的传递和网际互连（包Packet）</li><li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li><li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li><li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li><li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li></ul><h4 id="每一层的协议："><a href="#每一层的协议：" class="headerlink" title="每一层的协议："></a>每一层的协议：</h4><ul><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：TCP、UDP、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ul><h4 id="TCP对应的应用层协议"><a href="#TCP对应的应用层协议" class="headerlink" title="TCP对应的应用层协议"></a>TCP对应的应用层协议</h4><ul><li>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li><li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li><li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li><li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li></ul><h4 id="UDP对应的应用层协议"><a href="#UDP对应的应用层协议" class="headerlink" title="UDP对应的应用层协议"></a>UDP对应的应用层协议</h4><ul><li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li><li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li></ul><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p><img src="https://cdn.weiweiblog.cn/20180924164212.png" alt=""></p><ul><li>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 &#8211; 126.255.255.255）；</li><li>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 &#8211; 191.255.255.255）；</li><li>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 &#8211; 223.255.255.255）；</li></ul><p>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>ARP地址解析协议，简单说就是，在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。它的工作原理如下：</p><ol><li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p></li><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></li><li><p>如果目标IP与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的MAC地址。如果arp高速缓存有默认网关的MAC地址，直接发送IP数据报道默认网关，再由网关转发到外网；如果arp高速缓存没有默认网关的MAC地址，还是发送ARP广播请求默认网关的MAC地址，缓存该地址，并且发送数据报到网关。</p></li></ol><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下：</p><ul><li>支持客户/服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><h4 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h4><p><img src="https://cdn.weiweiblog.cn/20180924163958.png" alt=""></p><p><strong>三次握手：</strong>(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)</p><ul><li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>四次挥手：</strong>(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：</p><ul><li>第一次挥手：客户端主动关闭方发送一个FIN，用来关闭客户端到服务端的数据传送，也就是客户端告诉服务端：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。</li><li>第二次挥手：服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li><li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。</li><li>第四次挥手：客户端收到FIN后，发送一个ACK给服务端，确认序号为收到序号+1，至此，完成四次挥手。</li></ul><h3 id="第3次握手失败会怎么办"><a href="#第3次握手失败会怎么办" class="headerlink" title="第3次握手失败会怎么办?"></a>第3次握手失败会怎么办?</h3><p>第三次失败，只有客户端处于成功状态（因为第2次服务器返回了ACK），服务器端没有接收到客户端的 ACK。</p><p>这要分几种情况讨论：</p><ul><li>In other words, if the ACK is dropped but the next packet is not dropped, then everything is fine. 也就是说客户端发出的 ACK 丢失了，发出的 下一个数据包 没有丢失，则服务端接收到下一个数据包（这个数据包里也会带上 ACK 信息），能够进入正常的 ESTABLISHED 状态</li><li>如果服务端和客户端都没有数据发送，或者服务端想发送数据（但是发不了，因为没有收到客户端的 ACK），服务器都会有定时器发送第二步SYN+ACK数据包，如果客户端再次发送ACK成功，建立连接。</li><li>如果一直不成功，服务器肯定会有超时设置，超时之后会给客户端发RTS报文，进入CLOSED状态，防止SYN洪泛攻击。</li></ul><h4 id="为什么TCP链接需要三次握手，两次不可以么，为什么？"><a href="#为什么TCP链接需要三次握手，两次不可以么，为什么？" class="headerlink" title="为什么TCP链接需要三次握手，两次不可以么，为什么？"></a>为什么TCP链接需要三次握手，两次不可以么，为什么？</h4><p>为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p><p>客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p><h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手?"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手?</h4><p>TCP是全双工模式，关闭连接时，当主机B收到主机A的FIN报文时，仅仅表示主机 A不再发送数据了但是还能接收数据。此时，主机B也未必全部数据都发送给A了，所以B可以立即close；也可以发送一些数据给A后，再发送FIN报文给对方来表示同意现在关闭连接，因此，主机BACK和FIN一般都会分开发送。</p><h4 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h4><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p><ul><li><p>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p></li><li><p>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p><p><img src="https://cdn.weiweiblog.cn/20180924232335.png" alt=""></p> </p></li><li><p>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><img src="https://cdn.weiweiblog.cn/20180924232545.png" alt=""></p></li><li><p>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p><p><img src="https://cdn.weiweiblog.cn/20180924232756.png" alt=""></p></li></ul><h4 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h4><p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p><p>对于可靠性，TCP通过以下方式进行保证：</p><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h4 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h4><ol><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h4 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h4><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p><p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p><p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p><p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p><p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p><h4 id="交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？"><a href="#交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？" class="headerlink" title="交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？"></a>交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？</h4><p>交换机用于局域网，利用主机的MAC地址进行数据传输，而不需要关心IP数据包中的IP地址，它工作于数据链路层。路由器识别网络是通过IP数据包中IP地址的网络号进行的，所以为了保证数据包路由的正确性，每个网络都必须有一个唯一的网络号。路由器通过IP数据包的IP地址进行路由的（将数据包递交给哪个下一跳路由器）。路由器工作于网络层。由于设备现在的发展，现在很多设备既具有交换又具有路由功能，两者的界限越来越模糊。</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul><li><p>TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p></li><li><p>UDP的优点：快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……</p><p>有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率</p></li></ul><table><thead><tr><th align="center"></th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">连接</td><td align="center">面向连接</td><td align="center">面向无连接</td></tr><tr><td align="center">可靠性</td><td align="center">可靠，无差错，不丢失，不重复</td><td align="center">尽最大努力交付，即不保证可靠交付</td></tr><tr><td align="center">模式</td><td align="center">流模式（字节流）</td><td align="center">数据报模式（报文）</td></tr><tr><td align="center">连接</td><td align="center">点到点</td><td align="center">支持一对一，一对多，多对一和多对多的交互通信</td></tr><tr><td align="center">首部开销</td><td align="center">20字节</td><td align="center">8个字节</td></tr><tr><td align="center">逻辑通信信道</td><td align="center">全双工的可靠信道</td><td align="center">不可靠信道</td></tr><tr><td align="center">速度</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">对系统资源要求</td><td align="center">较多</td><td align="center">较少</td></tr></tbody></table><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fv3g1mp6aej30lb0a7dgw.jpg" alt=""></p><ul><li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li><li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li></ul><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h4 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h4><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；</p><p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p><h4 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h4><p>由于公有密钥的机制相对复杂，导致其处理速度相对较慢。于是HTTPS利用了两者的优势，采用了混合加密的机制。我们知道，共享（对称）密钥未能解决的问题是如何能够安全地把密钥发送给对方。只要解决了这个问题就可以进行安全地通信。于是，HTTPS首先是通过公有密钥来对共享密钥进行加密传输。当共享密钥安全地传输给对方后，双方则使用共享密钥的方式来加密报文，以此来提高传输的效率。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fv3g11oy5nj30h80evdh9.jpg" alt=""></p><p>步骤1：向服务器发起请求。</p><p>步骤2-3：取出公有密钥及证书并发送给客户端。</p><p>步骤4：客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。</p><p>步骤5：用步骤3得到的公有密钥对该随机数串加密，发送到服务器。</p><p>步骤6：服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。</p><p>步骤7-8：服务器对响应进行加密，客户端对报文进行解密。</p><h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>socket是通信的基石。支持TCP/IP等协议的基本操作单元。</p><p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.nowcoder.com/discuss/1937" target="_blank" rel="noopener">计算机网络之面试常考</a></p><p><a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">面试/笔试第一弹 —— 计算机网络面试问题集锦</a></p><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OSI，TCP-IP，五层协议的体系结构&quot;&gt;&lt;a href=&quot;#OSI，TCP-IP，五层协议的体系结构&quot; class=&quot;headerlink&quot; title=&quot;OSI，TCP/IP，五层协议的体系结构&quot;&gt;&lt;/a&gt;OSI，TCP/IP，五层协议的体系结构&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="计算机网络" scheme="https://weiweiblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图床折腾记</title>
    <link href="https://weiweiblog.cn/tuchuang/"/>
    <id>https://weiweiblog.cn/tuchuang/</id>
    <published>2018-09-23T23:25:18.000Z</published>
    <updated>2020-05-17T07:27:05.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文比较杂碎，全程记录下七牛云图床申请SSL免费证书，绑定域名，配置MWeb七牛云服务的过程。</p></blockquote><blockquote><p>多图预警，手机流量较少者请在wifi环境下浏览。 </p></blockquote><p>这两天，iPic这个MacOS上的图床神器免费版的一直上传失败，可窝火了！估计是自动登陆微博的机制了出问题了吧。。。</p><p>iPic确实挺好用的，可以很方便地实现图片上传图床，复制markdown链接，但是现在免费版的上传微博图床上传失败，又用不起收费版的（一年订阅要68块大洋～～～），只能另想他法。</p><p>一直是用MWeb在写东西，它用自动发布博客和图片自动上传图床的功能，不过之前都没有用起来，这次趁着iPic用不了，就想着把mweb这套流程跑起来，在本地写完文章后，可以自动上传图床，并发布到wordpress。</p><p>mweb支持上传的图床有Google Photos, imgur, 七牛云存储，又拍云和自定义，竟然不支持微博和github，那只能用七牛云存储了。</p><p><img src="https://cdn.weiweiblog.cn/20180924135637.png" alt=""></p><p>七牛云一个月赠送10G存储空间，20G下载流量，10w的put和100w的getAPI请求次数。对于一个访问量不大的网站，这些赠送的额度是绰绰有余的。</p><p><img src="https://cdn.weiweiblog.cn/20180924141138.png" alt=""></p><p>之前已经在七牛云上创建过一个存储空间了，但是它分配的是一个测试域名，还不支持HTTPS，而我的网站已经全站支持HTTPS了，所以之前那个测试域名我是不想用了，必须自己再绑定一个域名，设置通信协议为HTTPS。步骤如下：</p><p>首先你要有一个备案的域名，如果不知道如何备案域名，请移步<a href="https://www.weiweiblog.cn/beian/" target="_blank" rel="noopener">10天搞定域名备案（全记录）</a>，然后你得给你的域名申请SSL证书，刚好七牛云有提供一年免费的SSL证书。</p><p><img src="https://cdn.weiweiblog.cn/20180924143001.png" alt=""></p><p>在<code>管理控制台</code>-&gt;<code>SSL证书服务</code>点击<code>购买证书</code>按钮</p><p><img src="https://cdn.weiweiblog.cn/20180924143124.png" alt=""></p><p>可以看到TrustAsia有限免，点击限免的，拉到最下面有核对信息并支付</p><p><img src="https://cdn.weiweiblog.cn/20180924143902.png" alt=""></p><p>确认支付</p><p><img src="https://cdn.weiweiblog.cn/20180924143957.png" alt=""></p><p>之后会提示支付成功，并让你补全信息</p><p><img src="https://cdn.weiweiblog.cn/20180924144021.png" alt=""></p><p>这边我用的是qiniu.weiweiblog.cn这个二级域名，因为<a href="http://www.weiweiblog.cn已经用到我的网站上了，你可以根据你的实际情况填写" target="_blank" rel="noopener">www.weiweiblog.cn已经用到我的网站上了，你可以根据你的实际情况填写</a></p><p><img src="https://cdn.weiweiblog.cn/20180924144416.png" alt=""></p><p>剩下的基本信息就根据你的实际情况填写，提交后会显示待确认</p><p><img src="https://cdn.weiweiblog.cn/20180924144913.png" alt=""></p><p>这时候就需要去你的域名管理商那边添加一条TXT记录，进行域名验证。</p><p>以阿里云为例，添加一条记录，选择TXT记录类型，填入七牛云给的TXT记录名和TXT记录值</p><p><img src="https://cdn.weiweiblog.cn/20180924145236.png" alt=""></p><p>过几分钟，等待验证通过，订单状态就会变成已签发。</p><p><img src="https://cdn.weiweiblog.cn/20180924145635.png" alt=""></p><p>点击<code>我的证书</code>，可以看到多了一条记录</p><p><img src="https://cdn.weiweiblog.cn/20180924145756.png" alt=""></p><p>至此，SSL证书就申请完成了。</p><p>接下来，我们就可以配置域名了</p><p>在<code>对象存储</code>页面点击<code>绑定域名</code></p><p><img src="https://cdn.weiweiblog.cn/20180924150016.png" alt=""></p><p>输入刚才申请SSL证书的二级域名</p><p><img src="https://cdn.weiweiblog.cn/20180924150218.png" alt=""></p><p>选择HTTPS，如果刚才申请SSL证书成功，在<code>请选择证书</code>旁边的下拉框会出现你的域名供你选择</p><p><img src="https://cdn.weiweiblog.cn/20180924150338.png" alt=""></p><p>选择好之后，就可以拉到最下面，点击创建</p><p><img src="https://cdn.weiweiblog.cn/20180924150646.png" alt=""></p><p>再回到对象存储的页面，<code>融合 CDN 加速域名</code>的模块下面多了条记录，这时的状态还不是成功，还需要到你的域名服务商配置CNAME，具体配置方法旁边有说明。配置完成之后，状态就变为<code>成功</code>，这时候你的域名就可以使用了。</p><p>然后，我们回到MWeb，<code>偏好设置</code>-&gt;<code>发布服务</code>，选择<code>七牛云存储</code></p><p><img src="https://cdn.weiweiblog.cn/20180924151305.png" alt=""></p><p>填入对应的信息后就设置好了。</p><p>当你写完文章后，点击把本地图片上传至图床</p><p><img src="https://cdn.weiweiblog.cn/20180924151713.png" alt=""></p><p>信息框里就会显示本地所有的图片</p><p><img src="https://cdn.weiweiblog.cn/20180924151803.png" alt=""></p><p>点击上传本地图片后，就可以自动上传本地所有的图片</p><p>至此，图床就折腾完毕了，再配置一下自动发布到wordpress，就不会出现本地的图片，发布后图片不显示的问题了。</p><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文比较杂碎，全程记录下七牛云图床申请SSL免费证书，绑定域名，配置MWeb七牛云服务的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="网站建设" scheme="https://weiweiblog.cn/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>10天搞定域名备案（全记录）</title>
    <link href="https://weiweiblog.cn/beian/"/>
    <id>https://weiweiblog.cn/beian/</id>
    <published>2018-09-23T22:27:20.000Z</published>
    <updated>2020-05-17T07:27:05.252Z</updated>
    
    <content type="html"><![CDATA[<p>前年12月在万网买了个域名，然后就没有然后了。。。</p><p>直到前几天又开始想好好建设一下个人主页，于是有了备案域名的想法，那就Just do it</p><h1 id="3月8日"><a href="#3月8日" class="headerlink" title="3月8日"></a>3月8日</h1><p>既然域名是在万网买的，那就直接用阿里云的代备案系统了（由于当时没有截图，下面图片均出自<a href="https://help.aliyun.com/knowledge_detail/6563875.html?spm=5176.200021.n2.18.Ql8xA4#万网主机网站备案指南" target="_blank" rel="noopener">万网主机网站备案指南</a>）</p><blockquote><p><a href="https://beian.gein.cn/order/index.htm" target="_blank" rel="noopener">https://beian.gein.cn/order/index.htm</a> </p></blockquote><p>1、看一下首次备案流程：</p><p><img src="http://upload-images.jianshu.io/upload_images/1670644-fa23aabcb5653fc6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt"></p><p>2、注册账号</p><p><img src="https://img.alicdn.com/tps/i3/TB1az5kGVXXXXcJXpXXvYGVGpXX-700-368.png" alt="">   </p><p>3、进入填写的邮箱查看邮件,完成登录账户注册</p><p><img src="https://img.alicdn.com/tps/i2/TB1GvORGVXXXXcBXpXXOGKKGpXX-700-307.jpg" alt=""></p><p>4、登录备案系统</p><p>根据您填写备案域名以及主体信息，进行验证备案类型</p><p><img src="https://img.alicdn.com/tps/i4/TB1aBKKGVXXXXcgXVXXZp6XGpXX-700-487.png" alt=""></p><p>5、验证产品</p><p>根据填写的备案域名等信息判断此次备案为首次备案，继续填写产品信息验证产品</p><p><img src="https://img.alicdn.com/tps/i1/TB1g9qHHXXXXXc7aXXXqOG3GpXX-700-439.png" alt=""> </p><p>这里需要阿里云主机或者万网虚拟主机，我购买的是33元的<a href="http://click.aliyun.com/m/3646/?spm=a3c00.7621327.a3c20.3.oFqcro" target="_blank" rel="noopener">云虚机主机免费版极速礼包</a>，购买之后，主可以在主机管理界面找到相应的控制台用户名及密码用于验证：</p><p><img src="http://upload-images.jianshu.io/upload_images/1670644-5f7e51deb0ee1eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>6、填写主体信息</p><p><img src="https://img.alicdn.com/tps/i3/TB1ySCTGVXXXXaPXpXXM1y3GpXX-700-438.png" alt=""> </p><p><img src="https://img.alicdn.com/tps/i1/TB1YFuZGVXXXXaQXXXX4O54GpXX-700-446.png" alt=""></p><p>7、填写网站信息</p><p><img src="https://img.alicdn.com/tps/i4/TB1QcqTGVXXXXboXpXXQe2bGpXX-700-499.png" alt=""> </p><p><img src="https://img.alicdn.com/tps/i2/TB1ICaLGVXXXXXZXVXXHRy_GpXX-700-509.png" alt=""></p><p>8、上传备案资料（注：我第一次上传的时候用的是Chrome浏览器，遇到无法上传的情况，之后改用Microsoft Edge浏览器就可以上传了）</p><p><img src="https://img.alicdn.com/tps/i1/TB1g7WGGVXXXXaYaXXXUKSUGpXX-700-365.jpg" alt=""> </p><p><img src="https://img.alicdn.com/tps/i4/TB11JmPGVXXXXbXXFXXkjOMGpXX-700-293.jpg" alt=""></p><p><img src="https://img.alicdn.com/tps/i3/TB1C_STGVXXXXaaXpXXcNS1GpXX-700-428.png" alt=""></p><p>9、提交备案至初审（阿里云效率还是很高的，当天就会打电话过来告诉你初审情况。。。然而我没有注意，错过了三个电话。。。）</p><p><img src="https://img.alicdn.com/tps/i3/TB1T21YGVXXXXbiXXXXvgyDGpXX-700-239.png" alt="">  </p><h1 id="3月9日"><a href="#3月9日" class="headerlink" title="3月9日"></a>3月9日</h1><p>第二天初审没有通过，原因是网站的名称不符合规定，所以第二天我又改了名称重新提交初审，并且时时关注来自杭州的电话，终于下午阿里云的工作人员打电话来了，告诉我网站名称又一次不符合规定，并让我当场改一个,ps：工作人员态度还是很好的，还给了很多建议，然后初审就过啦<del>~</del></p><p>10、初审通过后，可进行拍照核</p><p><img src="https://img.alicdn.com/tps/i2/TB1JamSGVXXXXbMXpXX1ACZGpXX-700-391.jpg" alt=""> </p><p>因为我在内蒙偏远地区支教，所以没法前往拍照核验点拍照，所以选择方法2，申请邮寄幕布，自行拍照后上传，花了15软妹币，发顺丰。</p><p>#3月14日</p><p>因为是偏远地区，所以顺丰也要5天才到。。。</p><p>收到幕布后马上拍照上传（就不上图啦<del>）</del></p><p>11、提交照片，等待审核</p><p><img src="https://img.alicdn.com/tps/i1/TB1On5UGVXXXXXzXpXXUf9CGpXX-700-235.png" alt=""> </p><p>当天就收到审核通过的信息</p><blockquote><p>您的备案信息已通过阿里云审核，即将提交至通信管理局审核！ </p></blockquote><p>12、待提交管局审核</p><p><img src="https://img.alicdn.com/tps/i1/TB1Yu5YGVXXXXXDXXXX.DSrGpXX-700-146.png" alt=""></p><p>13、等待管局审核</p><p><img src="https://img.alicdn.com/tps/i1/TB1DAmTGVXXXXaRXpXXpFaFGpXX-700-251.png" alt=""> </p><p>#3月18日</p><p>14、备案成功；</p><p>审核结果将以短信及邮件形式通知</p><p><img src="https://img.alicdn.com/tps/i2/TB11suSGVXXXXcxXpXXaqUwGVXX-701-365.jpg" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/1670644-99545f2760b62e6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>至此，咱的网站也是用“户口”的啦<del>~</del></p><p>阿里云代备案效率还是挺高的，很多审核当天就搞定，要不是我身处偏远地区，一星期内肯定能搞定</p><p>接下来要好好装修我的个人主页啦，吼吼！！</p><p>个人主页：尾尾部落<a href="http://www.weiweiblog.cn" target="_blank" rel="noopener">www.weiweiblog.cn</a></p><p>欢迎加友链<del>~</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前年12月在万网买了个域名，然后就没有然后了。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站建设" scheme="https://weiweiblog.cn/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>记一次DigitalOcean欠费、删除账号、充错账号、退款经历</title>
    <link href="https://weiweiblog.cn/digitalocean_refund/"/>
    <id>https://weiweiblog.cn/digitalocean_refund/</id>
    <published>2018-09-22T01:34:02.000Z</published>
    <updated>2020-05-17T07:27:05.257Z</updated>
    
    <content type="html"><![CDATA[<p>之前用github的学生优惠申请了digitalocean的一台vps，但是因为已经有一台腾讯云，所以digitalocean就没怎么用，荒废着长草。</p><p>时间就这么如白驹过隙，一晃一年就过去了，digitalocean送的额度在8月份就用完了，9月就收费了，于是我就收到这样的邮件，说我欠费了，还欠了3.37刀。我以为欠费了，它会自动把我服务器关了，反正里面也没有要备份的东西，我就没管了。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvifgolh3fj317609etay.jpg" alt=""></p><p>谁知道，没过几天，我又收到了digitalocean的欠费提醒邮件，而且，这次的金额还变多了，从$3.37变成3.72。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fviflywiqwj3192080mz4.jpg" alt=""></p><p>我开方了，Google了一下，发现很多骂DigitalOcean的：垃圾DigitalOcean，欠费不停机。。。</p><p>原来，按时计费的，你的VPS开了一小时就收一小时的费用，但是欠费了它也不会自己给你停机。</p><p>于是，赶紧登录DigitalOcean自己把vps停了，删除掉，然后把欠款给补上（毕竟咱是有诚信的）</p><p>然鹅，因为我有两个DigitalOcean，都是记住密码可以自动登录的，我充值的时候，登陆的是另一个账号，结果，是的，我充错账号了-_-|||&#8230;</p><p>所以，这时候，我两个账号的状态是：</p><ol><li><p>一个账号欠着款</p></li><li><p>另一个账号啥都没干就充了5刀进去</p></li></ol><p>我真是脑袋进水。。。</p><p>于是，赶紧找找有没有退款的按钮，找了半天啥都没有，Google了一下，有的说DigitalOcean不支持退款，有的说给客服发邮件可以退款。。。我就死马当活马医，给客服<a href="mailto:support@support.digitalocean.com">support@support.digitalocean.com</a>发了如下邮件，</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvig0rfp2zj30ty0aemyy.jpg" alt=""></p><p>直接用中文发的，但是貌似对方系统不支持显示中文，他们看到的是乱码吧，估计没看懂，给我回了如下的邮件，让我提供更多的信息</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvig3aeoumj31a00koq7o.jpg" alt=""></p><p>于是我学乖了，直接给发蹩脚的英文过去</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvig4maje9j31b80kqwhm.jpg" alt=""></p><p>这次他们就看懂了，也很及时地给我回复，说钱已经原路返回，退回paypal里了</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvig55skvaj315q0ciq4y.jpg" alt=""></p><p>我到paypal里一看，果然有一条退款记录，并且已经退回到银行卡，但是我一查银行卡，里面的钱还没到账，据说要7天到30天左右才能到账。。。</p><p>至些，我的5刀也算是失而复得了。至于那个欠费的账号呢，我发现它有个删除账号的按钮，于是我就点了一下，然后，账号就没了，没了，没了。。。</p><p>然后就没有然后了。。。</p><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用github的学生优惠申请了digitalocean的一台vps，但是因为已经有一台腾讯云，所以digitalocean就没怎么用，荒废着长草。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站建设" scheme="https://weiweiblog.cn/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="云服务器" scheme="https://weiweiblog.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>简书作者信息统计</title>
    <link href="https://weiweiblog.cn/jianshu/"/>
    <id>https://weiweiblog.cn/jianshu/</id>
    <published>2018-09-22T00:55:46.000Z</published>
    <updated>2020-05-17T07:27:05.314Z</updated>
    
    <content type="html"><![CDATA[<p>从2016年就开始在简书上写文章，之所以选择这个平台，很大程度上是因为它洁简的后台输入界面，支持MD，非常适合写一些技术类的文章。</p><p>从最开始的零星几个粉丝，到粉丝数破百，到现在有700+粉丝，虽然离大牛们动辄数十万的粉丝还有很大的差距，但是看着粉丝数一天天上涨，感觉也很有成就感。于是就想着记录下粉丝数增涨的过程，以后当粉丝数上万后可以回头看看自己是怎么一步一步走到今天的（此处应该是意淫的表情）。但是，也许是简书太乞求简洁，后台都不提供作者粉丝数历史记录的，不像微信公众号、头条、熊掌号这些成熟的自媒体平台，都会给作者提供完善的相关数据记录，让作者可以清晰地跟踪自己粉丝数增长的曲线。</p><p>既然简书不提供，自己又希望有这个功能，又不想放弃简书这个平台，那就自己动手，丰衣足食吧。实现起来也很简单，思路如下：</p><ol><li>写个爬虫，每天定时爬取自己简书账号的各项指标数据（包括粉丝数、喜欢数、文章数等）</li><li>写一个页面，用来做数据展示 <a href="https://jianshu.weiweiblog.cn/j/67eb7ed414d3" target="_blank" rel="noopener">简书信息统计展示页面</a></li><li>没了，就是这么简单。</li></ol><blockquote><p>Talk is cheap, Show you the code</p></blockquote><blockquote><p>上代码，这里附上爬虫的代码，展示页面做得还不是很完善，就不献丑了。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomUserAgent</span><span class="params">()</span>:</span></span><br><span class="line">    USER_AGENTS = [</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20"</span>,</span><br><span class="line">        <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random.choice(USER_AGENTS)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span><span class="params">(url, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'headers'</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        kwargs[<span class="string">'headers'</span>] = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: randomUserAgent(),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    r = requests.get(url, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getArticleInfo</span><span class="params">(user)</span>:</span></span><br><span class="line">    print(<span class="string">"==getArticleInfo=="</span>)</span><br><span class="line">    uid = user[<span class="string">'uid'</span>]</span><br><span class="line">    article_num = int(user[<span class="string">'article_nums'</span>])</span><br><span class="line">    PER_NUM = <span class="number">9</span></span><br><span class="line">    max_page = int(article_num / PER_NUM) <span class="keyword">if</span> (article_num % PER_NUM) == <span class="number">0</span> <span class="keyword">else</span> int(article_num / PER_NUM)+<span class="number">1</span></span><br><span class="line">    article_urls = [<span class="string">'https://www.jianshu.com/u/&#123;&#125;?order_by=shared_at&amp;page=&#123;&#125;'</span>.format(uid, i) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                    range(<span class="number">1</span>, max_page+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    details = []</span><br><span class="line">    <span class="keyword">for</span> article_url <span class="keyword">in</span> article_urls:</span><br><span class="line">        r = getResponse(article_url)</span><br><span class="line">        dom = etree.HTML(r.text)</span><br><span class="line">        items = dom.xpath(<span class="string">'//ul[@class="note-list"]/li'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="comment"># 对每个 li标签再提取</span></span><br><span class="line">            details_xpath = &#123;</span><br><span class="line">                <span class="string">'link'</span>: <span class="string">'./div/a/@href'</span>,</span><br><span class="line">                <span class="string">'title'</span>: <span class="string">'./div/a/text()'</span>,</span><br><span class="line">                <span class="string">'read_num'</span>: <span class="string">'.//div[@class="meta"]/a[1]/text()'</span>,</span><br><span class="line">                <span class="string">'comment_num'</span>: <span class="string">'.//div[@class="meta"]/a[2]/text()'</span>,</span><br><span class="line">                <span class="string">'heart_num'</span>: <span class="string">'.//div[@class="meta"]/span[1]/text()'</span>,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_and_path = details_xpath.items()</span><br><span class="line">            detail = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, path <span class="keyword">in</span> key_and_path:</span><br><span class="line">                detail[key] = <span class="string">''</span>.join(item.xpath(path)).strip()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#将数字转换为整数</span></span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'read_num'</span>, <span class="string">'comment_num'</span>, <span class="string">'heart_num'</span>]:</span><br><span class="line">                    detail[key] = int(detail[key])</span><br><span class="line"></span><br><span class="line">                details.append(detail)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回爬取结果</span></span><br><span class="line">    <span class="keyword">return</span> details</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUserInfo</span><span class="params">(uid)</span>:</span></span><br><span class="line">    print(<span class="string">'==getUserInfo=='</span>)</span><br><span class="line">    url = <span class="string">'https://www.jianshu.com/u/&#123;&#125;'</span>.format(uid)</span><br><span class="line">    r = getResponse(url)</span><br><span class="line">    dom = etree.HTML(r.text)</span><br><span class="line">    user_info = dict()</span><br><span class="line">    user_info[<span class="string">'uid'</span>] = uid</span><br><span class="line">    user_info[<span class="string">'following'</span>]= dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">    user_info[<span class="string">'follows'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">1</span>]</span><br><span class="line">    user_info[<span class="string">'article_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">2</span>]</span><br><span class="line">    user_info[<span class="string">'word_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/p/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">    user_info[<span class="string">'like_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/p/text()'</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFollowsInfo</span><span class="params">(user_info)</span>:</span></span><br><span class="line">    print(<span class="string">"==getFollowsInfo=="</span>)</span><br><span class="line">    follows = []</span><br><span class="line">    uid = user_info[<span class="string">'uid'</span>]</span><br><span class="line">    follow_num = int(user_info[<span class="string">'follows'</span>])</span><br><span class="line">    PER_NUM = <span class="number">9</span></span><br><span class="line">    max_page = int(follow_num / PER_NUM) <span class="keyword">if</span> (follow_num % PER_NUM) == <span class="number">0</span> <span class="keyword">else</span> int(follow_num / PER_NUM)+<span class="number">1</span></span><br><span class="line">    following_urls = [<span class="string">'https://www.jianshu.com/users/&#123;&#125;/followers?page=&#123;&#125;'</span>.format(uid, i) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                          range(<span class="number">1</span>, max_page+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> following_url <span class="keyword">in</span> following_urls:</span><br><span class="line">        r = getResponse(following_url)</span><br><span class="line">        dom = etree.HTML(r.text)</span><br><span class="line">        items = dom.xpath(<span class="string">'//ul/li//div[@class="info"]'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            user = &#123;&#125;</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                user[<span class="string">'uid'</span>] = item.xpath(<span class="string">'./a/@href'</span>)[<span class="number">0</span>].split(<span class="string">'/'</span>)[<span class="number">2</span>]</span><br><span class="line">                user[<span class="string">'following'</span>] = item.xpath(<span class="string">'./div/span[1]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'关注'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                user[<span class="string">'follows'</span>] = item.xpath(<span class="string">'./div/span[2]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'粉丝'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                user[<span class="string">'article_nums'</span>] = item.xpath(<span class="string">'./div/span[3]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'文章'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                s = item.xpath(<span class="string">'./div[2]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">                num = re.findall(<span class="string">r"\d+"</span>,s)</span><br><span class="line">                <span class="keyword">if</span> len(num) == <span class="number">2</span>:</span><br><span class="line">                    user[<span class="string">'word_nums'</span>] = num[<span class="number">0</span>]</span><br><span class="line">                    user[<span class="string">'like_nums'</span>] = num[<span class="number">1</span>]</span><br><span class="line">                follows.append(user)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> follows</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    uid = <span class="string">"67eb7ed414d3"</span></span><br><span class="line">    date = time.strftime(<span class="string">"%Y-%m-%d"</span>, time.localtime())</span><br><span class="line">    user_info = getUserInfo(uid)</span><br><span class="line">    details = getArticleInfo(user_info)</span><br><span class="line">    follows = getFollowsInfo(user_info)</span><br><span class="line">    data = &#123;<span class="string">'uid'</span>: uid, <span class="string">'date'</span>: date, <span class="string">'following'</span>: user_info[<span class="string">'following'</span>],</span><br><span class="line">            <span class="string">'follows'</span>: user_info[<span class="string">'follows'</span>], <span class="string">'article_nums'</span>: user_info[<span class="string">'article_nums'</span>],</span><br><span class="line">            <span class="string">'word_nums'</span>: user_info[<span class="string">'word_nums'</span>], <span class="string">'like_nums'</span>: user_info[<span class="string">'like_nums'</span>],</span><br><span class="line">            <span class="string">'article_details'</span>: details, <span class="string">'follows_details'</span>: follows&#125;</span><br><span class="line"></span><br><span class="line">    db  = client.jianshu</span><br><span class="line">    posts = db.author_info</span><br><span class="line">    result = posts.insert_one(data)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库用的是mongodb，让自行配置。</p><p>祝各位作者粉丝数暴增。</p><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2016年就开始在简书上写文章，之所以选择这个平台，很大程度上是因为它洁简的后台输入界面，支持MD，非常适合写一些技术类的文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="搞事情" scheme="https://weiweiblog.cn/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
      <category term="爬虫" scheme="https://weiweiblog.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>互联网校招面试必备——Redis</title>
    <link href="https://weiweiblog.cn/redis/"/>
    <id>https://weiweiblog.cn/redis/</id>
    <published>2018-09-22T00:26:19.000Z</published>
    <updated>2020-05-17T07:27:05.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis有哪些数据结构？"><a href="#Redis有哪些数据结构？" class="headerlink" title="Redis有哪些数据结构？"></a>Redis有哪些数据结构？</h3><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p><p>如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p><h3 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h3><p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，</p><h3 id="使用Redis有哪些好处？"><a href="#使用Redis有哪些好处？" class="headerlink" title="使用Redis有哪些好处？"></a>使用Redis有哪些好处？</h3><p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</p><p>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="Redis相比memcached有哪些优势？"><a href="#Redis相比memcached有哪些优势？" class="headerlink" title="Redis相比memcached有哪些优势？"></a>Redis相比memcached有哪些优势？</h3><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>(2) redis的速度比memcached快很多</p><p>(3) redis可以持久化其数据</p><p>(4) Redis支持数据的备份，即master-slave模式的数据备份。</p><p>(5)、使用底层模型不同</p><p>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。</p><p>Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><p>(6）value大小：redis最大可以达到1GB，而memcache只有1MB</p><h3 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h3><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p><p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h3 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h3><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><p>纯内存数据库，避免了磁盘I/O的瓶颈。</p><p>单进程单线程，减少了线程上下文切换的开销。</p><p>利用队列技术将并行访问变为串行访问，消除了传统数据库并发访问控制锁的开销。</p><p>Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p><p>使用多路I/O复用模型，非阻塞I/O。</p><h4 id="多路I-O复用模型："><a href="#多路I-O复用模型：" class="headerlink" title="多路I/O复用模型："></a>多路I/O复用模型：</h4><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h3 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h3><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><h3 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h3><ul><li><p>RDB持久化：redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行，也可以再redis.conf中配置，定期执行。RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。</p></li><li><p>AOF持久化：AOF持久化（Append-Only-File），与RDB持久化不同，AOF持久化是通过保存Redis服务器锁执行的写状态来记录数据库的。具体来说，RDB持久化相当于备份数据库状态，而AOF持久化是备份数据库接收到的命令，所有被写入AOF的命令都是以redis的协议格式来保存的。在AOF持久化的文件中，数据库会记录下所有变更数据库状态的命令，除了指定数据库的select命令，其他的命令都是来自client的，这些命令会以追加(append)的形式保存到文件中。</p><p>对比：</p></li><li><p>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢，也更完整。</p></li><li><p>RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/xlgen157387/article/details/79470556" target="_blank" rel="noopener">为什么说Redis是单线程的以及Redis为什么这么快！</a></li><li><a href="https://www.imooc.com/article/36399" target="_blank" rel="noopener">史上最全Redis面试题及答案</a></li></ul><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis有哪些数据结构？&quot;&gt;&lt;a href=&quot;#Redis有哪些数据结构？&quot; class=&quot;headerlink&quot; title=&quot;Redis有哪些数据结构？&quot;&gt;&lt;/a&gt;Redis有哪些数据结构？&lt;/h3&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="redis" scheme="https://weiweiblog.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>互联网校招面试必备——数据库</title>
    <link href="https://weiweiblog.cn/databases/"/>
    <id>https://weiweiblog.cn/databases/</id>
    <published>2018-09-21T01:00:51.000Z</published>
    <updated>2020-05-17T07:27:05.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDL（Data-Definition-Language）数据库定义语言"><a href="#DDL（Data-Definition-Language）数据库定义语言" class="headerlink" title="DDL（Data Definition Language）数据库定义语言"></a>DDL（Data Definition Language）数据库定义语言</h2><p>CREATE、ALTER、DROP、TRUNCATE、COMMENT、RENAME</p><h2 id="DML（Data-Manipulation-Language）数据操纵语言"><a href="#DML（Data-Manipulation-Language）数据操纵语言" class="headerlink" title="DML（Data Manipulation Language）数据操纵语言"></a>DML（Data Manipulation Language）数据操纵语言</h2><p>SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE</p><h2 id="左连接、右连接、内连接、全连接"><a href="#左连接、右连接、内连接、全连接" class="headerlink" title="左连接、右连接、内连接、全连接"></a>左连接、右连接、内连接、全连接</h2><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemvsngcbj30go0d4q4v.jpg" alt=""></p><h3 id="INNER-JOIN（内连接）"><a href="#INNER-JOIN（内连接）" class="headerlink" title="INNER JOIN（内连接）"></a>INNER JOIN（内连接）</h3><p>内连接是一种一一映射关系，就是两张表都有的才能显示出来</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemwddgj8j307604umxa.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">INNER JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure><h3 id="LEFT-JOIN-（左连接）"><a href="#LEFT-JOIN-（左连接）" class="headerlink" title="LEFT JOIN （左连接）"></a>LEFT JOIN （左连接）</h3><p>左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示，所谓的左边表其实就是指放在left join的左边的表</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvemxp9klbj307604umxa.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">LEFT JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure><h3 id="RIGHT-JOIN（右连接）"><a href="#RIGHT-JOIN（右连接）" class="headerlink" title="RIGHT JOIN（右连接）"></a>RIGHT JOIN（右连接）</h3><p>右连接正好是和左连接相反的，这里的右边也是相对right join来说的，在这个右边的表就是右表</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemyju8qmj307604uq32.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">RIGHT JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure><h3 id="OUTER-JOIN（外连接、全连接）"><a href="#OUTER-JOIN（外连接、全连接）" class="headerlink" title="OUTER JOIN（外连接、全连接）"></a>OUTER JOIN（外连接、全连接）</h3><p>查询出左表和右表所有数据，但是去除两表的重复数据</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvemzkh12zj307604umxa.jpg" alt=""></p><p>因为mysql不支持全连接，只能用以下代码实现效果，含义是左连接+右连接+去重=全连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">LEFT JOIN  table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"> UNION</span><br><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">RIGHT JOIN  table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。</p><p>用法：A CROSS JOIN B (不要ON)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u014204541/article/details/79739980" target="_blank" rel="noopener">数据库左连接、右连接、内连接、全连接笔记</a></p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><ul><li>第一范式（1NF）：符合1NF的关系中的每个属性都不可再分。是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</li><li>第二范式（2NF）：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>第三范式（3NF）：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</li></ul><p>详细内容参考：<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">知乎——解释一下关系数据库的第一第二第三范式？_刘慰</a></p><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是一种数据结构 。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul><li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvg610tf0tj316s0fqq7m.jpg" alt=""></p></li></ul><h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p><p>B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul><li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li>主键索引: 数据列不允许重复，不允许为NULL.一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li><li>非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li></ul><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li><li>空间方面：索引需要占物理空间。</li></ul><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><h3 id="四大特性-简称ACID"><a href="#四大特性-简称ACID" class="headerlink" title="四大特性(简称ACID)"></a>四大特性(简称ACID)</h3><p>数据库如果支持事务的操作，那么就具备以下四个特性：</p><ol><li>原子性(Atomicity)</li></ol><p>事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。</p><ol start="2"><li>一致性(Consistency)</li></ol><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p><ol start="3"><li>隔离性(Isolation)</li></ol><p>一个事务的执行不能被其他事务干扰。</p><ol start="4"><li>持续性/永久性(Durability)</li></ol><p>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="left"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">Read committed&#8211;Sql Server , Oracle</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">Repeatable read&#8211;MySQL</td><td align="center">×</td><td align="center"></td><td align="center">√</td></tr><tr><td align="left">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。</p><p>出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。</p><p>当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。</p><h4 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h4><p>singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何&#8230;&#8230;</p><p>出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p><p>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</p><p>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。</p><h4 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h4><p>当隔离级别设置为Repeatable read时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。</p><p>虽然Repeatable read避免了不可重复读，但还有可能出现幻读。</p><p>singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction &#8230; ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p><p>注：MySQL的默认隔离级别就是Repeatable read。</p><h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Read-Uncommitted（读取未提交内容）"><a href="#Read-Uncommitted（读取未提交内容）" class="headerlink" title="Read Uncommitted（读取未提交内容）"></a>Read Uncommitted（读取未提交内容）</h4><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h4 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h4><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h4 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h4><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><h4 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h4><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读操作不加S锁；</p><p>在Read Committed级别下，读操作需要加S锁，但是在语句执行完以后释放S锁；</p><p>在Repeatable Read级别下，读操作需要加S锁，但是在事务提交之前并不释放S锁，也就是必须等待事务执行完毕以后才释放S锁。</p><p>在Serialize级别下，会在Repeatable Read级别的基础上，添加一个范围锁。保证一个事务内的两次查询结果完全一样，而不会出现第一次查询结果是第二次查询结果的子集。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://xm-king.iteye.com/blog/770721" target="_blank" rel="noopener">MySQL事务隔离级别详解</a></li><li><a href="https://blog.csdn.net/baidu_37107022/article/details/77481670" target="_blank" rel="noopener">数据库隔离级别</a></li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性搞，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。</p><p>视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。</p><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的，这些视图有如下特征：</p><p>　　a.有UNIQUE等集合操作符的视图。</p><p>　　b.有GROUP BY子句的视图。</p><p>　　c.有诸如AVG\SUM\MAX等聚合函数的视图。</p><p>　　d.使用DISTINCT关键字的视图。</p><p>　　e.连接表的视图（其中有些例外）</p></li></ol><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程。一旦定义，触发器将被保存在数据库服务器中。任何用户对表的增、删、改操作均由服务器自动激活相应的触发器，在关系数据库管理系统核心层进行集中的完整性控制。触发器类似于约束，但是比约束更加灵活，可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</p><h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的全部或者一部分数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢,需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvh9340z9oj30kd0emdgz.jpg" alt=""></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><blockquote><p>获取最新资讯，请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DDL（Data-Definition-Language）数据库定义语言&quot;&gt;&lt;a href=&quot;#DDL（Data-Definition-Language）数据库定义语言&quot; class=&quot;headerlink&quot; title=&quot;DDL（Data Definition Language）数据库定义语言&quot;&gt;&lt;/a&gt;DDL（Data Definition Language）数据库定义语言&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据库" scheme="https://weiweiblog.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="校招" scheme="https://weiweiblog.cn/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>互联网校招面试必备——Java多线程</title>
    <link href="https://weiweiblog.cn/thread/"/>
    <id>https://weiweiblog.cn/thread/</id>
    <published>2018-09-18T09:06:52.000Z</published>
    <updated>2020-05-17T07:27:05.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。</p><blockquote><p>什么是进程，什么是线程？为什么需要多线程编程？</p></blockquote><blockquote><p>进程间的通信方式、线程间的通信方式</p></blockquote><blockquote><p>实现多线程的三种方法</p></blockquote><blockquote><p>三种创建多线程方法的对比</p></blockquote><blockquote><p>线程状态</p></blockquote><blockquote><p>线程控制</p></blockquote><blockquote><p>wait、notify、notifyAll的区别</p></blockquote><blockquote><p>sleep() 和 wait() 有什么区别?</p></blockquote><blockquote><p>锁类型</p></blockquote><blockquote><p>什么是乐观锁和悲观锁</p></blockquote><blockquote><p>乐观锁的实现方式（CAS）</p></blockquote><blockquote><p>CAS的缺点</p></blockquote><blockquote><p>实现一个死锁</p></blockquote><blockquote><p>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</p></blockquote><blockquote><p>volatile</p></blockquote><blockquote><p>volatile使用建议</p></blockquote><blockquote><p>volatile和synchronized区别</p></blockquote><blockquote><p>synchronized</p></blockquote><blockquote><p>synchronized的三种应用方式</p></blockquote><blockquote><p>Lock</p></blockquote><blockquote><p>Lock接口中获取锁的方法</p></blockquote><blockquote><p>Condition类</p></blockquote><blockquote><p>Condition与Object中的wait, notify, notifyAll区别</p></blockquote><blockquote><p>synchronized和lock的区别</p></blockquote><blockquote><p>锁的状态</p></blockquote><blockquote><p>偏向锁、轻量级锁、重量级锁、自旋锁、自适应自旋锁</p></blockquote><blockquote><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</p></blockquote><blockquote><p>AQS</p></blockquote><blockquote><p>线程池</p></blockquote><blockquote><p>使用线程池的好处</p></blockquote><blockquote><p>线程池都有哪几种工作队列 </p></blockquote><h2 id="什么是进程，什么是线程？为什么需要多线程编程？"><a href="#什么是进程，什么是线程？为什么需要多线程编程？" class="headerlink" title="什么是进程，什么是线程？为什么需要多线程编程？"></a>什么是进程，什么是线程？为什么需要多线程编程？</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它占用了更多的 CPU 资源。</p><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul><li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li><li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ul><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><ul><li>锁机制：包括互斥锁、条件变量、读写锁 <ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li><li>信号机制(Signal)：类似进程间的信号处理</li></ul><blockquote><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 </p></blockquote><h2 id="实现多线程的三种方法"><a href="#实现多线程的三种方法" class="headerlink" title="实现多线程的三种方法"></a>实现多线程的三种方法</h2><ul><li>继承Thread类，重写父类run()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class thread1 extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;我是线程&quot;+this.getId());</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                thread1 th1 &#x3D; new thread1();</span><br><span class="line">                thread1 th2 &#x3D; new thread1();</span><br><span class="line">                th1.start();</span><br><span class="line">                th2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现runnable接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class thread2 implements Runnable &#123;</span><br><span class="line">        public String ThreadName;</span><br><span class="line">        public thread2(String tName)&#123;</span><br><span class="line">                ThreadName &#x3D; tName;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(ThreadName);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建一个Runnable接口实现类的对象</span><br><span class="line">                thread2 th1 &#x3D; new thread2(&quot;线程A:&quot;);</span><br><span class="line">                thread2 th2 &#x3D; new thread2(&quot;线程B:&quot;);</span><br><span class="line">                &#x2F;&#x2F; 将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程</span><br><span class="line">                Thread myth1 &#x3D; new Thread(th1);</span><br><span class="line">                Thread myth2 &#x3D; new Thread(th2);</span><br><span class="line">                &#x2F;&#x2F; 调用start()方法，启动线程并执行run()方法</span><br><span class="line">                myth1.start();</span><br><span class="line">                myth2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Callable和Future创建线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for(;i&lt;100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        CallableThreadTest ctt &#x3D; new CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);</span><br><span class="line">            if(i&#x3D;&#x3D;20)&#123;</span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());</span><br><span class="line">        &#125; catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种创建多线程方法的对比"><a href="#三种创建多线程方法的对比" class="headerlink" title="三种创建多线程方法的对比"></a>三种创建多线程方法的对比</h3><p>1、采用实现Runnable、Callable接口的方式创建多线程时，线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。缺点是编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p><p>2、使用继承Thread类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。缺点是线程类已经继承了Thread类，所以不能再继承其他父类。</p><p>3、Runnable和Callable的区别</p><p>(1) Callable规定重写call()，Runnable重写run()。</p><p>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</p><p>(3) call方法可以抛出异常，run方法不可以。</p><p>(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvao00n1s4j30zk0i8jvt.jpg" alt=""></p><ul><li>新建状态：新建线程对象，并没有调用start()方法之前</li><li>就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。</li><li>运行状态：线程被设置为当前线程，获得CPU后，开始执行run()方法，就是线程进入运行状态。</li><li>阻塞状态：处于运行的状态的线程，除非执行时间非常非常非常短，否则它会因为系统对资源的调度而被中断进入阻塞状态。比如说调用sleep()方法后线程就进入阻塞状态。</li><li>死亡状态：处于运行状态的线程，当它主动或者被动结束，线程就处于死亡状态。结束的形式，通常有以下几种：1. 线程执行完成，线程正常结束；2. 线程执行过程中出现异常或者错误，被动结束；3. 线程主动调用stop方法结束线程。</li></ul><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><ul><li>join()：等待。让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。</li><li>sleep()：睡眠。让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。</li><li>yield()：线程让步。将线程从运行状态转换为就绪状态。当某个线程调用 yiled() 方法从运行状态转换到就绪状态后，CPU 会从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。</li><li>setPriority()：改变线程的优先级。每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值：MAX_PRIORITY：10；MIN_PRIORITY：1；NORM_PRIORITY：5。</li></ul><blockquote><p>PS: 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 </p></blockquote><ul><li>setDaemon(true)：设置为后台线程。后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。当所有的前台线程都进入死亡状态时，后台线程会自动死亡。</li></ul><blockquote><p>sleep() 和 yield() 两者的区别：</p></blockquote><blockquote><p>① sleep()方法会给其他线程运行的机会，不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会。yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</p></blockquote><blockquote><p>② 当线程执行了 sleep(long millis) 方法，将转到阻塞状态，参数millis指定睡眠时间。当线程执行了yield()方法，将转到就绪状态。</p></blockquote><blockquote><p>③ sleep() 方法声明抛出InterruptedException异常，而 yield() 方法没有声明抛出任何异常。 </p></blockquote><h2 id="wait、notify、notifyAll的区别"><a href="#wait、notify、notifyAll的区别" class="headerlink" title="wait、notify、notifyAll的区别"></a>wait、notify、notifyAll的区别</h2><p>wait、notify、notifyAll是java同步机制中重要的组成部分，结合synchronized关键字使用，可以建立很多优秀的同步模型。这3个方法并不是Thread类或者是Runnable接口的方法，而是Object类的3个本地方法。</p><p>调用一个Object的wait与notify/notifyAll的时候，必须保证调用代码对该Object是同步的，也就是说必须在作用等同于synchronized(obj){&#8230;&#8230;}的内部才能够去调用obj的wait与notify/notifyAll三个方法，否则就会报错：<code>java.lang.IllegalMonitorStateException:current thread not owner</code></p><blockquote><p>先说两个概念：锁池和等待池</p></blockquote><blockquote><p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p></blockquote><blockquote><p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</p></blockquote><blockquote><p>@知乎&#8211;<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">文龙</a> </p></blockquote><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><p>wait：线程自动释放其占有的对象锁，并等待notify</p></li><li><p>notify：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁</p></li><li><p>notifyAll：唤醒所有正在wait当前对象锁的线程</p><p>notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。</p></li></ul><h4 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h4><p>sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用 sleep 不会释放对象锁。wait() 是 Object 类的方法，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><ul><li>可重入锁：广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。即在执行对象中所有同步方法不用再次获得锁。ReentrantLock和synchronized都是可重入锁。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</li><li>可中断锁：在等待获取锁过程中可中断。synchronized就不是可中断锁，而Lock是可中断锁。</li><li>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利。非公平锁即无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。synchronized是非公平锁，它无法保证等待的线程获取锁的顺序。对于ReentrantLock和ReentrantReadWriteLock，默认情况下是非公平锁，但是可以设置为公平锁。</li><li>读写锁：对资源读取和写入的时候拆分为2部分处理，一个读锁和一个写锁。读的时候可以多线程一起读，写的时候必须同步地写。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li></ul><h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><p>（1）乐观锁：很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会去判断在此期间有没有人去更新这个数据（可以使用版本号等机制）。如果因为冲突失败就重试。乐观锁适用于写比较少的情况下，即冲突比较少发生，这样可以省去了锁的开销，加大了系统的整个吞吐量。像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>（2）悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，因此每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁，效率比较低。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><h3 id="乐观锁的实现方式（CAS）"><a href="#乐观锁的实现方式（CAS）" class="headerlink" title="乐观锁的实现方式（CAS）"></a>乐观锁的实现方式（CAS）</h3><p>乐观锁的实现主要就两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><p>CAS：CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p><blockquote><p>乐观锁是一种思想，CAS是这种思想的一种实现方式。 </p></blockquote><h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><ol><li><p>ABA问题</p><blockquote><p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。ava并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p></blockquote></li><li><p>循环时间长开销很大</p><blockquote><p>自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p></blockquote></li><li><p>只能保证一个共享变量的原子操作。</p><blockquote><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></blockquote></li></ol><h2 id="实现一个死锁"><a href="#实现一个死锁" class="headerlink" title="实现一个死锁"></a>实现一个死锁</h2><p>什么是死锁：两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><p>产生死锁的四个必要条件：</p><p>互斥条件：一个资源每次只能被一个进程使用。</p><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>考虑如下情形：</p><p>（1）线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。</p><p>（2）线程A试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2释放。</p><p>（3）如果此时线程B也在试图获取lock1，同理线程也会阻塞。</p><p>（4）两者都在等待对方所持有但是双方都不释放的锁，这时便会一直阻塞形成死锁。</p><p>死锁的解决方法:</p><p>a 撤消陷于死锁的全部进程；</p><p>b 逐个撤消陷于死锁的进程，直到死锁不存在；</p><p>c 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</p><p>d 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态</p><h3 id="如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><a href="#如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？" class="headerlink" title="如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？"></a>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>　　对于过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p><ul><li><p>防止重排序</p><blockquote><p>问题：操作系统可以对指令进行重排序，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果</p></blockquote><blockquote><p>解决原理：volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p></blockquote><blockquote><p>1、在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</p></blockquote><blockquote><p>2、在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 </p></blockquote></li><li><p>实现可见性</p><blockquote><p>问题：可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到</p></blockquote><blockquote><p>解决原理：（1）修改volatile变量时会强制将修改后的值刷新的主内存中。</p></blockquote><blockquote><p>（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 </p></blockquote></li><li><p>注：volatile并不保证变量更新的原子性</p> </p></li></ul><h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p><p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p><p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</p><p>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p><h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><p>1、volatile不会进行加锁操作：</p><p>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p><p>2、volatile变量作用类似于同步变量读写操作：</p><p>从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p><p>3、volatile不如synchronized安全：</p><p>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</p><p>4、volatile无法同时保证内存可见性和原子性：</p><p>加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。</p><p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p><p>1、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</p><p>2、该变量没有包含在具有其他变量的不变式中。</p><p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Synchronized主要有以下三个作用：保证互斥性、保证可见性、保证顺序性。</p><h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><ul><li><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。实现原理：指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。实现原理：使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static AccountingSync instance&#x3D;new AccountingSync();</span><br><span class="line">synchronized(instance)&#123;</span><br><span class="line">    for(int j&#x3D;0;j&lt;1000000;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock是一个接口，它的的实现类提供了比synchronized更广泛意义上锁操作，它允许用户更灵活的代码结构，更多的不同特效。Lock的实现类主要有ReentrantLock和ReentrantReadWriteLock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock&#x3D;new ReentrantLock()；</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    &#x2F;&#x2F; 如果有return要写在try块中</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock接口中获取锁的方法"><a href="#Lock接口中获取锁的方法" class="headerlink" title="Lock接口中获取锁的方法"></a>Lock接口中获取锁的方法</h3><ul><li>void lock()：lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。在发生异常时，它不会自动释放锁，要记得在finally块中释放锁，以保证锁一定被被释放，防止死锁的发生。</li><li>void lockInterruptibly()：可以响应中断，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。</li><li>boolean tryLock()：有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true；如果获取失败（即锁已被其他线程获取），则返回false。</li><li>boolean tryLock(long time, TimeUnit unit)：和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。</li></ul><h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>Condition是Java提供来实现等待/通知的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p><p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。</p><p>其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p><p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p><h4 id="Condition与Object中的wait-notify-notifyAll区别"><a href="#Condition与Object中的wait-notify-notifyAll区别" class="headerlink" title="Condition与Object中的wait, notify, notifyAll区别"></a>Condition与Object中的wait, notify, notifyAll区别</h4><p>1.Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。</p><p>不同的是，Object中的这些方法是和同步锁捆绑使用的；而Condition是需要与互斥锁/共享锁捆绑使用的。</p><p>2.Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</p><p>例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒&#8221;读线程&#8221;；当从缓冲区读出数据之后，唤醒&#8221;写线程&#8221;；并且当缓冲区满的时候，&#8221;写线程&#8221;需要等待；当缓冲区为空时，&#8221;读线程&#8221;需要等待。</p><p>如果采用Object类中的wait(),notify(),notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒&#8221;读线程&#8221;时，不可能通过notify()或notifyAll()明确的指定唤醒&#8221;读线程&#8221;，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。 但是，通过Condition，就能明确的指定唤醒读线程。</p><h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><table><thead><tr><th align="center"></th><th align="center">synchronized</th><th align="center">Lock</th></tr></thead><tbody><tr><td align="center">存在层次</td><td align="center">Java的关键字</td><td align="center">是一个接口</td></tr><tr><td align="center">锁的释放</td><td align="center">1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td><td align="center">在finally中必须释放锁，不然容易造成线程死锁</td></tr><tr><td align="center">锁的获取</td><td align="center">假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td><td align="center">Lock可以让等待锁的线程响应中断</td></tr><tr><td align="center">锁状态</td><td align="center">无法判断</td><td align="center">可以判断有没有成功获取锁</td></tr><tr><td align="center">锁类型</td><td align="center">可重入 不可中断 非公平</td><td align="center">可重入 可中断 公平/非公平</td></tr></tbody></table><p>性能方面，JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。多线程环境下，synchronized的吞吐量下降的非常严重，而ReentrankLock则能基本保持在同一个比较稳定的水平上。</p><p>到了JDK1.6，synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><h2 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h2><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。轻量级锁是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p><p>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li><li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li></ul><p>自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p><h3 id="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"><a href="#偏向锁、轻量级锁、重量级锁适用于不同的并发场景" class="headerlink" title="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"></a>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</h3><p>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</p><p>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</p><p>重量级锁：有实际竞争，且锁竞争时间长。</p><p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p><p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p><blockquote><p>锁膨胀的过程：只有一个线程进入临界区（偏向锁），多个线程交替进入临界区（轻量级锁），多线程同时进入临界区（重量级锁）。 </p></blockquote><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p><p>AbstractQueuedSynchronizer是一个抽象类，主要是维护了一个int类型的state属性和一个非阻塞、先进先出的线程等待队列；其中state是用volatile修饰的，保证线程之间的可见性，队列的入队和出对操作都是无锁操作，基于自旋锁和CAS实现；另外AQS分为两种模式：独占模式和共享模式，像ReentrantLock是基于独占模式模式实现的，CountDownLatch、CyclicBarrier等是基于共享模式。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>线程池的产生和数据库的连接池类似，系统启动一个线程的代价是比较高昂的，如果在程序启动的时候就初始化一定数量的线程，放入线程池中，在需要是使用时从池子中去，用完再放回池子里，这样能大大的提高程序性能，再者，线程池的一些初始化配置，也可以有效的控制系统并发的数量，防止因为消耗过多的内存，而把服务器累趴下。</p><p>通过Executors工具类可以创建各种类型的线程池，如下为常见的四种：</p><ul><li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li><li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li><li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li></ul><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li><li>对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li></ul><h3 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h3><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/java-interview-bible/multi-thread.html" target="_blank" rel="noopener">Java 多线程</a></p><p><a href="http://www.importnew.com/23535.html" target="_blank" rel="noopener">Java并发：volatile内存可见性和指令重排</a></p><p><a href="https://juejin.im/post/5a43ad786fb9a0450909cb5f" target="_blank" rel="noopener">并发编程的锁机制：synchronized和lock</a></p><p><a href="https://juejin.im/post/5a5c09d051882573282164ae" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁</a></p><blockquote><p>获取最新资讯，请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="https://weiweiblog.cn/tags/java/"/>
    
      <category term="同步" scheme="https://weiweiblog.cn/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="多线程" scheme="https://weiweiblog.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="https://weiweiblog.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>一文搞定BAT面试——Java 集合类</title>
    <link href="https://weiweiblog.cn/collections/"/>
    <id>https://weiweiblog.cn/collections/</id>
    <published>2018-09-08T08:11:27.000Z</published>
    <updated>2020-05-17T07:27:05.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Iterator接口"><a href="#1-Iterator接口" class="headerlink" title="1. Iterator接口"></a>1. Iterator接口</h3><p>Iterator接口，这是一个用于遍历集合中元素的接口，主要包含hashNext(),next(),remove()三种方法。它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious()。也就是说如果是先Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常无序集合实现的都是这个接口，比如HashSet，HashMap；而那些元素有序的集合，实现的一般都是LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个元素，比如ArrayList。</p><h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><p>List是元素有序并且可以重复的集合。</p><p>List的主要实现：ArrayList, LinkedList, Vector。</p><h4 id="2-ArrayList、LinkedList、Vector-的区别"><a href="#2-ArrayList、LinkedList、Vector-的区别" class="headerlink" title="2. ArrayList、LinkedList、Vector 的区别"></a>2. ArrayList、LinkedList、Vector 的区别</h4><table><thead><tr><th align="center"></th><th align="center">ArrayList</th><th align="center">LinkedList</th><th align="center">Vector</th></tr></thead><tbody><tr><td align="center">底层实现</td><td align="center">数组</td><td align="center">双向循环链表</td><td align="center">数组</td></tr><tr><td align="center">同步性及效率</td><td align="center">不同步，非线程安全，效率高</td><td align="center">不同步，非线程安全，效率高</td><td align="center">同步，线程安全，效率低</td></tr><tr><td align="center">特点</td><td align="center">查询快,增删慢</td><td align="center">查询慢,增删快</td><td align="center">查询快,增删慢</td></tr><tr><td align="center">默认容量</td><td align="center">10</td><td align="center">/</td><td align="center">10</td></tr><tr><td align="center">扩容机制</td><td align="center">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5 倍</td><td align="center">/</td><td align="center">2 倍</td></tr></tbody></table><blockquote><p><strong>总结</strong>：</p></blockquote><blockquote><p>&#8211; ArrayList 和 Vector 基于数组实现，对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</p></blockquote><blockquote><p>&#8211; LinkedList 不会出现扩容的问题，所以比较适合随机位置增、删。但是其基于链表实现，所以在定位时需要线性扫描，效率比较低。</p></blockquote><blockquote><p>&#8211; 当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；</p></blockquote><blockquote><p>&#8211; 当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。 </p></blockquote><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h3><p>Set集合中的对象不按特定的方式排序(存入和取出的顺序不一定一致)，并且没有重复对象。</p><p>Set的主要实现类：HashSet, TreeSet。</p><table><thead><tr><th align="center"></th><th align="center">HashSet</th><th align="center">TreeSet</th><th align="center">LinkedHashSet</th></tr></thead><tbody><tr><td align="center">底层实现</td><td align="center">HashMap</td><td align="center">红黑树</td><td align="center">LinkedHashMap</td></tr><tr><td align="center">重复性</td><td align="center">不允许重复</td><td align="center">不允许重复</td><td align="center">不允许重复</td></tr><tr><td align="center">有/无序</td><td align="center">无序</td><td align="center">有序，支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</td><td align="center">有序，以元素插入的顺序来维护集合的链接表</td></tr><tr><td align="center">时间复杂度</td><td align="center">add()，remove()，contains()方法的时间复杂度是O(1)</td><td align="center">add()，remove()，contains()方法的时间复杂度是O(logn)</td><td align="center">LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet，时间复杂度是 O(1)。</td></tr><tr><td align="center">同步性</td><td align="center">不同步，线程不安全</td><td align="center">不同步，线程不安全</td><td align="center">不同步，线程不安全</td></tr><tr><td align="center">null值</td><td align="center">允许null值</td><td align="center">不支持null值，会抛出 java.lang.NullPointerException 异常。因为TreeSet应用 compareTo() 方法于各个元素来比较他们，当比较null值时会抛出 NullPointerException异常。</td><td align="center">允许null值</td></tr><tr><td align="center">比较</td><td align="center">equals()</td><td align="center">compareTo()</td><td align="center">equals()</td></tr></tbody></table><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p><p>hashCode（）与equals（）的相关规定：</p><ul><li><p>如果两个对象相等，则hashcode一定也是相同的</p></li><li><p>两个对象相等,对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p></li></ul><blockquote><p>总结：</p></blockquote><blockquote><p>HashSet是一个通用功能的Set，而LinkedHashSet 提供元素插入顺序保证，TreeSet是一个SortedSet实现，由Comparator 或者 Comparable指定的元素顺序存储元素。 </p></blockquote><h3 id="4-Map"><a href="#4-Map" class="headerlink" title="4. Map"></a>4. Map</h3><p>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。 Map没有继承于Collection接口从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><table><thead><tr><th align="center"></th><th align="center">HashMap</th><th align="center">HashTable</th></tr></thead><tbody><tr><td align="center">底层实现</td><td align="center">数组+链表</td><td align="center">数组+链表</td></tr><tr><td align="center">同步性</td><td align="center">线程不同步</td><td align="center">同步</td></tr><tr><td align="center">null值</td><td align="center">允许 key 和 Vale 是 null，但是只允许一个 key 为 null,且这个元素存放在哈希表 0 角标位置</td><td align="center">不允许key、value 是 null</td></tr><tr><td align="center">hash</td><td align="center">使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值</td><td align="center">直接使用 key 的 hashCode() 返回值作为 hash 值</td></tr><tr><td align="center">容量</td><td align="center">容量为 2^4 且容量一定是 2^n</td><td align="center">默认容量是11,不一定是 2^n</td></tr><tr><td align="center">扩容</td><td align="center">两倍，且哈希桶的下标使用 &amp;运算代替了取模</td><td align="center">2倍+1，取哈希桶下标是直接用模运算</td></tr></tbody></table><h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><p><strong>1. HashMap 的工作原理？</strong></p><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高效率。</p><p><strong>2.get和put的原理吗？equals()和hashCode()的都有什么作用？</strong></p><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><p><strong>3. HashMap 的长度为什么是2的幂次方？</strong></p><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><h4 id="HashMap-和-LinkedHashMap-的区别"><a href="#HashMap-和-LinkedHashMap-的区别" class="headerlink" title="HashMap 和 LinkedHashMap 的区别"></a>HashMap 和 LinkedHashMap 的区别</h4><ul><li>LinkedHashMap 拥有与 HashMap 相同的底层哈希表结构，即数组 + 单链表 + 红黑树，也拥有相同的扩容机制。</li><li>LinkedHashMap 相比 HashMap 的拉链式存储结构，内部额外通过 Entry 维护了一个双向链表。</li><li>HashMap 元素的遍历顺序不一定与元素的插入顺序相同，而 LinkedHashMap 则通过遍历双向链表来获取元素，所以遍历顺序在一定条件下等于插入顺序。</li><li>LinkedHashMap 可以通过构造参数 accessOrder 来指定双向链表是否在元素被访问后改变其在双向链表中的位置。</li></ul><h4 id="HashMap-amp-TreeMap-的区别"><a href="#HashMap-amp-TreeMap-的区别" class="headerlink" title="HashMap &amp; TreeMap 的区别"></a>HashMap &amp; TreeMap 的区别</h4><p>HashMap实现了Map接口，不保障元素顺序。</p><p>TreeMap实现了SortedMap接口，是一个有序的Map。内部采用红黑树实现，红黑树是一种维护有序数据的高效数据结构</p><h4 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><p>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><p>实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p>JDK1.7的ConcurrentHashMap：</p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.im/post/5b7e955be51d4538de11550c" target="_blank" rel="noopener">这几道Java集合框架面试题在面试中几乎必问</a></li><li><a href="https://juejin.im/post/5ad6313df265da2386706662" target="_blank" rel="noopener">搞懂 HashSet &amp; LinkedHashSet 源码以及集合常见面试题目</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Iterator接口&quot;&gt;&lt;a href=&quot;#1-Iterator接口&quot; class=&quot;headerlink&quot; title=&quot;1. Iterator接口&quot;&gt;&lt;/a&gt;1. Iterator接口&lt;/h3&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>[算法总结] 13 道题搞定 BAT 面试——字符串</title>
    <link href="https://weiweiblog.cn/13string/"/>
    <id>https://weiweiblog.cn/13string/</id>
    <published>2018-09-05T00:49:14.000Z</published>
    <updated>2020-05-17T07:27:05.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h3><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p><p>具体算法细节请参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li><li><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾彻底理解KMP</a></li><li><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法?</a></li><li><a href="https://blog.sengxian.com/algorithms/kmp" target="_blank" rel="noopener">KMP 算法详细解析</a></li><li><a href="http://blog.jobbole.com/76611/" target="_blank" rel="noopener">图解 KMP 算法</a></li><li><a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925" target="_blank" rel="noopener">汪都能听懂的KMP字符串匹配算法【双语字幕】</a></li><li><a href="https://www.bilibili.com/video/av11866460?from=search&seid=12730654434238709250" target="_blank" rel="noopener">KMP字符串匹配算法1</a></li></ul><h3 id="1-1-BM-算法"><a href="#1-1-BM-算法" class="headerlink" title="1.1 BM 算法"></a>1.1 BM 算法</h3><p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</p><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p><h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/replacespace/" target="_blank" rel="noopener">替换空格</a></p></blockquote><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &amp;gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                res.append(<span class="string">"02%"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h3><blockquote><p>Leetcode: <a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">最长公共前缀</a></p></blockquote><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &#8220;&#8221;。 </p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyg2oa3fkj31ec0eoabx.jpg" alt=""></p><p>首先对字符串数组进行排序，然后拿数组中的第一个和最后一个字符串进行比较，从第 0 位开始，如果相同，把它加入 res 中，不同则退出。最后返回 res</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">char</span> [] first = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">char</span> [] last = strs[strs.length - <span class="number">1</span>].toCharArray();</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = first.length &amp;lt; last.length ? first.length : last.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first[i] == last[i])&#123;</span><br><span class="line">                res.append(first[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最长回文串"><a href="#4-最长回文串" class="headerlink" title="4. 最长回文串"></a>4. 最长回文串</h3><blockquote><p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">最长回文串</a></p></blockquote><blockquote><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 &#8220;Aa&#8221; 不能当做一个回文字符串。 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuygx8mx9lj31ek0e0tae.jpg" alt=""></p><p>统计字母出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashSet&amp;lt;Character&amp;gt; hs = <span class="keyword">new</span> HashSet&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&amp;lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.contains(s.charAt(i)))&#123;</span><br><span class="line">                hs.remove(s.charAt(i));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hs.add(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hs.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-验证回文串"><a href="#4-1-验证回文串" class="headerlink" title="4.1 验证回文串"></a>4.1 验证回文串</h3><blockquote><p>Leetcode: <a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">验证回文串</a></p></blockquote><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p></blockquote><blockquote><p>说明：本题中，我们将空字符串定义为有效的回文串。 </p></blockquote><p>两个指针比较头尾。要注意只考虑字母和数字字符，可以忽略字母的大小写。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyht2qfgej31e40diwfz.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &amp;lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(l)))&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(r)))&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-最长回文子串"><a href="#4-2-最长回文子串" class="headerlink" title="4.2 最长回文子串"></a>4.2 最长回文子串</h3><blockquote><p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">最长回文子串</a></p></blockquote><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuyi05yg94j31eg0eqgnb.jpg" alt=""></p><p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index, len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; s.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            PalindromeHelper(s, i, i);</span><br><span class="line">            PalindromeHelper(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(index, index+len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PalindromeHelper</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &amp;gt;= <span class="number">0</span> &amp;&amp; r &amp;lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &amp;lt; r - l - <span class="number">1</span>)&#123;</span><br><span class="line">            index = l + <span class="number">1</span>;</span><br><span class="line">            len = r - l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长回文子序列"><a href="#4-3-最长回文子序列" class="headerlink" title="4.3 最长回文子序列"></a>4.3 最长回文子序列</h3><blockquote><p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">最长回文子序列</a></p></blockquote><blockquote><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p></blockquote><blockquote><p><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，&#8221;bbbb&#8221;可以使字符串&#8221;bbbab&#8221;的子序列但不是子串。</strong> </p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyo76q586j31eg0r4tb8.jpg" alt=""></p><p>动态规划：</p><p>dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j)</p><p>otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i&amp;gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &amp;lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-字符串的排列"><a href="#5-字符串的排列" class="headerlink" title="5. 字符串的排列"></a>5. 字符串的排列</h3><blockquote><p>Leetcode: <a href="https://leetcode-cn.com/problems/permutation-in-string/description/" target="_blank" rel="noopener">字符串的排列</a></p></blockquote><blockquote><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p></blockquote><blockquote><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuyfz1pt9tj31eq0gwjtg.jpg" alt=""></p><p>我们不用真的去算出s1的全排列，只要统计字符出现的次数即可。可以使用一个哈希表配上双指针来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> l2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">if</span>(l1 &amp;gt; l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&amp;lt;l1; i++)&#123;</span><br><span class="line">            count[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(allZero(count))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l1; i&amp;lt;l2; i++)&#123;</span><br><span class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">            count[s2.charAt(i-l1) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(allZero(count))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allZero</span><span class="params">(<span class="keyword">int</span> [] count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = count.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-打印字符串的全排列"><a href="#6-打印字符串的全排列" class="headerlink" title="6. 打印字符串的全排列"></a>6. 打印字符串的全排列</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/permutation/" target="_blank" rel="noopener">字符串的排列</a></p></blockquote><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 </p></blockquote><p>把问题拆解成简单的步骤：</p><p>第一步求所有可能出现在第一个位置的字符（即把第一个字符和后面的所有字符交换[相同字符不交换]）；</p><p>第二步固定第一个字符，求后面所有字符的排列。这时候又可以把后面的所有字符拆成两部分（第一个字符以及剩下的所有字符），依此类推。这样，我们就可以用递归的方法来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;String&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;String&amp;gt; Permutation(String str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PermutationHelper(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(str));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &amp;lt; str.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i &amp;&amp; str[i] == str[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">                PermutationHelper(str, i+<span class="number">1</span>);</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-第一个只出现一次的字符"><a href="#7-第一个只出现一次的字符" class="headerlink" title="7. 第一个只出现一次的字符"></a>7. 第一个只出现一次的字符</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/firstnotrepeatingchar/" target="_blank" rel="noopener">第一个只出现一次的字符</a></p></blockquote><blockquote><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1. </p></blockquote><p>先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数。也可以用数组代替hash表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(str.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> value = map.get(str.charAt(i));</span><br><span class="line">                map.put(str.charAt(i), value+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(str.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-翻转单词顺序列"><a href="#8-翻转单词顺序列" class="headerlink" title="8. 翻转单词顺序列"></a>8. 翻转单词顺序列</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/reversesentence/" target="_blank" rel="noopener">翻转单词顺序列</a></p></blockquote><blockquote><p>LeetCode: <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/description/" target="_blank" rel="noopener">翻转字符串里的单词</a> </p></blockquote><p>借助trim()和 split()就很容易搞定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.trim().length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s.trim();</span><br><span class="line">        String [] temp = s.trim().split(<span class="string">" +"</span>);</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res += temp[i] + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + temp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-旋转字符串"><a href="#9-旋转字符串" class="headerlink" title="9. 旋转字符串"></a>9. 旋转字符串</h3><blockquote><p>Leetcode: <a href="https://leetcode-cn.com/problems/rotate-string/description/" target="_blank" rel="noopener">旋转字符串</a></p></blockquote><blockquote><p>给定两个字符串, A 和 B。</p></blockquote><blockquote><p>A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = &#8216;abcde&#8217;，在移动一次之后结果就是&#8217;bcdea&#8217; 。如果在若干次旋转操作之后，A 能变成B，那么返回True。 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuyp75lk0yj31e60b8dhb.jpg" alt=""></p><p>一行代码搞定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.length() == B.length() &amp;&amp; (A+A).contains(B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-左旋转字符串"><a href="#9-1-左旋转字符串" class="headerlink" title="9.1 左旋转字符串"></a>9.1 左旋转字符串</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/leftrotatestring/" target="_blank" rel="noopener">左旋转字符串</a></p></blockquote><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ </p></blockquote><p>在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。注意字符串长度为 0 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        n = n % len;</span><br><span class="line">        String s1 = str.substring(n, len);</span><br><span class="line">        String s2 = str.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> s1+s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-反转字符串"><a href="#9-2-反转字符串" class="headerlink" title="9.2 反转字符串"></a>9.2 反转字符串</h3><blockquote><p>LeetCode: <a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">反转字符串</a></p></blockquote><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuypdj7b5vj31e40dk75w.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> [] strs = s.toCharArray(); </span><br><span class="line">        <span class="keyword">while</span>(l &amp;lt; r)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = strs[l];</span><br><span class="line">            strs[l] = strs[r];</span><br><span class="line">            strs[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-把字符串转换成整数"><a href="#10-把字符串转换成整数" class="headerlink" title="10. 把字符串转换成整数"></a>10. 把字符串转换成整数</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/strtoint/" target="_blank" rel="noopener">把字符串转换成整数</a></p></blockquote><blockquote><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'+'</span>)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> start = flag &amp;gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start) &amp;gt; <span class="string">'9'</span> || str.charAt(start) &amp;lt; <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + (str.charAt(start) - <span class="string">'0'</span>);</span><br><span class="line">            start ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">2</span> ? -(<span class="keyword">int</span>)res : (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-正则表达式匹配"><a href="#11-正则表达式匹配" class="headerlink" title="11. 正则表达式匹配"></a>11. 正则表达式匹配</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/match/" target="_blank" rel="noopener">正则表达式匹配</a></p></blockquote><blockquote><p>请实现一个函数用来匹配包括’.’和’&#42;’的正则表达式。模式中的字符’.’表示任意一个字符，而’&#42;’表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab&#42;ac&#42;a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuyqunzeuxj31e40s6jvg.jpg" alt=""></p><p>动态规划：</p><p>这里我们采用dp[i+1][j+1]代表s[0..i]匹配p[0..j]的结果，结果自然是采用布尔值True/False来表示。</p><p>首先，对边界进行赋值，显然dp[0][0] = true，两个空字符串的匹配结果自然为True;</p><p>接着，我们对dp[0][j+1]进行赋值，因为 i=0 是空串，如果一个空串和一个匹配串想要匹配成功，那么只有可能是p.charAt(j) == &#8216;*&#8217; &amp;&amp; dp[0][j-1]</p><p>之后，就可以愉快地使用动态规划递推方程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &amp;lt; p.length(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &amp;lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-表示数值的字符串"><a href="#12-表示数值的字符串" class="headerlink" title="12. 表示数值的字符串"></a>12. 表示数值的字符串</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/isnumeric/" target="_blank" rel="noopener">表示数值的字符串</a></p></blockquote><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。 </p></blockquote><p>设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &amp;gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &amp;lt; <span class="string">'0'</span> || str[i] &amp;gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-字符流中第一个不重复的字符"><a href="#13-字符流中第一个不重复的字符" class="headerlink" title="13. 字符流中第一个不重复的字符"></a>13. 字符流中第一个不重复的字符</h3><blockquote><p>剑指offer: <a href="https://www.weiweiblog.cn/firstappearingonce/" target="_blank" rel="noopener">字符流中第一个不重复的字符</a></p></blockquote><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 </p></blockquote><p>用一个哈希表来存储每个字符及其出现的次数，另外用一个字符串 s 来保存字符流中字符的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;Character, Integer&amp;gt;();</span><br><span class="line">    StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s.append(ch);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-KMP-算法&quot;&gt;&lt;a href=&quot;#1-KMP-算法&quot; class=&quot;headerlink&quot; title=&quot;1. KMP 算法&quot;&gt;&lt;/a&gt;1. KMP 算法&lt;/h3&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="KMP" scheme="https://weiweiblog.cn/tags/KMP/"/>
    
      <category term="String" scheme="https://weiweiblog.cn/tags/String/"/>
    
      <category term="动态规划" scheme="https://weiweiblog.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[算法总结] 6 道题搞定 BAT 面试——堆栈和队列</title>
    <link href="https://weiweiblog.cn/stack_and_queue/"/>
    <id>https://weiweiblog.cn/stack_and_queue/</id>
    <published>2018-09-03T18:48:06.000Z</published>
    <updated>2020-05-17T07:27:05.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于我的个人博客：<a href="https://www.weiweiblog.cn/stack_and_queue/" target="_blank" rel="noopener">尾尾部落</a> </p></blockquote><h3 id="0-基础概念"><a href="#0-基础概念" class="headerlink" title="0. 基础概念"></a>0. 基础概念</h3><p><strong>栈</strong>：后进先出（LIFO）</p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fux9mbb808j30bf0640sv.jpg" alt=""></p><p><strong>队列</strong>：先进先出（FIFO）</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fux9li0phxj30w006pt9d.jpg" alt=""></p><h3 id="1-栈的-java-实现"><a href="#1-栈的-java-实现" class="headerlink" title="1. 栈的 java 实现"></a>1. 栈的 java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//栈顶位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> init)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(init &amp;lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            init = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入栈的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == array.length)&#123;</span><br><span class="line">            array = Arrays.copyOf(array, size*<span class="number">2</span>);   <span class="comment">//扩容操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈顶元素，但栈顶元素不出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;  <span class="comment">//空栈</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"栈是空的"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[size-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈，同时获取栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> item = peek();  <span class="comment">//获取栈顶元素</span></span><br><span class="line">        size--;  <span class="comment">//直接使元素个数减1，不用清除元素，下次入栈会覆盖旧元素的值</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-队列的-java-实现"><a href="#2-队列的-java-实现" class="headerlink" title="2. 队列的 java 实现"></a>2. 队列的 java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] queue;  <span class="comment">//声明一个数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入队成功与否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == (tail+<span class="number">1</span>)%queue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[tail] = o;</span><br><span class="line">        tail = (tail+<span class="number">1</span>)%queue.length;  <span class="comment">//tail标记后移一位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队首元素，但不出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            <span class="comment">//队空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue[head];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = queue[head];</span><br><span class="line">        queue[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == (tail+<span class="number">1</span>)%queue.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail&amp;gt;=head)&#123;</span><br><span class="line">            <span class="keyword">return</span> tail-head;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (tail+queue.length)-head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-用两个栈实现队列"><a href="#3-用两个栈实现队列" class="headerlink" title="3. 用两个栈实现队列"></a>3. 用两个栈实现队列</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">用两个栈实现队列</a></p></blockquote><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Implement Queue using Stacks</a> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; input = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; output = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!input.isEmpty())</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.isEmpty() &amp;&amp; output.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-用队列实现栈"><a href="#4-用队列实现栈" class="headerlink" title="4. 用队列实现栈"></a>4. 用队列实现栈</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Implement Stack using Queues</a> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&amp;lt;Integer&amp;gt; q1 = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Queue&amp;lt;Integer&amp;gt; q2 = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.isEmpty())&#123;</span><br><span class="line">            q1.add(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; q2.size(); i++)&#123;</span><br><span class="line">                q1.add(q2.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q2.add(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; q1.size(); i++)&#123;</span><br><span class="line">                q2.add(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() ? q2.poll() : q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() ? q2.peek() : q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-包含min函数的栈"><a href="#5-包含min函数的栈" class="headerlink" title="5. 包含min函数的栈"></a>5. 包含min函数的栈</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">包含min函数的栈</a></p></blockquote><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(temp.isEmpty() || temp.peek() &amp;gt;= x)</span><br><span class="line">            temp.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> min = temp.peek();</span><br><span class="line">        <span class="keyword">if</span>(x == min)</span><br><span class="line">            temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temp.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-栈的压入、弹出序列"><a href="#6-栈的压入、弹出序列" class="headerlink" title="6. 栈的压入、弹出序列"></a>6. 栈的压入、弹出序列</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">栈的压入、弹出序列</a></p></blockquote><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA, <span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length != popA.length || </span><br><span class="line">               pushA.length == <span class="number">0</span> ||</span><br><span class="line">               popA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://www.weiweiblog.cn/stack_and_queue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;尾尾部落&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="stack" scheme="https://weiweiblog.cn/tags/stack/"/>
    
      <category term="queue" scheme="https://weiweiblog.cn/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>[算法总结] 20 道题搞定 BAT 面试——二叉树</title>
    <link href="https://weiweiblog.cn/20tree/"/>
    <id>https://weiweiblog.cn/20tree/</id>
    <published>2018-09-03T08:29:45.000Z</published>
    <updated>2020-05-17T07:27:05.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-几个概念"><a href="#0-几个概念" class="headerlink" title="0. 几个概念"></a>0. 几个概念</h3><p>完全二叉树：若二叉树的高度是h，除第h层之外，其他（1<del>h-1）层的节点数都达到了最大个数，并且第h层的节点都连续的集中在最左边。想到点什么没？实际上，完全二叉树和堆联系比较紧密哈</del></p><p>满二叉树：除最后一层外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点。</p><p>哈夫曼树：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p><p>二叉排序树：又称二叉查找树（Binary Search Tree），亦称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点</li></ul><p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p><p>平衡二叉树：又称 AVL 树。平衡二叉树是二叉搜索树的进化版，所谓平衡二叉树指的是，左右两个子树的高度差的绝对值不超过 1。</p><p>红黑树：红黑树是每个节点都带颜色的树，节点颜色或是红色或是黑色，红黑树是一种查找树。红黑树有一个重要的性质，从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍。对于红黑树，插入，删除，查找的复杂度都是O（log N）。</p><h3 id="1-求二叉树中的节点个数"><a href="#1-求二叉树中的节点个数" class="headerlink" title="1. 求二叉树中的节点个数"></a>1. 求二叉树中的节点个数</h3><p>递归解法：</p><p>（1）如果二叉树为空，节点个数为0</p><p>（2）如果不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</p><p>参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeNumRec</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">return</span> getNodeNumRec(root.left) + getNodeNumRec(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求二叉树的最大层数-最大深度"><a href="#2-求二叉树的最大层数-最大深度" class="headerlink" title="2. 求二叉树的最大层数(最大深度)"></a>2. 求二叉树的最大层数(最大深度)</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/treedepth/">二叉树的深度</a></p></blockquote><blockquote><p>递归解法：</p></blockquote><blockquote><p>（1）如果二叉树为空，二叉树的深度为0</p></blockquote><blockquote><p>（2）如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1</p></blockquote><blockquote><p>参考代码如下： </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-二叉树的最小深度"><a href="#2-1-二叉树的最小深度" class="headerlink" title="2.1 二叉树的最小深度"></a>2.1 二叉树的最小深度</h3><blockquote><p>LeetCode：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a></p></blockquote><blockquote><p>给定一个二叉树，找出其最小深度。</p></blockquote><blockquote><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuwr1dxogtj31e80ek0u8.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) ? left + right + <span class="number">1</span> : Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-先序遍历-前序遍历"><a href="#3-先序遍历-前序遍历" class="headerlink" title="3. 先序遍历/前序遍历"></a>3. 先序遍历/前序遍历</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Preorder Traversal</a></p></blockquote><blockquote><p>给定二叉树，返回其节点值的前序遍历。 </p></blockquote><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv7z3zzmpj31e20dmgmr.jpg" alt=""></p><p><code>根 - 左 - 右</code></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&amp;lt;Integer&amp;gt; preOrderReverse(TreeNode root)&#123;</span><br><span class="line">    ArrayList&amp;lt;Integer&amp;gt; result = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    preOrder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p>法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4. 中序遍历"></a>4. 中序遍历</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Inorder Traversal</a></p></blockquote><blockquote><p>给定二叉树，返回其节点值的中序遍历。 </p></blockquote><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv7x8fbwkj31e60dyq43.jpg" alt=""></p><p><code>左 - 根 - 右</code></p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-后序遍历"><a href="#5-后序遍历" class="headerlink" title="5. 后序遍历"></a>5. 后序遍历</h3><blockquote><p>Leetcode：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></p></blockquote><blockquote><p>给定二叉树，返回其节点值的后序遍历。 </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuv7s7s13wj31e20dogmr.jpg" alt=""></p><p><code>左 - 右 - 根</code></p><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; ans = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            <span class="comment">//采用逆序插入的方式</span></span><br><span class="line">            ans.addFirst(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode visited = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span> &amp;&amp; cur.right != visited)&#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    visited = cur;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    cur = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三(推荐)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; result = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Deque&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> ArrayDeque&amp;lt;&amp;gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                result.addFirst(p.val);  <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">                p = p.right;             <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line">                p = node.left;           <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-分层遍历"><a href="#6-分层遍历" class="headerlink" title="6. 分层遍历"></a>6. 分层遍历</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a></p></blockquote><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/printfromtoptobottom/">从上往下打印二叉树</a></p></blockquote><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/print/">把二叉树打印成多行</a></p></blockquote><blockquote><p>给定二叉树，返回其节点值的级别顺序遍历。 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv7qgpmmhj31ee0jiq4s.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&amp;lt;Integer&amp;gt; level = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">            <span class="keyword">int</span> l = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;l;i++)&#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-自下而上分层遍历"><a href="#6-1-自下而上分层遍历" class="headerlink" title="6.1 自下而上分层遍历"></a>6.1 自下而上分层遍历</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a></p></blockquote><blockquote><p>给定二叉树，返回其节点值的自下而上级别顺序遍历。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;count; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次都添加到第一个位置</span></span><br><span class="line">            res.add(<span class="number">0</span>, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-按之字形顺序打印二叉树"><a href="#6-2-按之字形顺序打印二叉树" class="headerlink" title="6.2 按之字形顺序打印二叉树"></a>6.2 按之字形顺序打印二叉树</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/printz/">按之字形顺序打印二叉树</a></p></blockquote><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 </p></blockquote><p>设两个栈，s2存放奇数层，s1存放偶数层</p><p>遍历s2节点的同时按照左子树、右子树的顺序加入s1，</p><p>遍历s1节点的同时按照右子树、左子树的顺序加入s2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s1 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s2 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        s2.push(pRoot);</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">            temp.clear();</span><br><span class="line">            flag ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-求二叉树第K层的节点个数"><a href="#7-求二叉树第K层的节点个数" class="headerlink" title="7. 求二叉树第K层的节点个数"></a>7. 求二叉树第K层的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_k_level_number</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || k &amp;lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_k_level_number(root.left, k-<span class="number">1</span>) + get_k_level_number(root.right, k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-求二叉树第K层的叶子节点个数"><a href="#8-求二叉树第K层的叶子节点个数" class="headerlink" title="8. 求二叉树第K层的叶子节点个数"></a>8. 求二叉树第K层的叶子节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_k_level_leaf_number</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || k &amp;lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_k_level_number(root.left, k-<span class="number">1</span>) + get_k_level_number(root.right, k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-判断两棵二叉树是否结构相同"><a href="#9-判断两棵二叉树是否结构相同" class="headerlink" title="9. 判断两棵二叉树是否结构相同"></a>9. 判断两棵二叉树是否结构相同</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Same Tree</a></p></blockquote><blockquote><p>给定两个二叉树，编写一个函数来检查它们是否相同。 </p></blockquote><p>递归解法：</p><p>（1）如果两棵二叉树都为空，返回真</p><p>（2）如果两棵二叉树一棵为空，另一棵不为空，返回假</p><p>（3）如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val == q.val)</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-判断二叉树是不是平衡二叉树"><a href="#10-判断二叉树是不是平衡二叉树" class="headerlink" title="10. 判断二叉树是不是平衡二叉树"></a>10. 判断二叉树是不是平衡二叉树</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Balanced Binary Tree</a></p></blockquote><blockquote><p>给定二叉树，确定它是否是高度平衡的。</p></blockquote><blockquote><p>对于此问题，高度平衡二叉树定义为： 一个二叉树，其中每个节点的两个子树的深度差不相差超过1。 </p></blockquote><p>递归解法：</p><p>（1）如果二叉树为空，返回真</p><p>（2）如果二叉树不为空，如果左子树和右子树高度相差不大于1且左子树和右子树都是AVL树，返回真，其他返回假</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxHigh(root.left) - maxHigh(root.right)) &amp;lt;= <span class="number">1</span> </span><br><span class="line">            &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHigh</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxHigh(root.left), maxHigh(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-求二叉树的镜像"><a href="#11-求二叉树的镜像" class="headerlink" title="11. 求二叉树的镜像"></a>11. 求二叉树的镜像</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/mirrortree/" target="_blank" rel="noopener">二叉树的镜像</a></p></blockquote><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Invert Binary Tree</a></p></blockquote><blockquote><p>反转二叉树 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuv7ea8p94j31ei0jq0u4.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-1-对称二叉树"><a href="#11-1-对称二叉树" class="headerlink" title="11.1 对称二叉树"></a>11.1 对称二叉树</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/issymmetrical/">[剑指offer] 对称的二叉树</a></p></blockquote><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Symmetric Tree</a></p></blockquote><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。</p></blockquote><blockquote></blockquote><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuws1gopizj31eo0jwq4x.jpg" alt=""> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || isSymmetricHelper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricHelper(left.left, right.right) &amp;&amp; isSymmetricHelper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-求二叉树中两个节点的最低公共祖先节点"><a href="#12-求二叉树中两个节点的最低公共祖先节点" class="headerlink" title="12. 求二叉树中两个节点的最低公共祖先节点"></a>12. 求二叉树中两个节点的最低公共祖先节点</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a></p></blockquote><blockquote><p>给定二叉树，找到树中两个给定节点的最低共同祖先（LCA）。 </p></blockquote><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv818buisj31du0rgjvi.jpg" alt=""></p><p>递归解法：</p><p>（1）如果两个节点分别在根节点的左子树和右子树，则返回根节点</p><p>（2）如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-1-求二叉搜索树的最近公共祖先"><a href="#12-1-求二叉搜索树的最近公共祖先" class="headerlink" title="12.1 求二叉搜索树的最近公共祖先"></a>12.1 求二叉搜索树的最近公共祖先</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a></p></blockquote><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><blockquote><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw3xgeyd0j31dw0r4dk0.jpg" alt=""></p><p>注意二叉搜索树的特性：<code>左子树</code> &lt; <code>根节点</code> &lt; <code>右子树</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &amp;gt; p.val &amp;&amp; root.val &amp;gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &amp;lt; p.val &amp;&amp; root.val &amp;lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-求二叉树的直径"><a href="#13-求二叉树的直径" class="headerlink" title="13. 求二叉树的直径"></a>13. 求二叉树的直径</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">Diameter of Binary Tree</a></p></blockquote><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fuw3a12zjaj31ek0e20ua.jpg" alt=""></p><p>递归解法：对于每个节点，它的最长路径等于左子树的最长路径+右子树的最长路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        diamHelper(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">diamHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = diamHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = diamHelper(root.right);</span><br><span class="line">        path = Math.max(path, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-由前序遍历序列和中序遍历序列重建二叉树"><a href="#14-由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="14. 由前序遍历序列和中序遍历序列重建二叉树"></a>14. 由前序遍历序列和中序遍历序列重建二叉树</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/reconstructbinarytree/" target="_blank" rel="noopener">重建二叉树</a></p></blockquote><blockquote><p>LeetCode：<a href="">Construct Binary Tree from Preorder and Inorder Traversal</a></p></blockquote><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。 </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw48smh0cj31dw0g6tai.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pre_start, <span class="keyword">int</span> pre_end, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_start &amp;gt; pre_end || in_start &amp;gt; in_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_start]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = in_start; i &amp;lt;= in_end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[pre_start])&#123;</span><br><span class="line">                <span class="comment">// 左子树的长度：i-is</span></span><br><span class="line">                root.left = buildTreeHelper(preorder, pre_start + <span class="number">1</span>, pre_start + i - in_start, inorder, in_start, i - <span class="number">1</span>);</span><br><span class="line">                root.right = buildTreeHelper(preorder, pre_start + i - in_start + <span class="number">1</span>, pre_end, inorder, i + <span class="number">1</span>, in_end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-1-从中序与后序遍历序列构造二叉树"><a href="#14-1-从中序与后序遍历序列构造二叉树" class="headerlink" title="14.1 从中序与后序遍历序列构造二叉树"></a>14.1 从中序与后序遍历序列构造二叉树</h3><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">Construct Binary Tree from Inorder and Postorder Traversal</a></p></blockquote><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。 </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw5432j6cj31dy0goabw.jpg" alt=""></p><p>本题与“从前序与中序遍历序列构造二叉树”是一个套路。唯一的区别是，后序序列的最后一个节点是根节点，因此我们要从后序序列的最后一个节点入手，再去中序序列中找到这个节点。在这个节点左侧的属于根节点的左子树部分，右侧的属于根节点右子树部分。然后根据左右子树节点的数量，在后序序列中找到他们各自的后序序列。比左子树节点个数为5，那么在后序序列中前五个节点就是左子树节点，之后的节点除了最后一个节点都是右子树节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> post_start, <span class="keyword">int</span> post_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_start &amp;gt; in_end || post_start &amp;gt; post_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[post_end]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = in_start; i &amp;lt;= in_end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[post_end])&#123;</span><br><span class="line">                root.left = buildTreeHelper(inorder, in_start, i - <span class="number">1</span>, postorder, post_start, post_start + i - in_start - <span class="number">1</span>);</span><br><span class="line">                root.right = buildTreeHelper(inorder, i + <span class="number">1</span>, in_end, postorder, post_start + i - in_start, post_end - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：根据前序和后序遍历无法构造出唯一的二叉树 </p></blockquote><h3 id="15-判断二叉树是不是完全二叉树"><a href="#15-判断二叉树是不是完全二叉树" class="headerlink" title="15. 判断二叉树是不是完全二叉树"></a>15. 判断二叉树是不是完全二叉树</h3><p>完全二叉树是指最后一层左边是满的，右边可能慢也不能不满，然后其余层都是满的，根据这个特性，利用层遍历。如果我们当前遍历到了NULL结点，如果后续还有非NULL结点，说明是非完全二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">_CheckCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="keyword">true</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="16-树的子结构"><a href="#16-树的子结构" class="headerlink" title="16. 树的子结构"></a>16. 树的子结构</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/issubtree/">树的子结构</a></p></blockquote><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsSubtree(root1, root2) || </span><br><span class="line">               HasSubtree(root1.left, root2) ||</span><br><span class="line">               HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要先判断roo2, 不然&#123;8,8,7,9,2,#,#,#,#,4,7&#125;,&#123;8,9,2&#125;这个测试用例通不过。</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> IsSubtree(root1.left, root2.left) &amp;&amp; </span><br><span class="line">                IsSubtree(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-二叉树中和为某一值的路径"><a href="#17-二叉树中和为某一值的路径" class="headerlink" title="17. 二叉树中和为某一值的路径"></a>17. 二叉树中和为某一值的路径</h3><blockquote><p>剑指offer：<a href="https://www.weiweiblog.cn/findpath/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></p></blockquote><blockquote><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">    ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        target -= root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            FindPath(root.left, target);</span><br><span class="line">            FindPath(root.right, target);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-二叉树的下一个结点"><a href="#18-二叉树的下一个结点" class="headerlink" title="18. 二叉树的下一个结点"></a>18. 二叉树的下一个结点</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/getnext/">二叉树的下一个结点</a></p></blockquote><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode node = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode root = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNode == root.left)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            pNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-序列化二叉树"><a href="#19-序列化二叉树" class="headerlink" title="19. 序列化二叉树"></a>19. 序列化二叉树</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/serialize/">序列化二叉树</a></p></blockquote><blockquote><p>LeetCode：<a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a></p></blockquote><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树 </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuwsmry0fsj31e20f4mym.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer(root.val + <span class="string">","</span>);</span><br><span class="line">        res.append(serialize(root.left));</span><br><span class="line">        res.append(serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String [] d = data.split(<span class="string">","</span>);</span><br><span class="line">        Queue&amp;lt;String&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; d.length; i++)&#123;</span><br><span class="line">            queue.offer(d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pre</span><span class="params">(Queue&amp;lt;String&amp;gt; queue)</span></span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(<span class="string">"#"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        node.left = pre(queue);</span><br><span class="line">        node.right = pre(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-二叉搜索树的第k个结点"><a href="#20-二叉搜索树的第k个结点" class="headerlink" title="20. 二叉搜索树的第k个结点"></a>20. 二叉搜索树的第k个结点</h3><blockquote><p>剑指offer：<a href="https://weiweiblog.cn/kthnode/">二叉搜索树的第k个结点</a></p></blockquote><blockquote><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 </p></blockquote><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuwt2r4qi6j31ec0q0jtp.jpg" alt=""></p><p>因为二叉搜索树按照中序遍历的顺序打印出来就是排好序的，所以，我们按照中序遍历找到第k个结点就是题目所求的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span>(count == k)</span><br><span class="line">                    <span class="keyword">return</span> node.val;</span><br><span class="line">                p = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-几个概念&quot;&gt;&lt;a href=&quot;#0-几个概念&quot; class=&quot;headerlink&quot; title=&quot;0. 几个概念&quot;&gt;&lt;/a&gt;0. 几个概念&lt;/h3&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://weiweiblog.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[算法总结] 17 题！ BAT面试涉及的链表题都在这里了</title>
    <link href="https://weiweiblog.cn/linkedlist_summary/"/>
    <id>https://weiweiblog.cn/linkedlist_summary/</id>
    <published>2018-08-27T20:35:29.000Z</published>
    <updated>2020-05-17T07:27:05.317Z</updated>
    
    <content type="html"><![CDATA[<p>链表是面试过程中经常被问到的，这里把剑指offer 和 LeetCode 中的相关题目做一个汇总，方便复习。</p><h4 id="1-在-O-1-时间删除链表节点"><a href="#1-在-O-1-时间删除链表节点" class="headerlink" title="1. 在 O(1) 时间删除链表节点"></a>1. 在 O(1) 时间删除链表节点</h4><p><strong>题目描述</strong>：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p><p><strong>解题思路</strong>：常规的做法是从链表的头结点开始遍历，找到需要删除的节点的前驱节点，把它的 next 指向要删除节点的下一个节点，平均时间复杂度为O(n)，不满足题目要求。</p><p>那是不是一定要得到被删除的节点的前一个节点呢？其实不用的。我们可以很方面地得到要删除节点的下一个节点，如果我们把下一个节点的内容复制到要删除的节点上覆盖原有的内容，再把下一个节点删除，那就相当于把当前要删除的节点删除了。举个栗子，我们要删除的节点i，先把i的下一个节点j的内容复制到i，然后把i的指针指向节点j的下一个节点。此时再删除节点j，其效果刚好是把节点i给删除了。</p><p>要注意两种情况：</p><ol><li>如果链表中只有一个节点，即头节点等于要删除的节点，此时我们在删除节点之后，还需要把链表的头节点设置为NULL。</li><li>如果要删除的节点位于链表的尾部，那么它就没有下一个节点，这时我们就要从链表的头节点开始，顺序遍历得到该节点的前序节点，并完成删除操作。</li></ol><p><strong>参考代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode toBeDeleted)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果输入参数有空值就返回表头结点  </span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || toBeDeleted == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果删除的是头结点，直接返回头结点的下一个结点  </span></span><br><span class="line">    <span class="keyword">if</span> (head == toBeDeleted) &#123;  </span><br><span class="line">        <span class="keyword">return</span> head.next;  </span><br><span class="line">    &#125;  </span><br><span class="line">      <span class="comment">// 下面的情况链表至少有两个结点  </span></span><br><span class="line">    <span class="comment">// 在多个节点的情况下，如果删除的是最后一个元素  </span></span><br><span class="line">    <span class="keyword">if</span> (toBeDeleted.next == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 找待删除元素的前驱  </span></span><br><span class="line">        ListNode tmp = head;  </span><br><span class="line">        <span class="keyword">while</span> (tmp.next != toBeDeleted) &#123;  </span><br><span class="line">            tmp = tmp.next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 删除待结点  </span></span><br><span class="line">        tmp.next = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 在多个节点的情况下，如果删除的是某个中间结点  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 将下一个结点的值输入当前待删除的结点  </span></span><br><span class="line">        toBeDeleted.value = toBeDeleted.next.value;  </span><br><span class="line">        <span class="comment">// 待删除的结点的下一个指向原先待删除引号的下下个结点，即将待删除的下一个结点删除  </span></span><br><span class="line">        toBeDeleted.next = toBeDeleted.next.next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 返回删除节点后的链表头结点  </span></span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="2-翻转单链表"><a href="#2-翻转单链表" class="headerlink" title="2. 翻转单链表"></a>2. 翻转单链表</h4><p><strong>题目描述</strong>：输出一个单链表的逆序反转后的链表。</p><p><strong>解题思路</strong>：用三个临时指针 prev、cur、next 在链表上循环一遍即可。</p><blockquote><p><a href="https://weiweiblog.cn/printlistfromtailtohead/">[剑指offer] 从尾到头打印链表</a></p></blockquote><blockquote><p><a href="https://weiweiblog.cn/reverselist/">[剑指offer] 反转链表</a> </p></blockquote><h4 id="3-翻转部分单链表："><a href="#3-翻转部分单链表：" class="headerlink" title="3. 翻转部分单链表："></a>3. 翻转部分单链表：</h4><p><strong>题目描述</strong>：给定一个单向链表的头结点head,以及两个整数from和to,在单链表上把第from个节点和第to个节点这一部分进行反转</p><blockquote><p>举例：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null, from = 2, to = 4</p></blockquote><blockquote><p>结果：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    ListNode reversedNewHead = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转后的头结点</span></span><br><span class="line">    ListNode reversedTail = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转后的尾结点</span></span><br><span class="line">    ListNode oldHead = head;<span class="comment">// 原链表的头结点</span></span><br><span class="line">    ListNode reversePreNode = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转前其头结点的前一个结点</span></span><br><span class="line">    ListNode reverseNextNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;gt; n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span>) &#123;</span><br><span class="line">            reversePreNode = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;gt;= m &amp;&amp; i &amp;lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                reversedTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseNextNode = head.next;</span><br><span class="line">            head.next = reversedNewHead;</span><br><span class="line">            reversedNewHead = head;</span><br><span class="line">            head = reverseNextNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    reversedTail.next = reverseNextNode;</span><br><span class="line">    <span class="keyword">if</span> (reversePreNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reversePreNode.next = reversedNewHead;</span><br><span class="line">        <span class="keyword">return</span> oldHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reversedNewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-旋转单链表"><a href="#4-旋转单链表" class="headerlink" title="4. 旋转单链表"></a>4. 旋转单链表</h4><p><strong>题目描述</strong>：给定一个单链表，设计一个算法实现链表向右旋转 K 个位置。</p><p>举例： 给定 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, K=3</p><p>则4-&gt;5-&gt;6-&gt;1-&gt;2-&gt;3-&gt;NULL</p><p><strong>解题思路</strong>：</p><ul><li><strong>方法一</strong> 双指针，快指针先走k步，然后两个指针一起走，当快指针走到末尾时，慢指针的下一个位置是新的顺序的头结点，这样就可以旋转链表了。</li><li><strong>方法二</strong> 先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n &#8211; k % n个节点就到达新链表的头结点前一个点，这时断开链表即可。</li></ul><p>方法二代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">int</span> m = n - k % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; m; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead = cur.next;</span><br><span class="line">        cur.next = NULL;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-删除单链表倒数第-n-个节点"><a href="#5-删除单链表倒数第-n-个节点" class="headerlink" title="5. 删除单链表倒数第 n 个节点"></a>5. 删除单链表倒数第 n 个节点</h4><p><strong>题目描述</strong>：删除单链表倒数第 n 个节点，1 &lt;= n &lt;= length，尽量在一次遍历中完成。</p><p><strong>解题思路</strong>：双指针法，找到倒数第 n+1 个节点，将它的 next 指向倒数第 n-1个节点。</p><blockquote><p><a href="https://weiweiblog.cn/findkthtotail/">[剑指offer] 链表中倒数第k个结点</a> </p></blockquote><h4 id="6-求单链表的中间节点"><a href="#6-求单链表的中间节点" class="headerlink" title="6. 求单链表的中间节点"></a>6. 求单链表的中间节点</h4><p><strong>题目描述</strong>：求单链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p><p><strong>解题思路</strong>：快慢指针，慢的走一步，快的走两步，当快指针到达尾节点时，慢指针移动到中间节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历一次，找出单链表的中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMiddleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-链表划分"><a href="#7-链表划分" class="headerlink" title="7. 链表划分"></a>7. 链表划分</h4><p><strong>题目描述</strong>： 给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head: The first node of linked list.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x: an integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: a ListNode </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode left = leftDummy, right = rightDummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &amp;lt; x) &#123;</span><br><span class="line">                left.next = head;</span><br><span class="line">                left = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.next = head;</span><br><span class="line">                right = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right.next = <span class="keyword">null</span>;</span><br><span class="line">        left.next = rightDummy.next;</span><br><span class="line">        <span class="keyword">return</span> leftDummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-链表求和"><a href="#8-链表求和" class="headerlink" title="8. 链表求和"></a>8. 链表求和</h4><p><strong>题目描述</strong>：你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p><p><strong>解题思路</strong>：做个大循环，对每一位进行操作：</p><blockquote><p>当前位：(A[i]+B[i])%10</p></blockquote><blockquote><p>进位：（A[i]+B[i]）/10 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode c1 = l1;</span><br><span class="line">        ListNode c2 = l2;</span><br><span class="line">        ListNode sentinel = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode d = sentinel;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (c1 != <span class="keyword">null</span> || c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (c1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum += c1.val;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum += c2.val;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            d = d.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum / <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-单链表排序"><a href="#9-单链表排序" class="headerlink" title="9. 单链表排序"></a>9. 单链表排序</h4><p><strong>题目描述</strong>：在O(nlogn)时间内对链表进行排序。</p><p><strong>快速排序</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用快速排序</span></span><br><span class="line">   quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != end) &#123;</span><br><span class="line">        ListNode node = partion(head, end);</span><br><span class="line">        quickSort(head, node);</span><br><span class="line">        quickSort(node.next, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partion</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head, p2 = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到末尾才停</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != end) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于key值时，p1向前走一步，交换p1与p2的值</span></span><br><span class="line">        <span class="keyword">if</span> (p2.val &amp;lt; head.val) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有序时，不交换p1和key值</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        head.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并排序</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用归并排序</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间结点</span></span><br><span class="line">    ListNode mid = getMid(head);</span><br><span class="line">    ListNode right = mid.next;</span><br><span class="line">    mid.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">return</span> mergeSort(sortList(head), sortList(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的中间结点,偶数时取中间第一个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    ListNode slow = head, quick = head;</span><br><span class="line">    <span class="comment">//快2步，慢一步</span></span><br><span class="line">    <span class="keyword">while</span> (quick.next != <span class="keyword">null</span> &amp;&amp; quick.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 归并两个有序的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head1, p2 = head2, head;</span><br><span class="line">   <span class="comment">//得到头节点的指向</span></span><br><span class="line">    <span class="keyword">if</span> (head1.val &amp;lt; head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//比较链表中的值</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1.val &amp;lt;= p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-合并两个排序的链表"><a href="#10-合并两个排序的链表" class="headerlink" title="10. 合并两个排序的链表"></a>10. 合并两个排序的链表</h4><p><strong>题目描述</strong>：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><blockquote><p><a href="https://weiweiblog.cn/mergelinklist/">[剑指offer] 合并两个排序的链表</a> </p></blockquote><h4 id="11-复杂链表的复制"><a href="#11-复杂链表的复制" class="headerlink" title="11. 复杂链表的复制"></a>11. 复杂链表的复制</h4><p><strong>题目描述</strong>：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><blockquote><p><a href="https://weiweiblog.cn/clonelink/">[剑指offer] 复杂链表的复制</a> </p></blockquote><h4 id="12-删除链表中重复的结点"><a href="#12-删除链表中重复的结点" class="headerlink" title="12. 删除链表中重复的结点"></a>12. 删除链表中重复的结点</h4><p><strong>题目描述</strong>：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><blockquote><p><a href="https://weiweiblog.cn/deleteduplication/">[剑指offer] 删除链表中重复的结点</a> </p></blockquote><h4 id="13-判断单链表是否存在环"><a href="#13-判断单链表是否存在环" class="headerlink" title="13. 判断单链表是否存在环"></a>13. 判断单链表是否存在环</h4><p><strong>题目描述</strong>：判断一个单链表是否有环</p><p>分析：快慢指针，慢指针每次移动一步，快指针每次移动两步，如果存在环，那么两个指针一定会在环内相遇。</p><h4 id="14-单链表是否有环扩展：找到环的入口点"><a href="#14-单链表是否有环扩展：找到环的入口点" class="headerlink" title="14. 单链表是否有环扩展：找到环的入口点"></a>14. 单链表是否有环扩展：找到环的入口点</h4><p><strong>题目描述</strong>：判断单链表是否有环，如果有，找到环的入口点</p><p><strong>解题思路</strong>：在第 5 题两个指针相遇后，让其中一个指针回到链表的头部，另一个指针在原地，同时往前每次走一步，当它们再次相遇时，就是在环路的入口点。</p><blockquote><p><a href="https://weiweiblog.cn/entrynodeofloop/">[剑指offer] 链表中环的入口结点</a> </p></blockquote><h4 id="15-判断两个无环单链表是否相交"><a href="#15-判断两个无环单链表是否相交" class="headerlink" title="15. 判断两个无环单链表是否相交"></a>15. 判断两个无环单链表是否相交</h4><p><strong>题目描述</strong>：给出两个无环单链表</p><p><strong>解题思路</strong>：</p><ul><li><strong>方法一</strong> 最直接的方法是判断 A 链表的每个节点是否在 B 链表中，但是这种方法的时间复杂度为 O(Length(A) * Length(B))。</li><li><strong>方法二</strong> 转化为环的问题。把 B 链表接在 A 链表后面，如果得到的链表有环，则说明两个链表相交。可以之前讨论过的快慢指针来判断是否有环，但是这里还有更简单的方法。如果 B 链表和 A 链表相交，把 B 链表接在 A 链表后面时，B 链表的所有节点都在环内，所以此时只需要遍历 B 链表，看是否会回到起点就可以判断是否相交。这个方法需要先遍历一次 A 链表，找到尾节点，然后还要遍历一次 B 链表，判断是否形成环，时间复杂度为 O(Length(A) + Length(B))。</li><li><strong>方法三</strong> 除了转化为环的问题，还可以利用“如果两个链表相交于某一节点，那么之后的节点都是共有的”这个特点，如果两个链表相交，那么最后一个节点一定是共有的。所以可以得出另外一种解法，先遍历 A 链表，记住尾节点，然后遍历 B 链表，比较两个链表的尾节点，如果相同则相交，不同则不相交。时间复杂度为 O(Length(A) + Length(B))，空间复杂度为 O(1)，思路比解法 2 更简单。</li></ul><p>方法三的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIntersect</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == headA || <span class="keyword">null</span> == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != headA.next) &#123;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != headB.next) &#123;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headA == headB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-两个链表相交扩展：求两个无环单链表的第一个相交点"><a href="#16-两个链表相交扩展：求两个无环单链表的第一个相交点" class="headerlink" title="16. 两个链表相交扩展：求两个无环单链表的第一个相交点"></a>16. 两个链表相交扩展：求两个无环单链表的第一个相交点</h4><p><strong>题目描述</strong>：找到两个无环单链表第一个相交点，如果不相交返回空，要求在线性时间复杂度和常量空间复杂度内完成。</p><p><strong>解题思路</strong>：</p><ul><li><strong>方法一</strong> 如果两个链表存在公共结点，那么它们从公共结点开始一直到链表的结尾都是一样的，因此我们只需要从链表的结尾开始，往前搜索，找到最后一个相同的结点即可。但是题目给出的单向链表，我们只能从前向后搜索，这时，我们就可以借助栈来完成。先把两个链表依次装到两个栈中，然后比较两个栈的栈顶结点是否相同，如果相同则出栈，如果不同，那最后相同的结点就是我们要的返回值。</li><li><strong>方法二</strong> 先找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走，直到找到第一个公共结点。</li><li><strong>方法三</strong> 由于2个链表都没有环，我们可以把第二个链表接在第一个链表后面，这样就把问题转化为求环的入口节点问题。</li><li><strong>方法四</strong> 两个指针p1和p2分别指向链表A和链表B，它们同时向前走，当走到尾节点时，转向另一个链表，比如p1走到链表 A 的尾节点时，下一步就走到链表B，p2走到链表 B 的尾节点时，下一步就走到链表 A，当p1==p2 时，就是链表的相交点</li></ul><p>方法四的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == headA || <span class="keyword">null</span> == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    ListNode p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 遍历完所在链表后从另外一个链表再开始</span></span><br><span class="line">        <span class="comment">// 当 p1 和 p2 都换到另一个链表时，它们对齐了：</span></span><br><span class="line">        <span class="comment">// （1）如果链表相交，p1 == p2 时为第一个相交点</span></span><br><span class="line">        <span class="comment">// （2）如果链表不相交，p1 和 p2 同时移动到末尾，p1 = p2 = null，然后退出循环</span></span><br><span class="line">        p1 = (<span class="keyword">null</span> == p1) ? headB : p1.next;</span><br><span class="line">        p2 = (<span class="keyword">null</span> == p2) ? headA : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://weiweiblog.cn/findfirstcommonnode/">[剑指offer] 两个链表的第一个公共结点</a> </p></blockquote><h4 id="17-两个链表相交扩展：判断两个有环单链表是否相交"><a href="#17-两个链表相交扩展：判断两个有环单链表是否相交" class="headerlink" title="17. 两个链表相交扩展：判断两个有环单链表是否相交"></a>17. 两个链表相交扩展：判断两个有环单链表是否相交</h4><p><strong>题目描述</strong>：上面的问题是针对无环链表的，如果是链表有环呢？</p><p><strong>解题思路</strong>：如果两个有环单链表相交，那么它们一定共有一个环，即环上的任意一个节点都存在于两个链表上。因此可以先用之前快慢指针的方式找到两个链表中位于环内的两个节点，如果相交的话，两个节点在一个环内，那么移动其中一个节点，在一次循环内肯定可以与另外一个节点相遇。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表是面试过程中经常被问到的，这里把剑指offer 和 LeetCode 中的相关题目做一个汇总，方便复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="https://weiweiblog.cn/tags/java/"/>
    
      <category term="Leetcode" scheme="https://weiweiblog.cn/tags/Leetcode/"/>
    
      <category term="剑指offer" scheme="https://weiweiblog.cn/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="链表" scheme="https://weiweiblog.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>[算法总结] 十大排序算法</title>
    <link href="https://weiweiblog.cn/10sort/"/>
    <id>https://weiweiblog.cn/10sort/</id>
    <published>2018-08-20T23:27:34.000Z</published>
    <updated>2020-05-17T07:27:05.250Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。</p><p>下面介绍几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序的思想，其代码均采用Java实现。</p><h3 id="1-冒泡排序-O-n-2"><a href="#1-冒泡排序-O-n-2" class="headerlink" title="1. 冒泡排序 $O(n^2)$"></a>1. 冒泡排序 $O(n^2)$</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/640.gif" alt="冒泡排序"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &amp;gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop j</span></span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;<span class="comment">// method bubbleSort</span></span><br></pre></td></tr></table></figure><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n^2 )。因此，算法在数据基本有序的情况下，性能最好。</p><p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        swap=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &amp;gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swap=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop j</span></span><br><span class="line">        <span class="keyword">if</span> (swap==<span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;<span class="comment">// method bubbleSort</span></span><br></pre></td></tr></table></figure><h3 id="2-选择排序-O-n-2"><a href="#2-选择排序-O-n-2" class="headerlink" title="2. 选择排序 $O(n^2)$"></a>2. 选择排序 $O(n^2)$</h3><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/640-1.gif" alt="选择排序"></p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="comment">// 循环查找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &amp;lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &amp;gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><p>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。</p><p>不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是不稳定的。</p><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n^2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p><h3 id="3-插入排序-O-n-2"><a href="#3-插入排序-O-n-2" class="headerlink" title="3. 插入排序 $O(n^2)$"></a>3. 插入排序 $O(n^2)$</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。</li><li>重复上述过程直到最后一个元素被插入有序子数组中。</li></ol><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/849589-20171015225645277-1151100000.gif" alt="插入排序"></p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> position=i;</span><br><span class="line">        <span class="keyword">while</span> (position&amp;gt;<span class="number">0</span> &amp;&amp; arr[position-<span class="number">1</span>]&amp;gt;value)&#123;</span><br><span class="line">            arr[position] = arr[position-<span class="number">1</span>];</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[position] = value;</span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法。</p><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>插入排序由于O( n^2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</p><h3 id="4-归并排序-O-N-logN"><a href="#4-归并排序-O-N-logN" class="headerlink" title="4. 归并排序 $O(N*logN)$"></a>4. 归并排序 $O(N*logN)$</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>两种方法</p><ul><li>递归法（Top-down）</li></ul><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><ul><li>迭代法（Bottom-up）</li></ul><p>原理如下（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素</li><li>若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1</li></ol><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp =<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    internalMergeSort(arr, temp, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalMergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">    <span class="keyword">if</span> (left&amp;lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        internalMergeSort(arr, temp, left, middle);          <span class="comment">//左子数组</span></span><br><span class="line">        internalMergeSort(arr, temp, middle+<span class="number">1</span>, right);       <span class="comment">//右子数组</span></span><br><span class="line">        mergeSortedArray(arr, temp, left, middle, right);    <span class="comment">//合并两个子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序子序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortedArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;      </span><br><span class="line">    <span class="keyword">int</span> j=middle+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&amp;lt;=middle &amp;&amp; j&amp;lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[i] &amp;lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &amp;lt;=middle)&#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&amp;lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&amp;lt;k; ++i)&#123;</span><br><span class="line">        arr[left+i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h4><p>因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。</p><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h3 id="5-快速排序-O-N-logN"><a href="#5-快速排序-O-N-logN" class="headerlink" title="5. 快速排序 $O(N*logN)$"></a>5. 快速排序 $O(N*logN)$</h3><p>快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。</p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>从数列中挑出一个元素，称为&#8221;基准&#8221;（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &amp;gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, low, high);        <span class="comment">//将数组分为两部分</span></span><br><span class="line">    qsort(arr, low, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></span><br><span class="line">    qsort(arr, pivot+<span class="number">1</span>, high);                  <span class="comment">//递归排序右子数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];     <span class="comment">//基准</span></span><br><span class="line">    <span class="keyword">while</span> (low &amp;lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &amp;lt; high &amp;&amp; arr[high] &amp;gt;= pivot) --high;</span><br><span class="line">        arr[low]=arr[high];             <span class="comment">//交换比基准大的记录到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &amp;lt; high &amp;&amp; arr[low] &amp;lt;= pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];           <span class="comment">//交换比基准小的记录到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描完成，基准到位</span></span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="comment">//返回的是基准的位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h4><p>快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h4><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><h3 id="6-堆排序-O-N-logN"><a href="#6-堆排序-O-N-logN" class="headerlink" title="6. 堆排序 $O(N*logN)$"></a>6. 堆排序 $O(N*logN)$</h3><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><p>关于树的概念请参考：<a href="">[算法总结] 二叉树</a></p><h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fufzubvoquj30fo052dga.jpg" alt=""></p><p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = floor(i/2)，i 的父节点下标</li><li>Left(i) = 2i，i 的左子节点下标</li><li>Right(i) = 2i + 1，i 的右子节点下标</li></ul><p>二叉堆一般分为两种：最大堆和最小堆。</p><p><strong>最大堆：</strong></p><p>最大堆中的最大元素值出现在根结点（堆顶）</p><p>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fug00fssjwj30ad034q35.jpg" alt=""></p><p><strong>最小堆：</strong></p><p>最小堆中的最小元素值出现在根结点（堆顶）</p><p>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fug00saf77j30aa034mxd.jpg" alt=""></p><h4 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h4><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li><p>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li><li><p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</p></li><li><p>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p><p>继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变</p></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fug05te8saj30fm05eaah.jpg" alt=""></p><p>相应的，几个计算公式也要作出相应调整：</p><ul><li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li><li>Left(i) = 2i + 1，i 的左子节点下标</li><li>Right(i) = 2(i + 1)，i 的右子节点下标</li></ul><h4 id="堆的建立和维护"><a href="#堆的建立和维护" class="headerlink" title="堆的建立和维护"></a>堆的建立和维护</h4><p>堆可以支持多种操作，但现在我们关心的只有两个问题：</p><ol><li>给定一个无序数组，如何建立为堆？</li><li>删除堆顶元素后，如何调整数组成为新堆？</li></ol><p>先看第二个问题。假定我们已经有一个现成的大根堆。现在我们删除了根元素，但并没有移动别的元素。想想发生了什么：根元素空了，但其它元素还保持着堆的性质。我们可以把<strong>最后一个元素</strong>（代号A）移动到根元素的位置。如果不是特殊情况，则堆的性质被破坏。但这仅仅是由于A小于其某个子元素。于是，我们可以把A和这个子元素调换位置。如果A大于其所有子元素，则堆调整好了；否则，重复上述过程，A元素在树形结构中不断“下沉”，直到合适的位置，数组重新恢复堆的性质。上述过程一般称为“筛选”，方向显然是自上而下。</p><blockquote><p>删除后的调整，是把最后一个元素放到堆顶，自上而下比较 </p></blockquote><p>删除一个元素是如此，插入一个新元素也是如此。不同的是，我们把新元素放在<strong>末尾</strong>，然后和其父节点做比较，即自下而上筛选。</p><blockquote><p>插入是把新元素放在末尾，自下而上比较 </p></blockquote><p>那么，第一个问题怎么解决呢？</p><p>常规方法是从第一个非叶子结点向下筛选，直到根元素筛选完毕。这个方法叫“筛选法”，需要循环筛选n/2个元素。</p><p>但我们还可以借鉴“插入排序”的思路。我们可以视第一个元素为一个堆，然后不断向其中添加新元素。这个方法叫做“插入法”，需要循环插入(n-1)个元素。</p><p>由于筛选法和插入法的方式不同，所以，相同的数据，它们建立的堆一般不同。大致了解堆之后，堆排序就是水到渠成的事情了。</p><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt=""></p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>我们需要一个升序的序列，怎么办呢？我们可以建立一个最小堆，然后每次输出根元素。但是，这个方法需要额外的空间（否则将造成大量的元素移动，其复杂度会飙升到O(n^2) ）。如果我们需要就地排序（即不允许有O(n)空间复杂度），怎么办？</p><p>有办法。我们可以建立最大堆，然后我们倒着输出，在最后一个位置输出最大值，次末位置输出次大值……由于每次输出的最大元素会腾出第一个空间，因此，我们恰好可以放置这样的元素而不需要额外空间。很漂亮的想法，是不是？</p><h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整堆。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right, j;</span><br><span class="line">        left = getLeftChildIndex(i);</span><br><span class="line">        <span class="keyword">while</span> (left &amp;lt;= len) &#123;</span><br><span class="line">            right = left + <span class="number">1</span>;</span><br><span class="line">            j = left;</span><br><span class="line">            <span class="keyword">if</span> (j &amp;lt; len &amp;&amp; arr[left] &amp;lt; arr[right]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &amp;lt; arr[j]) &#123;</span><br><span class="line">                swap(array, i, j);</span><br><span class="line">                i = j;</span><br><span class="line">                left = getLeftChildIndex(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 停止筛选</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = getParentIndex(last); i &amp;gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjustHeap(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆调整</span></span><br><span class="line">        <span class="keyword">while</span> (last &amp;gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            swap(<span class="number">0</span>, last--);</span><br><span class="line">            adjustHeap(<span class="number">0</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-5"><a href="#稳定性-5" class="headerlink" title="稳定性"></a>稳定性</h4><p>堆排序存在大量的筛选和移动过程，属于不稳定的排序算法。</p><h4 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h4><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><h3 id="7-希尔排序（插入排序的改良版）-O-N-logN"><a href="#7-希尔排序（插入排序的改良版）-O-N-logN" class="headerlink" title="7. 希尔排序（插入排序的改良版）$O(N*logN)$"></a>7. 希尔排序（插入排序的改良版）$O(N*logN)$</h3><p>在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：</p><ol><li>插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。</li><li>但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</li></ol><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt=""></p><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><p>Donald Shell增量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> delta = arr.length/<span class="number">2</span>; delta&amp;gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;                              <span class="comment">//对每个增量进行一次排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=delta; i&amp;lt;arr.length; i++)&#123;              </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&amp;gt;=delta &amp;&amp; arr[j]&amp;lt;arr[j-delta]; j-=delta)&#123; <span class="comment">//注意每个地方增量和差值都是delta</span></span><br><span class="line">                temp = arr[j-delta];</span><br><span class="line">                arr[j-delta] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop i</span></span><br><span class="line">    &#125;<span class="comment">//loop delta</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n^(3/2)) by Knuth</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (delta &amp;lt; arr.length/<span class="number">3</span>)&#123;<span class="comment">//generate delta</span></span><br><span class="line">        delta=delta*<span class="number">3</span>+<span class="number">1</span>;    <span class="comment">// &amp;lt;O(n^(3/2)) by Knuth,1973&amp;gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; delta&amp;gt;=<span class="number">1</span>; delta/=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=delta; i&amp;lt;arr.length; i++)&#123;              </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&amp;gt;=delta &amp;&amp; arr[j]&amp;lt;arr[j-delta]; j-=delta)&#123;</span><br><span class="line">                temp = arr[j-delta];</span><br><span class="line">                arr[j-delta] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop i</span></span><br><span class="line">    &#125;<span class="comment">//loop delta</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序的增量"><a href="#希尔排序的增量" class="headerlink" title="希尔排序的增量"></a>希尔排序的增量</h4><p>希尔排序的增量数列可以任取，需要的唯一条件是最后一个一定为1（因为要保证按1有序）。但是，不同的数列选取会对算法的性能造成极大的影响。上面的代码演示了两种增量。</p><p>切记：增量序列中每两个元素最好不要出现1以外的公因子！（很显然，按4有序的数列再去按2排序意义并不大）。</p><p>下面是一些常见的增量序列。</p><p>&#8211; 第一种增量是最初Donald Shell提出的增量，即折半降低直到1。据研究，使用希尔增量，其时间复杂度还是O(n2)。</p><p>第二种增量Hibbard：{1, 3, &#8230;, 2^k-1}。该增量序列的时间复杂度大约是O(n^1.5)。</p><p>第三种增量Sedgewick增量：(1, 5, 19, 41, 109,&#8230;)，其生成序列或者是9_4^i &#8211; 9_2^i + 1或者是4^i &#8211; 3*2^i + 1。</p><h4 id="稳定性-6"><a href="#稳定性-6" class="headerlink" title="稳定性"></a>稳定性</h4><p>我们都知道插入排序是稳定算法。但是，Shell排序是一个多次插入的过程。在一次插入中我们能确保不移动相同元素的顺序，但在多次的插入中，相同元素完全有可能在不同的插入轮次被移动，最后稳定性被破坏，因此，Shell排序不是一个稳定的算法。</p><h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h4><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀&#8211;快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h3 id="计数排序-O-n-k"><a href="#计数排序-O-n-k" class="headerlink" title="计数排序 $O(n+k)$"></a>计数排序 $O(n+k)$</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt=""></p><h4 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//存储数组</span></span><br><span class="line">     <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];<span class="comment">//计数数组</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num = min; num &amp;lt;= max; num++) &#123;</span><br><span class="line">        <span class="comment">//初始化各元素值为0，数组下标从0开始因此减min</span></span><br><span class="line">        count[num - min] = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = a[i];</span><br><span class="line">        count[num - min]++;<span class="comment">//每出现一个值，计数数组对应元素的值+1</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num = min + <span class="number">1</span>; num &amp;lt;= max; num++) &#123;</span><br><span class="line">        <span class="comment">//加总数组元素的值为计数数组对应元素及左边所有元素的值的总和</span></span><br><span class="line">        count[num - min] += count[num - min - <span class="number">1</span>]</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; a.length; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> num = a[i];<span class="comment">//源数组第i位的值</span></span><br><span class="line">          <span class="keyword">int</span> index = count[num - min] - <span class="number">1</span>;<span class="comment">//加总数组中对应元素的下标</span></span><br><span class="line">          b[index] = num;<span class="comment">//将该值存入存储数组对应下标中</span></span><br><span class="line">          count[num - min]--;<span class="comment">//加总数组中，该值的总和减少1。</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//将存储数组的值一一替换给源数组</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;a.length;i++)&#123;</span><br><span class="line">         a[i] = b[i];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-7"><a href="#稳定性-7" class="headerlink" title="稳定性"></a>稳定性</h4><p>最后给 b 数组赋值是倒着遍历的，而且放进去一个就将C数组对应的值（表示前面有多少元素小于或等于A[i]）减去一。如果有相同的数x1,x2，那么相对位置后面那个元素x2放在（比如下标为4的位置），相对位置前面那个元素x1下次进循环就会被放在x2前面的位置3。从而保证了稳定性。</p><h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h4><p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p><blockquote><p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。网络中很多博文写的桶排序实际上都是计数排序，并非标准的桶排序，要注意辨别。 </p></blockquote><h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序数组中的最大值max、最小值min</li><li>我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1</li><li>遍历数组 arr，计算每个元素 arr[i] 放的桶</li><li>每个桶各自排序</li><li>遍历桶数组，把排序好的元素放进输出数组</li></ol><h4 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuhazwnaezj30rp0q4go7.jpg" alt=""></p><h4 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-8"><a href="#稳定性-8" class="headerlink" title="稳定性"></a>稳定性</h4><p>可以看出，在分桶和从桶依次输出的过程是稳定的。但是，由于我们在对每个桶进行排序时使用了其他算法，所以，桶排序的稳定性依赖于这一步。如果我们使用了快排，显然，算法是不稳定的。</p><h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h4><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h4 id="动图"><a href="#动图" class="headerlink" title="动图"></a>动图</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt=""></p><h4 id="算法实现-9"><a href="#算法实现-9" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSorter</span> <span class="keyword">extends</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> radix;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">RadixSorter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          radix = <span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 数组的第一维表示可能的余数0-radix，第二维表示array中的等于该余数的元素</span></span><br><span class="line">          <span class="comment">// 如：十进制123的个位为3，则bucket[3][] = &#123;123&#125;</span></span><br><span class="line">          <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[radix][array.length];</span><br><span class="line">          <span class="keyword">int</span> distance = getDistance(array); <span class="comment">// 表示最大的数有多少位</span></span><br><span class="line">          <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> round = <span class="number">1</span>; <span class="comment">// 控制键值排序依据在哪一位</span></span><br><span class="line">          <span class="keyword">while</span> (round &amp;lt;= distance) &#123;</span><br><span class="line">               <span class="comment">// 用来计数：数组counter[i]用来表示该位是i的数的个数</span></span><br><span class="line">               <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">               <span class="comment">// 将array中元素分布填充到bucket中，并进行计数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> which = (array[i] / temp) % radix;</span><br><span class="line">                    bucket[which][counter[which]] = array[i];</span><br><span class="line">                    counter[which]++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">// 根据bucket中收集到的array中的元素，根据统计计数，在array中重新排列</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; radix; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counter[i] != <span class="number">0</span>)</span><br><span class="line">                         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; counter[i]; j++) &#123;</span><br><span class="line">                              array[index] = bucket[i][j];</span><br><span class="line">                              index++;</span><br><span class="line">                         &#125;</span><br><span class="line">                    counter[i] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               temp *= radix;</span><br><span class="line">               round++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> max = computeMax(array);</span><br><span class="line">          <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> temp = max / radix;</span><br><span class="line">          <span class="keyword">while</span>(temp != <span class="number">0</span>) &#123;</span><br><span class="line">               digits++;</span><br><span class="line">               temp = temp / radix;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> digits + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeMax</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;array.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(array[i]&amp;gt;max) &#123;</span><br><span class="line">                    max = array[i];</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性-9"><a href="#稳定性-9" class="headerlink" title="稳定性"></a>稳定性</h4><p>通过上面的排序过程，我们可以看到，每一轮映射和收集操作，都保持从左到右的顺序进行，如果出现相同的元素，则保持他们在原始数组中的顺序。可见，基数排序是一种稳定的排序。</p><h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h4><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuhcs1ji9yj30qc0qm43d.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>LeetCode领扣:<a href="https://mp.weixin.qq.com/s/VX9LwTK77RUPLBFHPS1Z1A" target="_blank" rel="noopener">面试 | 常用的排序算法总结</a></li><li>飞翔的猫咪: <a href="http://blog.51cto.com/flyingcat2013" target="_blank" rel="noopener">用Java写算法</a></li><li>bubkoo: <a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法</a></li></ol><blockquote><p>获取更多最新资讯，免费获取百G视频教程</p></blockquote><blockquote><p>请关注微信公众号：南强说晚安 </p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="冒泡排序" scheme="https://weiweiblog.cn/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="https://weiweiblog.cn/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://weiweiblog.cn/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://weiweiblog.cn/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://weiweiblog.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://weiweiblog.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序算法" scheme="https://weiweiblog.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="https://weiweiblog.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="桶排序" scheme="https://weiweiblog.cn/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="计数排序" scheme="https://weiweiblog.cn/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://weiweiblog.cn/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[剑指offer] JAVA版题解（完整版）</title>
    <link href="https://weiweiblog.cn/jzoffer_java/"/>
    <id>https://weiweiblog.cn/jzoffer_java/</id>
    <published>2018-08-15T23:22:35.000Z</published>
    <updated>2020-05-17T07:27:05.315Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">序号</th><th align="center">题解</th><th align="center">牛客 OJ</th><th align="center">数据结构类型</th></tr></thead><tbody><tr><td align="center">03</td><td align="center"><a href="https://www.weiweiblog.cn/find2array/" target="_blank" rel="noopener">[剑指offer] 二维数组中的查找</a></td><td align="center"><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">二维数组中的查找</a></td><td align="center">数组</td></tr><tr><td align="center">04</td><td align="center"><a href="https://www.weiweiblog.cn/replacespace/" target="_blank" rel="noopener">[剑指offer] 替换空格</a></td><td align="center"><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">替换空格</a></td><td align="center">字符串</td></tr><tr><td align="center">05</td><td align="center"><a href="https://www.weiweiblog.cn/printlistfromtailtohead/" target="_blank" rel="noopener">[剑指offer] 从尾到头打印链表</a></td><td align="center"><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从尾到头打印链表</a></td><td align="center">链表</td></tr><tr><td align="center">06</td><td align="center"><a href="https://www.weiweiblog.cn/reconstructbinarytree/" target="_blank" rel="noopener">[剑指offer] 重建二叉树</a></td><td align="center"><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">重建二叉树</a></td><td align="center">树</td></tr><tr><td align="center">07</td><td align="center"><a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">[剑指offer] 用两个栈实现队列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">用两个栈实现队列</a></td><td align="center">栈、队列</td></tr><tr><td align="center">08</td><td align="center"><a href="https://www.weiweiblog.cn/minnumberinrotatearray/" target="_blank" rel="noopener">[剑指offer] 旋转数组的最小数字</a></td><td align="center"><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">旋转数组的最小数字</a></td><td align="center">数组</td></tr><tr><td align="center">09</td><td align="center"><a href="https://www.weiweiblog.cn/fibonacci/" target="_blank" rel="noopener">[剑指offer] 斐波那契数列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">斐波那契数列</a></td><td align="center">数组</td></tr><tr><td align="center">10</td><td align="center"><a href="https://www.weiweiblog.cn/numberof1/" target="_blank" rel="noopener">[剑指offer] 二进制中1的个数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二进制中1的个数</a></td><td align="center">数组</td></tr><tr><td align="center">11</td><td align="center"><a href="https://www.weiweiblog.cn/power/" target="_blank" rel="noopener">[剑指offer] 数值的整数次方</a></td><td align="center"><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数值的整数次方</a></td><td align="center">数值</td></tr><tr><td align="center">14</td><td align="center"><a href="https://www.weiweiblog.cn/reorderarray/" target="_blank" rel="noopener">[剑指offer] 调整数组顺序使奇数位于偶数前面</a></td><td align="center"><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></td><td align="center">数组</td></tr><tr><td align="center">15</td><td align="center"><a href="https://www.weiweiblog.cn/findkthtotail/" target="_blank" rel="noopener">[剑指offer] 链表中倒数第k个结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">链表中倒数第k个结点</a></td><td align="center">链表</td></tr><tr><td align="center">16</td><td align="center"><a href="https://www.weiweiblog.cn/reverselist/" target="_blank" rel="noopener">[剑指offer] 反转链表</a></td><td align="center"><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">反转链表</a></td><td align="center">链表</td></tr><tr><td align="center">17</td><td align="center"><a href="https://www.weiweiblog.cn/mergelinklist/" target="_blank" rel="noopener">[剑指offer] 合并两个排序的链表</a></td><td align="center"><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">合并两个排序的链表</a></td><td align="center">链表</td></tr><tr><td align="center">18</td><td align="center"><a href="https://www.weiweiblog.cn/issubtree/" target="_blank" rel="noopener">[剑指offer] 树的子结构</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">树的子结构</a></td><td align="center">树</td></tr><tr><td align="center">19</td><td align="center"><a href="https://www.weiweiblog.cn/mirrortree/" target="_blank" rel="noopener">[剑指offer] 二叉树的镜像</a></td><td align="center"><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的镜像</a></td><td align="center">树</td></tr><tr><td align="center">20</td><td align="center"><a href="https://www.weiweiblog.cn/printmatrix/" target="_blank" rel="noopener">[剑指offer] 顺时针打印矩阵</a></td><td align="center"><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">顺时针打印矩阵</a></td><td align="center">数组</td></tr><tr><td align="center">21</td><td align="center"><a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">[剑指offer] 包含min函数的栈</a></td><td align="center"><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">包含min函数的栈</a></td><td align="center">栈</td></tr><tr><td align="center">22</td><td align="center"><a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">[剑指offer] 栈的压入、弹出序列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">栈的压入、弹出序列</a></td><td align="center">栈</td></tr><tr><td align="center">23</td><td align="center"><a href="https://www.weiweiblog.cn/printfromtoptobottom/" target="_blank" rel="noopener">[剑指offer] 从上往下打印二叉树</a></td><td align="center"><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从上往下打印二叉树</a></td><td align="center">树</td></tr><tr><td align="center">24</td><td align="center"><a href="https://www.weiweiblog.cn/verifysquenceofbst/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树的后序遍历序列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></td><td align="center">树</td></tr><tr><td align="center">25</td><td align="center"><a href="https://www.weiweiblog.cn/findpath/" target="_blank" rel="noopener">[剑指offer] 二叉树中和为某一值的路径</a></td><td align="center"><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></td><td align="center">树</td></tr><tr><td align="center">26</td><td align="center"><a href="https://www.weiweiblog.cn/clonelink/" target="_blank" rel="noopener">[剑指offer] 复杂链表的复制</a></td><td align="center"><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">复杂链表的复制</a></td><td align="center">链表</td></tr><tr><td align="center">27</td><td align="center"><a href="https://www.weiweiblog.cn/converttree/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树与双向链表</a></td><td align="center"><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树与双向链表</a></td><td align="center">树、链表</td></tr><tr><td align="center">28</td><td align="center"><a href="https://www.weiweiblog.cn/permutation/" target="_blank" rel="noopener">[剑指offer] 字符串的排列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">字符串的排列</a></td><td align="center">字符串</td></tr><tr><td align="center">29</td><td align="center"><a href="https://www.weiweiblog.cn/morethanhalfnum_solution/" target="_blank" rel="noopener">[剑指offer] 数组中出现次数超过一半的数字</a></td><td align="center"><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></td><td align="center">数组</td></tr><tr><td align="center">30</td><td align="center"><a href="https://www.weiweiblog.cn/getleastnumbers_solution/" target="_blank" rel="noopener">[剑指offer] 最小的K个数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">最小的k个数</a></td><td align="center">数组</td></tr><tr><td align="center">31</td><td align="center"><a href="https://www.weiweiblog.cn/findgreatestsumofsubarray/" target="_blank" rel="noopener">[剑指offer] 连续子数组的最大和</a></td><td align="center"><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">连续子数组的最大和</a></td><td align="center">数组</td></tr><tr><td align="center">32</td><td align="center"><a href="https://www.weiweiblog.cn/numberof1between1andn_solution/" target="_blank" rel="noopener">[剑指offer] 整数中1出现的次数（从1到n整数中1出现的次数）</a></td><td align="center"><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从1到n整数中1出现的次数</a></td><td align="center">数组</td></tr><tr><td align="center">33</td><td align="center"><a href="https://www.weiweiblog.cn/printminnumber/" target="_blank" rel="noopener">[剑指offer] 把数组排成最小的数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把数组排成最小的数</a></td><td align="center">数组</td></tr><tr><td align="center">34</td><td align="center"><a href="https://www.weiweiblog.cn/getuglynumber_solution/" target="_blank" rel="noopener">[剑指offer] 丑数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">丑数</a></td><td align="center">数值</td></tr><tr><td align="center">35</td><td align="center"><a href="https://www.weiweiblog.cn/firstnotrepeatingchar/" target="_blank" rel="noopener">[剑指offer] 第一个只出现一次的字符</a></td><td align="center"><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">第一个只出现一次的字符</a></td><td align="center">字符串</td></tr><tr><td align="center">36</td><td align="center"><a href="https://www.weiweiblog.cn/inversepairs/" target="_blank" rel="noopener">[剑指offer] 数组中的逆序对</a></td><td align="center"><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中的逆序对</a></td><td align="center">数组</td></tr><tr><td align="center">37</td><td align="center"><a href="https://www.weiweiblog.cn/findfirstcommonnode/" target="_blank" rel="noopener">[剑指offer] 两个链表的第一个公共结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">两个链表的第一个公共结点</a></td><td align="center">链表</td></tr><tr><td align="center">38</td><td align="center"><a href="https://www.weiweiblog.cn/getnumberofk/" target="_blank" rel="noopener">[剑指offer] 数字在排序数组中出现的次数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数字在排序数组中出现的次数</a></td><td align="center">数组</td></tr><tr><td align="center">39</td><td align="center"><a href="https://www.weiweiblog.cn/treedepth/" target="_blank" rel="noopener">[剑指offer] 二叉树的深度</a></td><td align="center"><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的深度</a></td><td align="center">树</td></tr><tr><td align="center">40</td><td align="center"><a href="https://www.weiweiblog.cn/findnumsappearonce/" target="_blank" rel="noopener">[剑指offer] 数组中只出现一次的数字</a></td><td align="center"><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中只出现一次的数字</a></td><td align="center">数组</td></tr><tr><td align="center">41</td><td align="center"><a href="https://www.weiweiblog.cn/findnumberswithsum/" target="_blank" rel="noopener">[剑指offer] 和为S的两个数字</a> VS <a href="https://www.weiweiblog.cn/findcontinuoussequence/" target="_blank" rel="noopener">[剑指offer] 和为S的连续正数序列</a></td><td align="center"><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">和为s的两个数字</a> VS <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">和为S的连续正数序列</a></td><td align="center">数值</td></tr><tr><td align="center">42</td><td align="center"><a href="https://www.weiweiblog.cn/reversesentence/" target="_blank" rel="noopener">[剑指offer] 翻转单词顺序列</a> VS <a href="https://www.weiweiblog.cn/leftrotatestring/" target="_blank" rel="noopener">[剑指offer] 左旋转字符串</a></td><td align="center"><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">翻转单词顺序</a> VS <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">左旋转字符串</a></td><td align="center">字符串</td></tr><tr><td align="center">44</td><td align="center"><a href="https://www.weiweiblog.cn/iscontinuous/" target="_blank" rel="noopener">[剑指offer] 扑克牌顺子</a></td><td align="center"><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">扑克牌的顺子</a></td><td align="center">数组</td></tr><tr><td align="center">45</td><td align="center"><a href="https://www.weiweiblog.cn/lastremaining_solution/" target="_blank" rel="noopener">[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)</a></td><td align="center"><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></td><td align="center">数组</td></tr><tr><td align="center">46</td><td align="center"><a href="https://www.weiweiblog.cn/sum_solution/" target="_blank" rel="noopener">[剑指offer] 求1+2+3+…+n</a></td><td align="center"><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">求1+2+…+n 233</a></td><td align="center">数值</td></tr><tr><td align="center">47</td><td align="center"><a href="https://www.weiweiblog.cn/add/" target="_blank" rel="noopener">[剑指offer] 不用加减乘除做加法</a></td><td align="center"><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">不用加减乘除做加法</a></td><td align="center">数值</td></tr><tr><td align="center">49</td><td align="center"><a href="https://www.weiweiblog.cn/strtoint/" target="_blank" rel="noopener">[剑指offer] 把字符串转换成整数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把字符串转换成整数</a></td><td align="center">字符串</td></tr><tr><td align="center">51</td><td align="center"><a href="https://www.weiweiblog.cn/duplicate/" target="_blank" rel="noopener">[剑指offer] 数组中重复的数字</a></td><td align="center"><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中重复的数字</a></td><td align="center">数组</td></tr><tr><td align="center">52</td><td align="center"><a href="https://www.weiweiblog.cn/multiply/" target="_blank" rel="noopener">[剑指offer] 构建乘积数组</a></td><td align="center"><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">构建乘积数组</a></td><td align="center">数组</td></tr><tr><td align="center">53</td><td align="center"><a href="https://www.weiweiblog.cn/match/" target="_blank" rel="noopener">[剑指offer] 正则表达式匹配</a></td><td align="center"><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">正则表达式匹配</a></td><td align="center">字符串</td></tr><tr><td align="center">54</td><td align="center"><a href="https://www.weiweiblog.cn/isnumeric/" target="_blank" rel="noopener">[剑指offer] 表示数值的字符串</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">表示数值的字符串</a></td><td align="center">字符串</td></tr><tr><td align="center">55</td><td align="center"><a href="https://www.weiweiblog.cn/firstappearingonce/" target="_blank" rel="noopener">[剑指offer] 字符流中第一个不重复的字符</a></td><td align="center"><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">字符流中第一个不重复的字符</a></td><td align="center">字符串</td></tr><tr><td align="center">56</td><td align="center"><a href="https://www.weiweiblog.cn/entrynodeofloop/" target="_blank" rel="noopener">[剑指offer] 链表中环的入口结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">链表中环的入口结点</a></td><td align="center">链表</td></tr><tr><td align="center">57</td><td align="center"><a href="https://www.weiweiblog.cn/deleteduplication/" target="_blank" rel="noopener">[剑指offer] 删除链表中重复的结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">删除链表中重复的结点</a></td><td align="center">链表</td></tr><tr><td align="center">58</td><td align="center"><a href="https://www.weiweiblog.cn/getnext/" target="_blank" rel="noopener">[剑指offer] 二叉树的下一个结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的下一个结点</a></td><td align="center">树</td></tr><tr><td align="center">59</td><td align="center"><a href="https://www.weiweiblog.cn/issymmetrical/" target="_blank" rel="noopener">[剑指offer] 对称的二叉树</a></td><td align="center"><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">对称的二叉树</a></td><td align="center">树</td></tr><tr><td align="center">60</td><td align="center"><a href="https://www.weiweiblog.cn/printz/" target="_blank" rel="noopener">[剑指offer] 按之字形顺序打印二叉树</a></td><td align="center"><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></td><td align="center">树</td></tr><tr><td align="center">61</td><td align="center"><a href="https://www.weiweiblog.cn/print/" target="_blank" rel="noopener">[剑指offer] 把二叉树打印成多行</a></td><td align="center"><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把二叉树打印成多行</a></td><td align="center">树</td></tr><tr><td align="center">62</td><td align="center"><a href="https://www.weiweiblog.cn/serialize/" target="_blank" rel="noopener">[剑指offer] 序列化二叉树</a></td><td align="center"><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">序列化二叉树</a></td><td align="center">树</td></tr><tr><td align="center">63</td><td align="center"><a href="https://www.weiweiblog.cn/kthnode/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树的第k个结点</a></td><td align="center"><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树的第k个结点</a></td><td align="center">树</td></tr><tr><td align="center">64</td><td align="center"><a href="https://www.weiweiblog.cn/getmedian/" target="_blank" rel="noopener">[剑指offer] 数据流中的中位数</a></td><td align="center"><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数据流中的中位数</a></td><td align="center">数值</td></tr><tr><td align="center">65</td><td align="center"><a href="https://www.weiweiblog.cn/maxinwindows/" target="_blank" rel="noopener">[剑指offer] 滑动窗口的最大值</a></td><td align="center"><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">滑动窗口的最大值</a></td><td align="center">数组</td></tr><tr><td align="center">66</td><td align="center"><a href="https://www.weiweiblog.cn/haspath/" target="_blank" rel="noopener">[剑指offer] 矩阵中的路径</a></td><td align="center"><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">矩阵中的路径</a></td><td align="center">数组</td></tr><tr><td align="center">67</td><td align="center"><a href="https://www.weiweiblog.cn/movingcount/" target="_blank" rel="noopener">[剑指offer] 机器人的运动范围</a></td><td align="center"><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">机器人的运动范围</a></td><td align="center">数组</td></tr></tbody></table><h3 id="Array-数组题目汇总-18题"><a href="#Array-数组题目汇总-18题" class="headerlink" title="Array 数组题目汇总[18题]"></a>Array 数组题目汇总[18题]</h3><ul><li><a href="https://weiweiblog.cn/find2array/">[剑指offer] 二维数组中的查找</a></li><li><a href="https://weiweiblog.cn/minnumberinrotatearray/">[剑指offer] 旋转数组的最小数字</a></li><li><a href="https://weiweiblog.cn/reorderarray/">[剑指offer] 调整数组顺序使奇数位于偶数前面</a></li><li><a href="https://weiweiblog.cn/printmatrix/">[剑指offer] 顺时针打印矩阵</a></li><li><a href="https://weiweiblog.cn/morethanhalfnum_solution/">[剑指offer] 数组中出现次数超过一半的数字</a></li><li><a href="https://weiweiblog.cn/getleastnumbers_solution/">[剑指offer] 最小的K个数</a></li><li><a href="https://weiweiblog.cn/findgreatestsumofsubarray/">[剑指offer] 连续子数组的最大和</a></li><li><a href="https://weiweiblog.cn/jzoffer_java/">[剑指offer] 把数组排成最小的数</a></li><li><a href="https://weiweiblog.cn/inversepairs/">[剑指offer] 数组中的逆序对</a></li><li><a href="https://weiweiblog.cn/getnumberofk/">[剑指offer] 数字在排序数组中出现的次数</a></li><li><a href="https://weiweiblog.cn/findnumsappearonce/">[剑指offer] 数组中只出现一次的数字</a></li><li><a href="https://weiweiblog.cn/iscontinuous/">[剑指offer] 扑克牌顺子</a></li><li><a href="https://weiweiblog.cn/lastremaining_solution/">[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)</a></li><li><a href="https://weiweiblog.cn/duplicate/">[剑指offer] 数组中重复的数字</a></li><li><a href="https://weiweiblog.cn/multiply/">[剑指offer] 构建乘积数组</a></li><li><a href="https://weiweiblog.cn/maxinwindows/">[剑指offer] 滑动窗口的最大值</a></li><li><a href="https://weiweiblog.cn/haspath/">[剑指offer] 矩阵中的路径</a></li><li><a href="https://weiweiblog.cn/movingcount/">[剑指offer] 机器人的运动范围</a></li></ul><h3 id="链表题目汇总-8题"><a href="#链表题目汇总-8题" class="headerlink" title="链表题目汇总[8题]"></a>链表题目汇总[8题]</h3><ul><li><a href="https://weiweiblog.cn/printlistfromtailtohead/">[剑指offer] 从尾到头打印链表</a></li><li><a href="https://weiweiblog.cn/reverselist/">[剑指offer] 反转链表</a></li><li><a href="https://weiweiblog.cn/findkthtotail/">[剑指offer] 链表中倒数第k个结点</a></li><li><a href="https://weiweiblog.cn/mergelinklist/">[剑指offer] 合并两个排序的链表</a></li><li><a href="https://weiweiblog.cn/clonelink/">[剑指offer] 复杂链表的复制</a></li><li><a href="https://weiweiblog.cn/deleteduplication/">[剑指offer] 删除链表中重复的结点</a></li><li><a href="https://weiweiblog.cn/entrynodeofloop/">[剑指offer] 链表中环的入口结点</a></li><li><a href="https://weiweiblog.cn/findfirstcommonnode/">[剑指offer] 两个链表的第一个公共结点</a></li></ul><blockquote><p>更多关于链表面试题的总结，请移步<a href="https://weiweiblog.cn/linkedlist_summary/">[算法总结] 一文搞懂面试链表题</a> </p></blockquote><h3 id="二叉树题目汇总-13题"><a href="#二叉树题目汇总-13题" class="headerlink" title="二叉树题目汇总[13题]"></a>二叉树题目汇总[13题]</h3><ul><li><a href="https://weiweiblog.cn/reconstructbinarytree/">[剑指offer] 重建二叉树</a></li><li><a href="https://weiweiblog.cn/issubtree/">[剑指offer] 树的子结构</a></li><li><a href="https://weiweiblog.cn/mirrortree/">[剑指offer] 二叉树的镜像</a></li><li><a href="https://weiweiblog.cn/printfromtoptobottom/">[剑指offer] 从上往下打印二叉树</a></li><li><a href="https://weiweiblog.cn/verifysquenceofbst/">[剑指offer] 二叉搜索树的后序遍历序列</a></li><li><a href="https://weiweiblog.cn/findpath/">[剑指offer] 二叉树中和为某一值的路径</a></li><li><a href="https://weiweiblog.cn/treedepth/">[剑指offer] 二叉树的深度</a></li><li><a href="https://weiweiblog.cn/getnext/">[剑指offer] 二叉树的下一个结点</a></li><li><a href="https://weiweiblog.cn/issymmetrical/">[剑指offer] 对称的二叉树</a></li><li><a href="https://weiweiblog.cn/printz/">[剑指offer] 按之字形顺序打印二叉树</a></li><li><a href="https://weiweiblog.cn/print/">[剑指offer] 把二叉树打印成多行</a></li><li><a href="https://weiweiblog.cn/serialize/">[剑指offer] 序列化二叉树</a></li><li><a href="https://weiweiblog.cn/kthnode/">[剑指offer] 二叉搜索树的第k个结点</a></li></ul><blockquote><p>更多关于二叉树面试题的总结，请移步 <a href="https://www.weiweiblog.cn/20tree/" target="_blank" rel="noopener">[算法总结] 20 道题搞定 BAT 面试——二叉树</a> </p></blockquote><h3 id="堆栈和队列题目汇总-3题"><a href="#堆栈和队列题目汇总-3题" class="headerlink" title="堆栈和队列题目汇总[3题]"></a>堆栈和队列题目汇总[3题]</h3><ul><li><a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">[剑指offer] 用两个栈实现队列</a></li><li><a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">[剑指offer] 包含min函数的栈</a></li><li><a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">[剑指offer] 栈的压入、弹出序列</a></li></ul><blockquote><p>更多关于堆栈和队列面试题的总结，请移步 <a href="https://www.weiweiblog.cn/stack_and_queue/" target="_blank" rel="noopener">[算法总结] 6 道题搞定 BAT 面试——堆栈和队列</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;序号&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;题解&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;牛客 OJ&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;数据结构类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;03&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/find2array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二维数组中的查找&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二维数组中的查找&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;04&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/replacespace/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 替换空格&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;替换空格&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;05&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/printlistfromtailtohead/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 从尾到头打印链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从尾到头打印链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;06&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/reconstructbinarytree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 重建二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重建二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;07&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/stacktoqueue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 用两个栈实现队列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用两个栈实现队列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;栈、队列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;08&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/minnumberinrotatearray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 旋转数组的最小数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;旋转数组的最小数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;09&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/fibonacci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 斐波那契数列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斐波那契数列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/numberof1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二进制中1的个数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二进制中1的个数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/power/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数值的整数次方&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数值的整数次方&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;14&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/reorderarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 调整数组顺序使奇数位于偶数前面&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整数组顺序使奇数位于偶数前面&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;15&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findkthtotail/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 链表中倒数第k个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链表中倒数第k个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;16&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/reverselist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 反转链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反转链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;17&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/mergelinklist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 合并两个排序的链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个排序的链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;18&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/issubtree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 树的子结构&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树的子结构&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;19&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/mirrortree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉树的镜像&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的镜像&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;20&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/printmatrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 顺时针打印矩阵&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;顺时针打印矩阵&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/minstack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 包含min函数的栈&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;包含min函数的栈&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/ispoporder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 栈的压入、弹出序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;栈的压入、弹出序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;23&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/printfromtoptobottom/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 从上往下打印二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从上往下打印二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/verifysquenceofbst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉搜索树的后序遍历序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树的后序遍历序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findpath/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉树中和为某一值的路径&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树中和为某一值的路径&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;26&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/clonelink/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 复杂链表的复制&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;复杂链表的复制&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;27&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/converttree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉搜索树与双向链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树与双向链表&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树、链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;28&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 字符串的排列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字符串的排列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;29&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/morethanhalfnum_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数组中出现次数超过一半的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中出现次数超过一半的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;30&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/getleastnumbers_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 最小的K个数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最小的k个数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;31&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findgreatestsumofsubarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 连续子数组的最大和&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;连续子数组的最大和&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;32&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/numberof1between1andn_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 整数中1出现的次数（从1到n整数中1出现的次数）&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从1到n整数中1出现的次数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;33&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/printminnumber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 把数组排成最小的数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;把数组排成最小的数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;34&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/getuglynumber_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 丑数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;丑数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;35&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/firstnotrepeatingchar/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 第一个只出现一次的字符&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一个只出现一次的字符&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;36&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/inversepairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数组中的逆序对&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中的逆序对&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;37&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findfirstcommonnode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 两个链表的第一个公共结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个链表的第一个公共结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;38&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/getnumberofk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数字在排序数组中出现的次数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数字在排序数组中出现的次数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;39&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/treedepth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉树的深度&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的深度&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;40&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findnumsappearonce/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数组中只出现一次的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中只出现一次的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;41&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/findnumberswithsum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 和为S的两个数字&lt;/a&gt; VS &lt;a href=&quot;https://www.weiweiblog.cn/findcontinuoussequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 和为S的连续正数序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;和为s的两个数字&lt;/a&gt; VS &lt;a href=&quot;https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;和为S的连续正数序列&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;42&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/reversesentence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 翻转单词顺序列&lt;/a&gt; VS &lt;a href=&quot;https://www.weiweiblog.cn/leftrotatestring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 左旋转字符串&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;翻转单词顺序&lt;/a&gt; VS &lt;a href=&quot;https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;左旋转字符串&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;44&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/iscontinuous/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 扑克牌顺子&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;扑克牌的顺子&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;45&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/lastremaining_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;圆圈中最后剩下的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;46&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/sum_solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 求1+2+3+…+n&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求1+2+…+n 233&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;47&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/add/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 不用加减乘除做加法&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不用加减乘除做加法&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;49&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/strtoint/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 把字符串转换成整数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;把字符串转换成整数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;51&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/duplicate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数组中重复的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组中重复的数字&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;52&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/multiply/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 构建乘积数组&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;构建乘积数组&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;53&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/match/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 正则表达式匹配&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则表达式匹配&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;54&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/isnumeric/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 表示数值的字符串&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;表示数值的字符串&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;55&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/firstappearingonce/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 字符流中第一个不重复的字符&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字符流中第一个不重复的字符&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;56&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/entrynodeofloop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 链表中环的入口结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链表中环的入口结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;57&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/deleteduplication/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 删除链表中重复的结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;删除链表中重复的结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;链表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;58&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/getnext/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉树的下一个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的下一个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;59&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/issymmetrical/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 对称的二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对称的二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;60&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/printz/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 按之字形顺序打印二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;按之字形顺序打印二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;61&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/print/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 把二叉树打印成多行&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;把二叉树打印成多行&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;62&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/serialize/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 序列化二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;序列化二叉树&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;63&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/kthnode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 二叉搜索树的第k个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树的第k个结点&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;树&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;64&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/getmedian/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 数据流中的中位数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据流中的中位数&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;65&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/maxinwindows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 滑动窗口的最大值&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;滑动窗口的最大值&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;66&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/haspath/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 矩阵中的路径&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;矩阵中的路径&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;67&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.weiweiblog.cn/movingcount/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[剑指offer] 机器人的运动范围&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=4&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;机器人的运动范围&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="算法&amp;amp;数据结构" scheme="https://weiweiblog.cn/categories/%E7%AE%97%E6%B3%95-amp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="https://weiweiblog.cn/tags/java/"/>
    
      <category term="剑指offer" scheme="https://weiweiblog.cn/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="题解" scheme="https://weiweiblog.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
