<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【李宏毅-机器学习】RNN的梯度消失和梯度爆炸及其解决方案</title>
    <url>/ML_lecture21-2_RNN/</url>
    <content><![CDATA[<p>RNN在使用过程中会出现两种问题，一种是梯度消失，一种是梯度爆炸。</p>
<p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505133932.png" alt=""></p>
<p>有一个方法可以直观地知道一个gradient的大小是什么样的：<br>我们把某一个参数做小小的变化，看它对网络输出的变化有多大，你就可以测出这个参数的gradient的大小。</p>
<p>如上图，假设w是我们要学习的参数，我们想要知道当改变w值的时候对网络的输出有多大的影响。假设w=1,y的1000次方等于1，假设w=1.01，y的1000次方约等于20000，所以w有很大的gradient，这就会导致梯度爆炸；而如果让w=0.99，这时候y的1000次方约等于0，w的gradient就很小，导致梯度消失。</p>
<p>当出现梯度爆炸的时候，梯度值会变成NaN，导致程序崩溃，所以梯度爆炸容易发现。对于梯度爆炸的问题可以通过梯度裁剪来缓解，即当梯度的范式大于某个给定值时，对梯度进行等比收缩。</p>
<p>而梯度消失问题相对比较棘手，它不会像梯度爆炸那样明显被发现，同时也比较不好处理。LSTM或者GRU等模型通过加入门控机制，很大程度上弥补了梯度消失所带来的损失。</p>
<p>在RNN中，在每个时间点，memory里面的信息都会被覆盖掉，但是在LSTM里面，它是把原来memory里面的值乘上一个值再把input的值加起来放到cell里面去，所以它的memory和input是相加的。在LSTM中，如果w可以影响到memory里面的值话，一旦发生影响，这个影响会永远都存在（除非forget门开启），不像RNN在每个时间的值都会被覆盖掉。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>RNN</tag>
        <tag>LSTM</tag>
        <tag>gradient</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Action自动部署Hexo到Gihub和Coding</title>
    <url>/github_action/</url>
    <content><![CDATA[<p>本文主要介绍我这个小站的持续集成方案（Continuous integration，简称CI）。什么是持续集成呢，简单说，就是把我写完文章后，markdown源代码的提交、Hexo静态网页的生成、Hexo网页的发布这一整个流程使用自动化的工具串起来，通过一个命令来触发这一系列的动作，从而使用户专注于写作，不用管后续一堆的事情。</p>
<p>以前用过Travis CI将Hugo自动部署到服务器上，而这次我选择当下比较火的Github Action，不为别的，代码都托管在Github上了，亲儿子Action不用应该是脑袋有坑了。</p>
<p>我的方案是<code>Github Action</code> + <code>Github</code> + <code>Coding</code>。就是通过Github Action把网页自动部署在Github和Coding上。这个方案其实网络上早就有挺多人实现的了，但是试了一圈，一直卡在自动部署到Coding上，最后才发现Coding最近改版了，原来的方案都不能拿来直接就用，需要稍微改下域名才可以。</p>
<h3 id="基本流程如下："><a href="#基本流程如下：" class="headerlink" title="基本流程如下："></a>基本流程如下：</h3><ol>
<li>创建密钥</li>
<li>创建Github源代码仓库（私有），并上传私钥</li>
<li>创建Github静态网页仓库（开启GitPage）,并上传公钥</li>
<li>创建Coding静态网页仓库，开上传私钥</li>
<li>在Github源代码仓库中编写Github Action代码，完成自动部署</li>
</ol>
<h3 id="1-创建密钥"><a href="#1-创建密钥" class="headerlink" title="1. 创建密钥"></a>1. 创建密钥</h3><p>在命令行窗口中输入下面一行（其中<a href="mailto:your_email@example.com">your_email@example.com</a>换成你的邮箱）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</span><br></pre></td></tr></table></figure>

<p>然后一直回车就会在你的<code>~/.ssh/</code>目录下生成<code>id_rsa.pub</code>公钥和<code>id_rsa</code>私钥两个文件，这两个文件的内容待会要复制到git仓库中作为通关密码。</p>
<h3 id="2-创建Github源代码仓库"><a href="#2-创建Github源代码仓库" class="headerlink" title="2. 创建Github源代码仓库"></a>2. 创建Github源代码仓库</h3><p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505225127.png" alt=""><br>在Github上创建一个私有仓库，注意选择<code>Private</code>，然后将Hexo整个项目的代码上传上到该仓库下：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505225412.png" alt=""></p>
<blockquote>
<p>注意: 上传的时候可能会遇到报错，原因是theme下的next模板中也是一个git项目，简单粗暴的解决方案就是把next文件夹中的.git文件都删除了，但是这样做也有个坏处，就是当next官方发布更新时，你就无法直接拉取更新了</p>
</blockquote>
<p>创建好了源代码仓库后，就可以设置私钥：在<code>Settings</code>-&gt;<code>Secrets</code>中选择<code>Add a new secret</code>:<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505230131.png" alt=""></p>
<p>然后填写<code>Name</code>和<code>Value</code>，其中Name可以自己设定（后面编写自动部署的代码时会用到），比如我设为<code>ACTION_DEPLOY_KEY</code>，而Value就是你刚才生成的密钥了，你可以在命令行窗口运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>就可以得到如下的输出<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505230523.png" alt=""><br>将输出的内容全部（包括<code>-----BEGIN OPENSSH PRIVATE KEY-----</code>和<code>-----END OPENSSH PRIVATE KEY-----</code>）复制到Value输入框中即可。</p>
<h3 id="3-创建Github静态网页仓库"><a href="#3-创建Github静态网页仓库" class="headerlink" title="3. 创建Github静态网页仓库"></a>3. 创建Github静态网页仓库</h3><p>在Github上创建另一个仓库，用于存放静态网页文件，并开启GitPage的功能。</p>
<p>创建的步骤就不用多说了，创建一个公开的仓库即可，然后把源代码的public文件中的内容上传到静态网页仓库。接着上传公钥，在<code>Settings</code>-&gt;<code>Deploy keys</code>中选择<code>Add deploy key</code>:</p>
<p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231415.png" alt=""><br>其中<code>Title</code>可以随便取名，<code>key</code>的内容来源于第一步设置的公钥，在命令行窗口中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231638.png" alt=""><br>然后将输出的内容复制到key中即可。</p>
<p>同时，不要忘记开启GitHub Pages的功能，在<code>Settings</code>-&gt;<code>Options</code>中，往下拉找到GitHub Pages并启用它，如果你用自己的域名，还可以顺带设置Custom domain：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505231945.png" alt=""></p>
<h3 id="4-创建Coding静态网页仓库"><a href="#4-创建Coding静态网页仓库" class="headerlink" title="4. 创建Coding静态网页仓库"></a>4. 创建Coding静态网页仓库</h3><p>在Coding中创建一个项目，选择<code>DevOps项目</code><br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232217.png" alt=""><br>填写项目名称、项目地址等信息后，把静态网页的代码也上传到该仓库中<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232407.png" alt=""><br>然后在<code>代码仓库</code>的<code>设置</code>栏目中设置<code>部署公钥</code>，公钥名称可自定义，公钥内容内同第3步。<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232541.png" alt=""></p>
<p>之后在<code>持续部署</code>的<code>静态网站</code>中新建静态网站：<br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505232838.png" alt=""></p>
<h3 id="5-在Github源代码仓库中编写Github-Action代码"><a href="#5-在Github源代码仓库中编写Github-Action代码" class="headerlink" title="5. 在Github源代码仓库中编写Github Action代码"></a>5. 在Github源代码仓库中编写Github Action代码</h3><p>在Github源代码仓库的<code>Action</code>页面中<code>New workflow</code>，然后选择<code>set up a workflow yourself</code><br><img src="https://cdn.weiweiblog.cn/weiweiblog/20200505233228.png" alt=""><br>接着在代码编辑框中输入自动部署的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: macOS-latest  # 配置代码运行操作系统环境</span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions&#x2F;checkout@v1</span><br><span class="line">    - name: Use Node.js 12.x # 配置Node环境</span><br><span class="line">      uses: actions&#x2F;setup-node@v1 </span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;12.16.1&quot;</span><br><span class="line">    - name: Setup Hexo env  # 配置Hexo环境</span><br><span class="line">      env:</span><br><span class="line">        ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125;  # ACTION_DEPLOY_KEY在第2步中设置</span><br><span class="line">      run: |</span><br><span class="line">        # set up private key for deploy</span><br><span class="line">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">        echo &quot;$ACTION_DEPLOY_KEY&quot; | tr -d &#39;\r&#39; &gt; ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class="line">        ssh-keyscan e.coding.net &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts  # 注意，Coding的地址已经改成e.coding.net，很多教程中使用的地址都是旧的，导致无法完成部署</span><br><span class="line">        git config --global user.name &#39;wwwxmu&#39;  # 这里要将wwwxmu改为你的github和Coding的用户名（注意github和Coding的用户名必须相同）</span><br><span class="line">        git config --global user.email &#39;www@stu.xmu.edu.cn&#39; # 这里要将www@stu.xmu.edu.cn改为你的邮箱</span><br><span class="line">        npm i -g hexo-cli</span><br><span class="line">        npm i</span><br><span class="line">    - name: Deploy</span><br><span class="line">      run: |</span><br><span class="line">        # publish</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">        hexo deploy # 执行部署程序</span><br></pre></td></tr></table></figure>

<p>至此，所有设置都已经完成。接下来，你只要安心写作。写完之后，在源代码的根目录下依次运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m'修改哪些内容'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这样，新的文章会自动推到github的源代码仓库，同时触发Github Action，将其发布到Github Page和Coding中。</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Github Action</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>博客更新【2020-03-26】</title>
    <url>/new_blog/</url>
    <content><![CDATA[<p>2019年9月，阿里云的学生优惠到期了，当时想着等双十一做活动的时候再买个服务器，给小站续命。奈何双十一的时候，这些大厂太不给力了，针对老用户的服务器动辄就要500+，真的是下不了手，于是乎小站就无限期下线。</p>
<p>今年疫情期间，稍微有点时间，于是想着稍微整理一下，把小站重新上线。</p>
<p>由于之间的网站是用Wordpress搭的，wordpress这个开源的工具搭起来很简单，但是它太重了，一个小小的网站，还需要php环境和mysql数据库，为此就得买一台服务器。本着节省的理念，这次就打算通过免费的方案来上线小站。</p>
<p>既然想要免费，那就不可能再去买台服务器了，那么Github Pages的服务就是首选了。Github Pages可以免费发静态网页，我们用Markdown写作，然后使用一些开源的工具将其转换成静态网页，最到上传到Github上，整个流程操作起来很顺手，重点是<code>免费</code>。</p>
<p>说到静态网站生成器，那好东西真的不要太多，随便一抓就是一大把，像是<code>Hexo</code>，<code>Hugo</code>，<code>Pelican</code>等等。一开始，我是比例倾向于选择<code>Pelican</code>的，就因为它是Python开发的，毕竟：</p>
<blockquote class="blockquote-center">
            <p>人生苦短，我用Python</p>

          </blockquote>

<p>Python这么火，我怎么能弃它而不用呢？于是我就开始选主题了，但是把Github上的Pelican主题看了一遍，真的是太丑了。作为一个这么看重颜值的人，怎么能忍，于是就想着从其它地方的主题挑一个来改造迁移。最后选了hexo的next，然后看了Jinja2的语法就开始干，写着写着发现真TM太难了，没什么前端技能树的我只好半途放弃。。。</p>
<p>排除Pelican后，我最看好Hexo和Hugo，对比了一下，大家都在说Hexo很慢，Hugo超快。于是就打算使用Hugo了，然后又开始挑主题，Hugo的主题相对于Pelican真的是好很多了，但是看了一圈还是没有能让我很满意的。</p>
<p>最后，我把目光锁定在了Hexo，然后选重了<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a>这个Github上有<code>5.3k</code>start的主题，更新还很频繁。经过一翻折腾，跟着说明文档进行配置，对几个不是很满意的地方通过代码硬改，终于有了你现在看到的这个小站。</p>
<p>啰嗦了一堆，就当记流水账了，后面会把配置过程中踩过的一些坑记录一下，让大家在部署的过程中可以节约点时间。</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Facebook 推出PyTorch Hub，使模型的复现不再困难</title>
    <url>/pytorchhub/</url>
    <content><![CDATA[<p>可复现性是机器学习研究的重要组成部分，它能够验证所提出的模型是否达到了承诺的性能。当研究人员提交新论文时，他们通常会在GitHub上开源其预训练模型的代码和参数，以便其他人了解他们是否能够实现已发布的实验结果。然而，在加载模型以进行复现测试时涉及许多耗时的步骤。</p>
<p>为了提供更流畅的复制体验，Facebook宣布推出PyTorch Hub，这是一个新的预训练模型库，旨在促进模型的可复现性。由于其无与伦比的灵活性和强大功能，PyTorch是最受青睐的机器学习框架之一。 Facebook在上个月的F8开发者大会上发布了PyTorch v1.1，其中包括TensorBoard和JIT编译器等主要功能。</p>
<p>PyTorch Hub允许用户通过发送拉取请求来发布模型，并仅使用一行代码加载模型。以下是PyTorch Hub的主要功能的具体描述：</p>
<ol>
<li>发布模型：PyTorch Hub支持通过添加一个简单的hubconf.py文件将预训练模型（模型定义和预训练权重）发布到GitHub存储库，该文件提供运行模型所需的受支持模型和依赖项列表。</li>
</ol>
<p>在研究人员发送拉取请求后，Facebook PyTorch团队将帮助完善他们的拉取请求并决定是否接受它。接受的发布模型最终会出现在PyTorch Hub网页上。</p>
<ol start="2">
  <li>
    加载模型：用户可以使用torch.hub.load（）API加载预先训练的模型。下面是从pytorch / vision repo加载resnet18入口点的代码。
  </li>
</ol>

<p>model = torch.hub.load（&#8217;pytorch / vision&#8217;，&#8217;resnet18&#8217;，pretrained = True）</p>
<p>PyTorch Hub目前可容纳18种备受瞩目的机器学习模型，包括谷歌的BERT，由Hugging Face重新实现，以及由Facebook AI Research推出的PGANs。用户还可以在Colab和Papers With Code上查看这些和其他模型。 Facebook表示，PyTorch Hub将很快为开发人员提供即插即用型号，以进一步加速机器学习模型的可重复性测试和开发。</p>
<p>有关PyTorch Hub项目页面的更多信息。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>开源的Rufus，史上最好用的系统盘制作工具</title>
    <url>/rufus/</url>
    <content><![CDATA[<p>好像没有重装系统了，以前重装的时候都是使用windows提供的 USB/DVD Download Tool，这个工具是挺方法便的，安装上就可以用，但是win10安装这个工具就比较蛋疼，还要先安装.net framework2.0。于是我就寻思有没有更方便的系统盘刻录工具，还真让我找着了。</p>
<p>Rufus 是一个可以帮助格式化和创建可引导USB闪存盘的工具，比如 USB 随身碟，记忆棒等等。</p>
<p>在如下场景中会非常有用：</p>
<ul>
<li>你需要把一些可引导的ISO格式的镜像（Windows，Linux，UEFI等）创建成USB安装盘的时候</li>
<li>你需要使用一个还没有安装操作系统的设备的时候</li>
<li>你需要从DOS系统刷写BIOS或者其他固件的时候</li>
<li>你需要运行一个非常底层的工具的时候</li>
</ul>
<p>Rufus 麻雀虽小，五脏俱全，体积虽小，功能全面。</p>
<p>我选择Rufus，主要有两个原因</p>
<p>一、它不需要安装，拆箱即用。</p>
<p>二、它的速度还很快，飞一般的感觉。</p>
<p>Rufus刻录系统u盘的步骤很简单，</p>
<p><img src="https://cdn.weiweiblog.cn/20190607144800.png" alt=""></p>
<p>插上u盘，打开Rufus后，它会自动选中你的u盘，然后选择要事先下载好的系统，最后，也是最重要的一步，要选择分区类型和目标系统类型。这需要根据你的电脑的启动方案来选，如果是比较旧的电脑，一般选择MBR就可以，如果比较新的电脑，就选GPT。</p>
<p>关于MBR和GPT有什么区别，MBR只能支持4个主分区，而GPT则本身无限制，MBR不支持2TB以上的硬盘，GPT则最多支持到18EB。GPT是一种新的标准，会逐渐取代MBR。具体的差别可以自行Google了解。</p>
<p>选完之后点开始就可即刻录了，等待进度条跑完就可以拔出u盘，开始愉快地重装了。</p>
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
  </entry>
  <entry>
    <title>互联网校招面试必备——计算机网络</title>
    <url>/network/</url>
    <content><![CDATA[<h4 id="OSI，TCP-IP，五层协议的体系结构"><a href="#OSI，TCP-IP，五层协议的体系结构" class="headerlink" title="OSI，TCP/IP，五层协议的体系结构"></a>OSI，TCP/IP，五层协议的体系结构</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvinzmukkaj30ib08tq4b.jpg" alt=""></p>
<h4 id="每一层的作用："><a href="#每一层的作用：" class="headerlink" title="每一层的作用："></a>每一层的作用：</h4><ul>
<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包Packet）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
<h4 id="每一层的协议："><a href="#每一层的协议：" class="headerlink" title="每一层的协议："></a>每一层的协议：</h4><ul>
<li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li>
<li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li>
<li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li>
<li>传输层：TCP、UDP、SPX</li>
<li>会话层：NFS、SQL、NETBIOS、RPC</li>
<li>表示层：JPEG、MPEG、ASII</li>
<li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li>
</ul>
<h4 id="TCP对应的应用层协议"><a href="#TCP对应的应用层协议" class="headerlink" title="TCP对应的应用层协议"></a>TCP对应的应用层协议</h4><ul>
<li>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
<li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li>
<li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li>
<li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li>
<li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<h4 id="UDP对应的应用层协议"><a href="#UDP对应的应用层协议" class="headerlink" title="UDP对应的应用层协议"></a>UDP对应的应用层协议</h4><ul>
<li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li>
<li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
</ul>
<h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p><img src="https://cdn.weiweiblog.cn/20180924164212.png" alt=""></p>
<ul>
<li>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 &#8211; 126.255.255.255）；</li>
<li>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 &#8211; 191.255.255.255）；</li>
<li>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 &#8211; 223.255.255.255）；</li>
</ul>
<p>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>ARP地址解析协议，简单说就是，在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。它的工作原理如下：</p>
<ol>
<li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p>
</li>
<li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p>
</li>
<li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p>
</li>
<li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
</li>
<li><p>如果目标IP与自己不在同一个网段，这种情况需要将包发给默认网关，所以主要获取网关的MAC地址。如果arp高速缓存有默认网关的MAC地址，直接发送IP数据报道默认网关，再由网关转发到外网；如果arp高速缓存没有默认网关的MAC地址，还是发送ARP广播请求默认网关的MAC地址，缓存该地址，并且发送数据报到网关。</p>
</li>
</ol>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下：</p>
<ul>
<li>支持客户/服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
<h4 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h4><p><img src="https://cdn.weiweiblog.cn/20180924163958.png" alt=""></p>
<p><strong>三次握手：</strong>(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)</p>
<ul>
<li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><strong>四次挥手：</strong>(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：</p>
<ul>
<li>第一次挥手：客户端主动关闭方发送一个FIN，用来关闭客户端到服务端的数据传送，也就是客户端告诉服务端：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。</li>
<li>第二次挥手：服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li>
<li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。</li>
<li>第四次挥手：客户端收到FIN后，发送一个ACK给服务端，确认序号为收到序号+1，至此，完成四次挥手。</li>
</ul>
<h3 id="第3次握手失败会怎么办"><a href="#第3次握手失败会怎么办" class="headerlink" title="第3次握手失败会怎么办?"></a>第3次握手失败会怎么办?</h3><p>第三次失败，只有客户端处于成功状态（因为第2次服务器返回了ACK），服务器端没有接收到客户端的 ACK。</p>
<p>这要分几种情况讨论：</p>
<ul>
<li>In other words, if the ACK is dropped but the next packet is not dropped, then everything is fine. 也就是说客户端发出的 ACK 丢失了，发出的 下一个数据包 没有丢失，则服务端接收到下一个数据包（这个数据包里也会带上 ACK 信息），能够进入正常的 ESTABLISHED 状态</li>
<li>如果服务端和客户端都没有数据发送，或者服务端想发送数据（但是发不了，因为没有收到客户端的 ACK），服务器都会有定时器发送第二步SYN+ACK数据包，如果客户端再次发送ACK成功，建立连接。</li>
<li>如果一直不成功，服务器肯定会有超时设置，超时之后会给客户端发RTS报文，进入CLOSED状态，防止SYN洪泛攻击。</li>
</ul>
<h4 id="为什么TCP链接需要三次握手，两次不可以么，为什么？"><a href="#为什么TCP链接需要三次握手，两次不可以么，为什么？" class="headerlink" title="为什么TCP链接需要三次握手，两次不可以么，为什么？"></a>为什么TCP链接需要三次握手，两次不可以么，为什么？</h4><p>为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p>
<p>客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>
<h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手?"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手?</h4><p>TCP是全双工模式，关闭连接时，当主机B收到主机A的FIN报文时，仅仅表示主机 A不再发送数据了但是还能接收数据。此时，主机B也未必全部数据都发送给A了，所以B可以立即close；也可以发送一些数据给A后，再发送FIN报文给对方来表示同意现在关闭连接，因此，主机BACK和FIN一般都会分开发送。</p>
<h4 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h4><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p>
<ul>
<li><p>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>
</li>
<li><p>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924232335.png" alt=""></p> </p>
</li>
<li><p>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924232545.png" alt=""></p>
</li>
<li><p>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924232756.png" alt=""></p>
</li>
</ul>
<h4 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h4><p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p>
<p>对于可靠性，TCP通过以下方式进行保证：</p>
<ul>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ul>
<h4 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h4><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h4 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h4><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>
<p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
<p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
<p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
<p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
<h4 id="交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？"><a href="#交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？" class="headerlink" title="交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？"></a>交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？</h4><p>交换机用于局域网，利用主机的MAC地址进行数据传输，而不需要关心IP数据包中的IP地址，它工作于数据链路层。路由器识别网络是通过IP数据包中IP地址的网络号进行的，所以为了保证数据包路由的正确性，每个网络都必须有一个唯一的网络号。路由器通过IP数据包的IP地址进行路由的（将数据包递交给哪个下一跳路由器）。路由器工作于网络层。由于设备现在的发展，现在很多设备既具有交换又具有路由功能，两者的界限越来越模糊。</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li><p>TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
</li>
<li><p>UDP的优点：快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……</p>
<p>有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接</td>
<td align="center">面向连接</td>
<td align="center">面向无连接</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">可靠，无差错，不丢失，不重复</td>
<td align="center">尽最大努力交付，即不保证可靠交付</td>
</tr>
<tr>
<td align="center">模式</td>
<td align="center">流模式（字节流）</td>
<td align="center">数据报模式（报文）</td>
</tr>
<tr>
<td align="center">连接</td>
<td align="center">点到点</td>
<td align="center">支持一对一，一对多，多对一和多对多的交互通信</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">20字节</td>
<td align="center">8个字节</td>
</tr>
<tr>
<td align="center">逻辑通信信道</td>
<td align="center">全双工的可靠信道</td>
<td align="center">不可靠信道</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">对系统资源要求</td>
<td align="center">较多</td>
<td align="center">较少</td>
</tr>
</tbody></table>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fv3g1mp6aej30lb0a7dgw.jpg" alt=""></p>
<ul>
<li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li>
<li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li>
</ul>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h4 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h4><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
<p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>
<p>开销：Https通信需要证书，而证书一般需要向认证机构购买；</p>
<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<h4 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h4><p>由于公有密钥的机制相对复杂，导致其处理速度相对较慢。于是HTTPS利用了两者的优势，采用了混合加密的机制。我们知道，共享（对称）密钥未能解决的问题是如何能够安全地把密钥发送给对方。只要解决了这个问题就可以进行安全地通信。于是，HTTPS首先是通过公有密钥来对共享密钥进行加密传输。当共享密钥安全地传输给对方后，双方则使用共享密钥的方式来加密报文，以此来提高传输的效率。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fv3g11oy5nj30h80evdh9.jpg" alt=""></p>
<p>步骤1：向服务器发起请求。</p>
<p>步骤2-3：取出公有密钥及证书并发送给客户端。</p>
<p>步骤4：客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。</p>
<p>步骤5：用步骤3得到的公有密钥对该随机数串加密，发送到服务器。</p>
<p>步骤6：服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。</p>
<p>步骤7-8：服务器对响应进行加密，客户端对报文进行解密。</p>
<h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p>
<p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p>
<p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
<p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
<p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>socket是通信的基石。支持TCP/IP等协议的基本操作单元。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.nowcoder.com/discuss/1937" target="_blank" rel="noopener">计算机网络之面试常考</a></p>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">面试/笔试第一弹 —— 计算机网络面试问题集锦</a></p>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>图床折腾记</title>
    <url>/tuchuang/</url>
    <content><![CDATA[<blockquote>
<p>本文比较杂碎，全程记录下七牛云图床申请SSL免费证书，绑定域名，配置MWeb七牛云服务的过程。</p>
</blockquote>
<blockquote>
<p>多图预警，手机流量较少者请在wifi环境下浏览。 </p>
</blockquote>
<p>这两天，iPic这个MacOS上的图床神器免费版的一直上传失败，可窝火了！估计是自动登陆微博的机制了出问题了吧。。。</p>
<p>iPic确实挺好用的，可以很方便地实现图片上传图床，复制markdown链接，但是现在免费版的上传微博图床上传失败，又用不起收费版的（一年订阅要68块大洋～～～），只能另想他法。</p>
<p>一直是用MWeb在写东西，它用自动发布博客和图片自动上传图床的功能，不过之前都没有用起来，这次趁着iPic用不了，就想着把mweb这套流程跑起来，在本地写完文章后，可以自动上传图床，并发布到wordpress。</p>
<p>mweb支持上传的图床有Google Photos, imgur, 七牛云存储，又拍云和自定义，竟然不支持微博和github，那只能用七牛云存储了。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924135637.png" alt=""></p>
<p>七牛云一个月赠送10G存储空间，20G下载流量，10w的put和100w的getAPI请求次数。对于一个访问量不大的网站，这些赠送的额度是绰绰有余的。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924141138.png" alt=""></p>
<p>之前已经在七牛云上创建过一个存储空间了，但是它分配的是一个测试域名，还不支持HTTPS，而我的网站已经全站支持HTTPS了，所以之前那个测试域名我是不想用了，必须自己再绑定一个域名，设置通信协议为HTTPS。步骤如下：</p>
<p>首先你要有一个备案的域名，如果不知道如何备案域名，请移步<a href="https://www.weiweiblog.cn/beian/" target="_blank" rel="noopener">10天搞定域名备案（全记录）</a>，然后你得给你的域名申请SSL证书，刚好七牛云有提供一年免费的SSL证书。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924143001.png" alt=""></p>
<p>在<code>管理控制台</code>-&gt;<code>SSL证书服务</code>点击<code>购买证书</code>按钮</p>
<p><img src="https://cdn.weiweiblog.cn/20180924143124.png" alt=""></p>
<p>可以看到TrustAsia有限免，点击限免的，拉到最下面有核对信息并支付</p>
<p><img src="https://cdn.weiweiblog.cn/20180924143902.png" alt=""></p>
<p>确认支付</p>
<p><img src="https://cdn.weiweiblog.cn/20180924143957.png" alt=""></p>
<p>之后会提示支付成功，并让你补全信息</p>
<p><img src="https://cdn.weiweiblog.cn/20180924144021.png" alt=""></p>
<p>这边我用的是qiniu.weiweiblog.cn这个二级域名，因为<a href="http://www.weiweiblog.cn已经用到我的网站上了，你可以根据你的实际情况填写" target="_blank" rel="noopener">www.weiweiblog.cn已经用到我的网站上了，你可以根据你的实际情况填写</a></p>
<p><img src="https://cdn.weiweiblog.cn/20180924144416.png" alt=""></p>
<p>剩下的基本信息就根据你的实际情况填写，提交后会显示待确认</p>
<p><img src="https://cdn.weiweiblog.cn/20180924144913.png" alt=""></p>
<p>这时候就需要去你的域名管理商那边添加一条TXT记录，进行域名验证。</p>
<p>以阿里云为例，添加一条记录，选择TXT记录类型，填入七牛云给的TXT记录名和TXT记录值</p>
<p><img src="https://cdn.weiweiblog.cn/20180924145236.png" alt=""></p>
<p>过几分钟，等待验证通过，订单状态就会变成已签发。</p>
<p><img src="https://cdn.weiweiblog.cn/20180924145635.png" alt=""></p>
<p>点击<code>我的证书</code>，可以看到多了一条记录</p>
<p><img src="https://cdn.weiweiblog.cn/20180924145756.png" alt=""></p>
<p>至此，SSL证书就申请完成了。</p>
<p>接下来，我们就可以配置域名了</p>
<p>在<code>对象存储</code>页面点击<code>绑定域名</code></p>
<p><img src="https://cdn.weiweiblog.cn/20180924150016.png" alt=""></p>
<p>输入刚才申请SSL证书的二级域名</p>
<p><img src="https://cdn.weiweiblog.cn/20180924150218.png" alt=""></p>
<p>选择HTTPS，如果刚才申请SSL证书成功，在<code>请选择证书</code>旁边的下拉框会出现你的域名供你选择</p>
<p><img src="https://cdn.weiweiblog.cn/20180924150338.png" alt=""></p>
<p>选择好之后，就可以拉到最下面，点击创建</p>
<p><img src="https://cdn.weiweiblog.cn/20180924150646.png" alt=""></p>
<p>再回到对象存储的页面，<code>融合 CDN 加速域名</code>的模块下面多了条记录，这时的状态还不是成功，还需要到你的域名服务商配置CNAME，具体配置方法旁边有说明。配置完成之后，状态就变为<code>成功</code>，这时候你的域名就可以使用了。</p>
<p>然后，我们回到MWeb，<code>偏好设置</code>-&gt;<code>发布服务</code>，选择<code>七牛云存储</code></p>
<p><img src="https://cdn.weiweiblog.cn/20180924151305.png" alt=""></p>
<p>填入对应的信息后就设置好了。</p>
<p>当你写完文章后，点击把本地图片上传至图床</p>
<p><img src="https://cdn.weiweiblog.cn/20180924151713.png" alt=""></p>
<p>信息框里就会显示本地所有的图片</p>
<p><img src="https://cdn.weiweiblog.cn/20180924151803.png" alt=""></p>
<p>点击上传本地图片后，就可以自动上传本地所有的图片</p>
<p>至此，图床就折腾完毕了，再配置一下自动发布到wordpress，就不会出现本地的图片，发布后图片不显示的问题了。</p>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
  </entry>
  <entry>
    <title>10天搞定域名备案（全记录）</title>
    <url>/beian/</url>
    <content><![CDATA[<p>前年12月在万网买了个域名，然后就没有然后了。。。</p>
<p>直到前几天又开始想好好建设一下个人主页，于是有了备案域名的想法，那就Just do it</p>
<h1 id="3月8日"><a href="#3月8日" class="headerlink" title="3月8日"></a>3月8日</h1><p>既然域名是在万网买的，那就直接用阿里云的代备案系统了（由于当时没有截图，下面图片均出自<a href="https://help.aliyun.com/knowledge_detail/6563875.html?spm=5176.200021.n2.18.Ql8xA4#万网主机网站备案指南" target="_blank" rel="noopener">万网主机网站备案指南</a>）</p>
<blockquote>
<p><a href="https://beian.gein.cn/order/index.htm" target="_blank" rel="noopener">https://beian.gein.cn/order/index.htm</a> </p>
</blockquote>
<p>1、看一下首次备案流程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-fa23aabcb5653fc6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt"></p>
<p>2、注册账号</p>
<p><img src="https://img.alicdn.com/tps/i3/TB1az5kGVXXXXcJXpXXvYGVGpXX-700-368.png" alt="">   </p>
<p>3、进入填写的邮箱查看邮件,完成登录账户注册</p>
<p><img src="https://img.alicdn.com/tps/i2/TB1GvORGVXXXXcBXpXXOGKKGpXX-700-307.jpg" alt=""></p>
<p>4、登录备案系统</p>
<p>根据您填写备案域名以及主体信息，进行验证备案类型</p>
<p><img src="https://img.alicdn.com/tps/i4/TB1aBKKGVXXXXcgXVXXZp6XGpXX-700-487.png" alt=""></p>
<p>5、验证产品</p>
<p>根据填写的备案域名等信息判断此次备案为首次备案，继续填写产品信息验证产品</p>
<p><img src="https://img.alicdn.com/tps/i1/TB1g9qHHXXXXXc7aXXXqOG3GpXX-700-439.png" alt=""> </p>
<p>这里需要阿里云主机或者万网虚拟主机，我购买的是33元的<a href="http://click.aliyun.com/m/3646/?spm=a3c00.7621327.a3c20.3.oFqcro" target="_blank" rel="noopener">云虚机主机免费版极速礼包</a>，购买之后，主可以在主机管理界面找到相应的控制台用户名及密码用于验证：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-5f7e51deb0ee1eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>6、填写主体信息</p>
<p><img src="https://img.alicdn.com/tps/i3/TB1ySCTGVXXXXaPXpXXM1y3GpXX-700-438.png" alt=""> </p>
<p><img src="https://img.alicdn.com/tps/i1/TB1YFuZGVXXXXaQXXXX4O54GpXX-700-446.png" alt=""></p>
<p>7、填写网站信息</p>
<p><img src="https://img.alicdn.com/tps/i4/TB1QcqTGVXXXXboXpXXQe2bGpXX-700-499.png" alt=""> </p>
<p><img src="https://img.alicdn.com/tps/i2/TB1ICaLGVXXXXXZXVXXHRy_GpXX-700-509.png" alt=""></p>
<p>8、上传备案资料（注：我第一次上传的时候用的是Chrome浏览器，遇到无法上传的情况，之后改用Microsoft Edge浏览器就可以上传了）</p>
<p><img src="https://img.alicdn.com/tps/i1/TB1g7WGGVXXXXaYaXXXUKSUGpXX-700-365.jpg" alt=""> </p>
<p><img src="https://img.alicdn.com/tps/i4/TB11JmPGVXXXXbXXFXXkjOMGpXX-700-293.jpg" alt=""></p>
<p><img src="https://img.alicdn.com/tps/i3/TB1C_STGVXXXXaaXpXXcNS1GpXX-700-428.png" alt=""></p>
<p>9、提交备案至初审（阿里云效率还是很高的，当天就会打电话过来告诉你初审情况。。。然而我没有注意，错过了三个电话。。。）</p>
<p><img src="https://img.alicdn.com/tps/i3/TB1T21YGVXXXXbiXXXXvgyDGpXX-700-239.png" alt="">  </p>
<h1 id="3月9日"><a href="#3月9日" class="headerlink" title="3月9日"></a>3月9日</h1><p>第二天初审没有通过，原因是网站的名称不符合规定，所以第二天我又改了名称重新提交初审，并且时时关注来自杭州的电话，终于下午阿里云的工作人员打电话来了，告诉我网站名称又一次不符合规定，并让我当场改一个,ps：工作人员态度还是很好的，还给了很多建议，然后初审就过啦<del>~</del></p>
<p>10、初审通过后，可进行拍照核</p>
<p><img src="https://img.alicdn.com/tps/i2/TB1JamSGVXXXXbMXpXX1ACZGpXX-700-391.jpg" alt=""> </p>
<p>因为我在内蒙偏远地区支教，所以没法前往拍照核验点拍照，所以选择方法2，申请邮寄幕布，自行拍照后上传，花了15软妹币，发顺丰。</p>
<p>#3月14日</p>
<p>因为是偏远地区，所以顺丰也要5天才到。。。</p>
<p>收到幕布后马上拍照上传（就不上图啦<del>）</del></p>
<p>11、提交照片，等待审核</p>
<p><img src="https://img.alicdn.com/tps/i1/TB1On5UGVXXXXXzXpXXUf9CGpXX-700-235.png" alt=""> </p>
<p>当天就收到审核通过的信息</p>
<blockquote>
<p>您的备案信息已通过阿里云审核，即将提交至通信管理局审核！ </p>
</blockquote>
<p>12、待提交管局审核</p>
<p><img src="https://img.alicdn.com/tps/i1/TB1Yu5YGVXXXXXDXXXX.DSrGpXX-700-146.png" alt=""></p>
<p>13、等待管局审核</p>
<p><img src="https://img.alicdn.com/tps/i1/TB1DAmTGVXXXXaRXpXXpFaFGpXX-700-251.png" alt=""> </p>
<p>#3月18日</p>
<p>14、备案成功；</p>
<p>审核结果将以短信及邮件形式通知</p>
<p><img src="https://img.alicdn.com/tps/i2/TB11suSGVXXXXcxXpXXaqUwGVXX-701-365.jpg" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-99545f2760b62e6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>至此，咱的网站也是用“户口”的啦<del>~</del></p>
<p>阿里云代备案效率还是挺高的，很多审核当天就搞定，要不是我身处偏远地区，一星期内肯定能搞定</p>
<p>接下来要好好装修我的个人主页啦，吼吼！！</p>
<p>个人主页：尾尾部落<a href="http://www.weiweiblog.cn" target="_blank" rel="noopener">www.weiweiblog.cn</a></p>
<p>欢迎加友链<del>~</del></p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
  </entry>
  <entry>
    <title>记一次DigitalOcean欠费、删除账号、充错账号、退款经历</title>
    <url>/digitalocean_refund/</url>
    <content><![CDATA[<p>之前用github的学生优惠申请了digitalocean的一台vps，但是因为已经有一台腾讯云，所以digitalocean就没怎么用，荒废着长草。</p>
<p>时间就这么如白驹过隙，一晃一年就过去了，digitalocean送的额度在8月份就用完了，9月就收费了，于是我就收到这样的邮件，说我欠费了，还欠了3.37刀。我以为欠费了，它会自动把我服务器关了，反正里面也没有要备份的东西，我就没管了。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvifgolh3fj317609etay.jpg" alt=""></p>
<p>谁知道，没过几天，我又收到了digitalocean的欠费提醒邮件，而且，这次的金额还变多了，从$3.37变成3.72。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fviflywiqwj3192080mz4.jpg" alt=""></p>
<p>我开方了，Google了一下，发现很多骂DigitalOcean的：垃圾DigitalOcean，欠费不停机。。。</p>
<p>原来，按时计费的，你的VPS开了一小时就收一小时的费用，但是欠费了它也不会自己给你停机。</p>
<p>于是，赶紧登录DigitalOcean自己把vps停了，删除掉，然后把欠款给补上（毕竟咱是有诚信的）</p>
<p>然鹅，因为我有两个DigitalOcean，都是记住密码可以自动登录的，我充值的时候，登陆的是另一个账号，结果，是的，我充错账号了-_-|||&#8230;</p>
<p>所以，这时候，我两个账号的状态是：</p>
<ol>
<li><p>一个账号欠着款</p>
</li>
<li><p>另一个账号啥都没干就充了5刀进去</p>
</li>
</ol>
<p>我真是脑袋进水。。。</p>
<p>于是，赶紧找找有没有退款的按钮，找了半天啥都没有，Google了一下，有的说DigitalOcean不支持退款，有的说给客服发邮件可以退款。。。我就死马当活马医，给客服<a href="mailto:support@support.digitalocean.com">support@support.digitalocean.com</a>发了如下邮件，</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvig0rfp2zj30ty0aemyy.jpg" alt=""></p>
<p>直接用中文发的，但是貌似对方系统不支持显示中文，他们看到的是乱码吧，估计没看懂，给我回了如下的邮件，让我提供更多的信息</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvig3aeoumj31a00koq7o.jpg" alt=""></p>
<p>于是我学乖了，直接给发蹩脚的英文过去</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvig4maje9j31b80kqwhm.jpg" alt=""></p>
<p>这次他们就看懂了，也很及时地给我回复，说钱已经原路返回，退回paypal里了</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvig55skvaj315q0ciq4y.jpg" alt=""></p>
<p>我到paypal里一看，果然有一条退款记录，并且已经退回到银行卡，但是我一查银行卡，里面的钱还没到账，据说要7天到30天左右才能到账。。。</p>
<p>至些，我的5刀也算是失而复得了。至于那个欠费的账号呢，我发现它有个删除账号的按钮，于是我就点了一下，然后，账号就没了，没了，没了。。。</p>
<p>然后就没有然后了。。。</p>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>简书作者信息统计</title>
    <url>/jianshu/</url>
    <content><![CDATA[<p>从2016年就开始在简书上写文章，之所以选择这个平台，很大程度上是因为它洁简的后台输入界面，支持MD，非常适合写一些技术类的文章。</p>
<p>从最开始的零星几个粉丝，到粉丝数破百，到现在有700+粉丝，虽然离大牛们动辄数十万的粉丝还有很大的差距，但是看着粉丝数一天天上涨，感觉也很有成就感。于是就想着记录下粉丝数增涨的过程，以后当粉丝数上万后可以回头看看自己是怎么一步一步走到今天的（此处应该是意淫的表情）。但是，也许是简书太乞求简洁，后台都不提供作者粉丝数历史记录的，不像微信公众号、头条、熊掌号这些成熟的自媒体平台，都会给作者提供完善的相关数据记录，让作者可以清晰地跟踪自己粉丝数增长的曲线。</p>
<p>既然简书不提供，自己又希望有这个功能，又不想放弃简书这个平台，那就自己动手，丰衣足食吧。实现起来也很简单，思路如下：</p>
<ol>
<li>写个爬虫，每天定时爬取自己简书账号的各项指标数据（包括粉丝数、喜欢数、文章数等）</li>
<li>写一个页面，用来做数据展示 <a href="https://jianshu.weiweiblog.cn/j/67eb7ed414d3" target="_blank" rel="noopener">简书信息统计展示页面</a></li>
<li>没了，就是这么简单。</li>
</ol>
<blockquote>
<p>Talk is cheap, Show you the code</p>
</blockquote>
<blockquote>
<p>上代码，这里附上爬虫的代码，展示页面做得还不是很完善，就不献丑了。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomUserAgent</span><span class="params">()</span>:</span></span><br><span class="line">    USER_AGENTS = [</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20"</span>,</span><br><span class="line">        <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random.choice(USER_AGENTS)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span><span class="params">(url, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'headers'</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        kwargs[<span class="string">'headers'</span>] = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: randomUserAgent(),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    r = requests.get(url, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getArticleInfo</span><span class="params">(user)</span>:</span></span><br><span class="line">    print(<span class="string">"==getArticleInfo=="</span>)</span><br><span class="line">    uid = user[<span class="string">'uid'</span>]</span><br><span class="line">    article_num = int(user[<span class="string">'article_nums'</span>])</span><br><span class="line">    PER_NUM = <span class="number">9</span></span><br><span class="line">    max_page = int(article_num / PER_NUM) <span class="keyword">if</span> (article_num % PER_NUM) == <span class="number">0</span> <span class="keyword">else</span> int(article_num / PER_NUM)+<span class="number">1</span></span><br><span class="line">    article_urls = [<span class="string">'https://www.jianshu.com/u/&#123;&#125;?order_by=shared_at&amp;page=&#123;&#125;'</span>.format(uid, i) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                    range(<span class="number">1</span>, max_page+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    details = []</span><br><span class="line">    <span class="keyword">for</span> article_url <span class="keyword">in</span> article_urls:</span><br><span class="line">        r = getResponse(article_url)</span><br><span class="line">        dom = etree.HTML(r.text)</span><br><span class="line">        items = dom.xpath(<span class="string">'//ul[@class="note-list"]/li'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="comment"># 对每个 li标签再提取</span></span><br><span class="line">            details_xpath = &#123;</span><br><span class="line">                <span class="string">'link'</span>: <span class="string">'./div/a/@href'</span>,</span><br><span class="line">                <span class="string">'title'</span>: <span class="string">'./div/a/text()'</span>,</span><br><span class="line">                <span class="string">'read_num'</span>: <span class="string">'.//div[@class="meta"]/a[1]/text()'</span>,</span><br><span class="line">                <span class="string">'comment_num'</span>: <span class="string">'.//div[@class="meta"]/a[2]/text()'</span>,</span><br><span class="line">                <span class="string">'heart_num'</span>: <span class="string">'.//div[@class="meta"]/span[1]/text()'</span>,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_and_path = details_xpath.items()</span><br><span class="line">            detail = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, path <span class="keyword">in</span> key_and_path:</span><br><span class="line">                detail[key] = <span class="string">''</span>.join(item.xpath(path)).strip()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#将数字转换为整数</span></span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'read_num'</span>, <span class="string">'comment_num'</span>, <span class="string">'heart_num'</span>]:</span><br><span class="line">                    detail[key] = int(detail[key])</span><br><span class="line"></span><br><span class="line">                details.append(detail)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回爬取结果</span></span><br><span class="line">    <span class="keyword">return</span> details</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getUserInfo</span><span class="params">(uid)</span>:</span></span><br><span class="line">    print(<span class="string">'==getUserInfo=='</span>)</span><br><span class="line">    url = <span class="string">'https://www.jianshu.com/u/&#123;&#125;'</span>.format(uid)</span><br><span class="line">    r = getResponse(url)</span><br><span class="line">    dom = etree.HTML(r.text)</span><br><span class="line">    user_info = dict()</span><br><span class="line">    user_info[<span class="string">'uid'</span>] = uid</span><br><span class="line">    user_info[<span class="string">'following'</span>]= dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">    user_info[<span class="string">'follows'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">1</span>]</span><br><span class="line">    user_info[<span class="string">'article_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/a/p/text()'</span>)[<span class="number">2</span>]</span><br><span class="line">    user_info[<span class="string">'word_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/p/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">    user_info[<span class="string">'like_nums'</span>] = dom.xpath(<span class="string">'//div[@class="meta-block"]/p/text()'</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFollowsInfo</span><span class="params">(user_info)</span>:</span></span><br><span class="line">    print(<span class="string">"==getFollowsInfo=="</span>)</span><br><span class="line">    follows = []</span><br><span class="line">    uid = user_info[<span class="string">'uid'</span>]</span><br><span class="line">    follow_num = int(user_info[<span class="string">'follows'</span>])</span><br><span class="line">    PER_NUM = <span class="number">9</span></span><br><span class="line">    max_page = int(follow_num / PER_NUM) <span class="keyword">if</span> (follow_num % PER_NUM) == <span class="number">0</span> <span class="keyword">else</span> int(follow_num / PER_NUM)+<span class="number">1</span></span><br><span class="line">    following_urls = [<span class="string">'https://www.jianshu.com/users/&#123;&#125;/followers?page=&#123;&#125;'</span>.format(uid, i) <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                          range(<span class="number">1</span>, max_page+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> following_url <span class="keyword">in</span> following_urls:</span><br><span class="line">        r = getResponse(following_url)</span><br><span class="line">        dom = etree.HTML(r.text)</span><br><span class="line">        items = dom.xpath(<span class="string">'//ul/li//div[@class="info"]'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            user = &#123;&#125;</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                user[<span class="string">'uid'</span>] = item.xpath(<span class="string">'./a/@href'</span>)[<span class="number">0</span>].split(<span class="string">'/'</span>)[<span class="number">2</span>]</span><br><span class="line">                user[<span class="string">'following'</span>] = item.xpath(<span class="string">'./div/span[1]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'关注'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                user[<span class="string">'follows'</span>] = item.xpath(<span class="string">'./div/span[2]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'粉丝'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                user[<span class="string">'article_nums'</span>] = item.xpath(<span class="string">'./div/span[3]/text()'</span>)[<span class="number">0</span>].replace(<span class="string">'文章'</span>, <span class="string">''</span>).strip()</span><br><span class="line">                s = item.xpath(<span class="string">'./div[2]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">                num = re.findall(<span class="string">r"\d+"</span>,s)</span><br><span class="line">                <span class="keyword">if</span> len(num) == <span class="number">2</span>:</span><br><span class="line">                    user[<span class="string">'word_nums'</span>] = num[<span class="number">0</span>]</span><br><span class="line">                    user[<span class="string">'like_nums'</span>] = num[<span class="number">1</span>]</span><br><span class="line">                follows.append(user)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> follows</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    uid = <span class="string">"67eb7ed414d3"</span></span><br><span class="line">    date = time.strftime(<span class="string">"%Y-%m-%d"</span>, time.localtime())</span><br><span class="line">    user_info = getUserInfo(uid)</span><br><span class="line">    details = getArticleInfo(user_info)</span><br><span class="line">    follows = getFollowsInfo(user_info)</span><br><span class="line">    data = &#123;<span class="string">'uid'</span>: uid, <span class="string">'date'</span>: date, <span class="string">'following'</span>: user_info[<span class="string">'following'</span>],</span><br><span class="line">            <span class="string">'follows'</span>: user_info[<span class="string">'follows'</span>], <span class="string">'article_nums'</span>: user_info[<span class="string">'article_nums'</span>],</span><br><span class="line">            <span class="string">'word_nums'</span>: user_info[<span class="string">'word_nums'</span>], <span class="string">'like_nums'</span>: user_info[<span class="string">'like_nums'</span>],</span><br><span class="line">            <span class="string">'article_details'</span>: details, <span class="string">'follows_details'</span>: follows&#125;</span><br><span class="line"></span><br><span class="line">    db  = client.jianshu</span><br><span class="line">    posts = db.author_info</span><br><span class="line">    result = posts.insert_one(data)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数据库用的是mongodb，让自行配置。</p>
<p>祝各位作者粉丝数暴增。</p>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网校招面试必备——Redis</title>
    <url>/redis/</url>
    <content><![CDATA[<h3 id="Redis有哪些数据结构？"><a href="#Redis有哪些数据结构？" class="headerlink" title="Redis有哪些数据结构？"></a>Redis有哪些数据结构？</h3><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</p>
<p>如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p>
<p>如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p>
<h3 id="Redis为什么是单线程的？"><a href="#Redis为什么是单线程的？" class="headerlink" title="Redis为什么是单线程的？"></a>Redis为什么是单线程的？</h3><p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，</p>
<h3 id="使用Redis有哪些好处？"><a href="#使用Redis有哪些好处？" class="headerlink" title="使用Redis有哪些好处？"></a>使用Redis有哪些好处？</h3><p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>
<p>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</p>
<p>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h3 id="Redis相比memcached有哪些优势？"><a href="#Redis相比memcached有哪些优势？" class="headerlink" title="Redis相比memcached有哪些优势？"></a>Redis相比memcached有哪些优势？</h3><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<p>(4) Redis支持数据的备份，即master-slave模式的数据备份。</p>
<p>(5)、使用底层模型不同</p>
<p>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。</p>
<p>Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
<p>(6）value大小：redis最大可以达到1GB，而memcache只有1MB</p>
<h3 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h3><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<h3 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h3><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p>
<p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><p>纯内存数据库，避免了磁盘I/O的瓶颈。</p>
<p>单进程单线程，减少了线程上下文切换的开销。</p>
<p>利用队列技术将并行访问变为串行访问，消除了传统数据库并发访问控制锁的开销。</p>
<p>Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>
<p>使用多路I/O复用模型，非阻塞I/O。</p>
<h4 id="多路I-O复用模型："><a href="#多路I-O复用模型：" class="headerlink" title="多路I/O复用模型："></a>多路I/O复用模型：</h4><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<h3 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h3><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<h3 id="Redis-持久化方式"><a href="#Redis-持久化方式" class="headerlink" title="Redis 持久化方式"></a>Redis 持久化方式</h3><ul>
<li><p>RDB持久化：redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行，也可以再redis.conf中配置，定期执行。RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。</p>
</li>
<li><p>AOF持久化：AOF持久化（Append-Only-File），与RDB持久化不同，AOF持久化是通过保存Redis服务器锁执行的写状态来记录数据库的。具体来说，RDB持久化相当于备份数据库状态，而AOF持久化是备份数据库接收到的命令，所有被写入AOF的命令都是以redis的协议格式来保存的。在AOF持久化的文件中，数据库会记录下所有变更数据库状态的命令，除了指定数据库的select命令，其他的命令都是来自client的，这些命令会以追加(append)的形式保存到文件中。</p>
<p>对比：</p>
</li>
<li><p>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢，也更完整。</p>
</li>
<li><p>RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/xlgen157387/article/details/79470556" target="_blank" rel="noopener">为什么说Redis是单线程的以及Redis为什么这么快！</a></li>
<li><a href="https://www.imooc.com/article/36399" target="_blank" rel="noopener">史上最全Redis面试题及答案</a></li>
</ul>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网校招面试必备——数据库</title>
    <url>/databases/</url>
    <content><![CDATA[<h2 id="DDL（Data-Definition-Language）数据库定义语言"><a href="#DDL（Data-Definition-Language）数据库定义语言" class="headerlink" title="DDL（Data Definition Language）数据库定义语言"></a>DDL（Data Definition Language）数据库定义语言</h2><p>CREATE、ALTER、DROP、TRUNCATE、COMMENT、RENAME</p>
<h2 id="DML（Data-Manipulation-Language）数据操纵语言"><a href="#DML（Data-Manipulation-Language）数据操纵语言" class="headerlink" title="DML（Data Manipulation Language）数据操纵语言"></a>DML（Data Manipulation Language）数据操纵语言</h2><p>SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE</p>
<h2 id="左连接、右连接、内连接、全连接"><a href="#左连接、右连接、内连接、全连接" class="headerlink" title="左连接、右连接、内连接、全连接"></a>左连接、右连接、内连接、全连接</h2><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemvsngcbj30go0d4q4v.jpg" alt=""></p>
<h3 id="INNER-JOIN（内连接）"><a href="#INNER-JOIN（内连接）" class="headerlink" title="INNER JOIN（内连接）"></a>INNER JOIN（内连接）</h3><p>内连接是一种一一映射关系，就是两张表都有的才能显示出来</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemwddgj8j307604umxa.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">INNER JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure>

<h3 id="LEFT-JOIN-（左连接）"><a href="#LEFT-JOIN-（左连接）" class="headerlink" title="LEFT JOIN （左连接）"></a>LEFT JOIN （左连接）</h3><p>左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示，所谓的左边表其实就是指放在left join的左边的表</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvemxp9klbj307604umxa.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">LEFT JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure>

<h3 id="RIGHT-JOIN（右连接）"><a href="#RIGHT-JOIN（右连接）" class="headerlink" title="RIGHT JOIN（右连接）"></a>RIGHT JOIN（右连接）</h3><p>右连接正好是和左连接相反的，这里的右边也是相对right join来说的，在这个右边的表就是右表</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvemyju8qmj307604uq32.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">RIGHT JOIN table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure>

<h3 id="OUTER-JOIN（外连接、全连接）"><a href="#OUTER-JOIN（外连接、全连接）" class="headerlink" title="OUTER JOIN（外连接、全连接）"></a>OUTER JOIN（外连接、全连接）</h3><p>查询出左表和右表所有数据，但是去除两表的重复数据</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvemzkh12zj307604umxa.jpg" alt=""></p>
<p>因为mysql不支持全连接，只能用以下代码实现效果，含义是左连接+右连接+去重=全连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">LEFT JOIN  table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK</span><br><span class="line"> UNION</span><br><span class="line">SELECT  A.PK AS A_PK,A.Value AS A_Value,B.PK AS B_PK,B.Value AS B_Value</span><br><span class="line">FROM table_a A</span><br><span class="line">RIGHT JOIN  table_b B</span><br><span class="line">ON A.PK &#x3D; B.PK;</span><br></pre></td></tr></table></figure>

<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。</p>
<p>用法：A CROSS JOIN B (不要ON)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u014204541/article/details/79739980" target="_blank" rel="noopener">数据库左连接、右连接、内连接、全连接笔记</a></p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p>
<ul>
<li>第一范式（1NF）：符合1NF的关系中的每个属性都不可再分。是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</li>
<li>第二范式（2NF）：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>第三范式（3NF）：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</li>
</ul>
<p>详细内容参考：<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">知乎——解释一下关系数据库的第一第二第三范式？_刘慰</a></p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是一种数据结构 。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li><p>B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvg610tf0tj316s0fqq7m.jpg" alt=""></p>
</li>
</ul>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</p>
<p>B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>主键索引: 数据列不允许重复，不允许为NULL.一个表只能有一个主键。</li>
<li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li>
<li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</li>
<li>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
<li>非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li>
</ul>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>
<h3 id="四大特性-简称ACID"><a href="#四大特性-简称ACID" class="headerlink" title="四大特性(简称ACID)"></a>四大特性(简称ACID)</h3><p>数据库如果支持事务的操作，那么就具备以下四个特性：</p>
<ol>
<li>原子性(Atomicity)</li>
</ol>
<p>事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。</p>
<ol start="2">
<li>一致性(Consistency)</li>
</ol>
<p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p>
<ol start="3">
<li>隔离性(Isolation)</li>
</ol>
<p>一个事务的执行不能被其他事务干扰。</p>
<ol start="4">
<li>持续性/永久性(Durability)</li>
</ol>
<p>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read uncommitted</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Read committed&#8211;Sql Server , Oracle</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Repeatable read&#8211;MySQL</td>
<td align="center">×</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。</p>
<p>出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。</p>
<p>当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。</p>
<h4 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h4><p>singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何&#8230;&#8230;</p>
<p>出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p>
<p>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</p>
<p>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。</p>
<h4 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h4><p>当隔离级别设置为Repeatable read时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。</p>
<p>虽然Repeatable read避免了不可重复读，但还有可能出现幻读。</p>
<p>singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction &#8230; ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p>
<p>注：MySQL的默认隔离级别就是Repeatable read。</p>
<h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Read-Uncommitted（读取未提交内容）"><a href="#Read-Uncommitted（读取未提交内容）" class="headerlink" title="Read Uncommitted（读取未提交内容）"></a>Read Uncommitted（读取未提交内容）</h4><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<h4 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h4><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<h4 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h4><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<h4 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h4><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读操作不加S锁；</p>
<p>在Read Committed级别下，读操作需要加S锁，但是在语句执行完以后释放S锁；</p>
<p>在Repeatable Read级别下，读操作需要加S锁，但是在事务提交之前并不释放S锁，也就是必须等待事务执行完毕以后才释放S锁。</p>
<p>在Serialize级别下，会在Repeatable Read级别的基础上，添加一个范围锁。保证一个事务内的两次查询结果完全一样，而不会出现第一次查询结果是第二次查询结果的子集。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://xm-king.iteye.com/blog/770721" target="_blank" rel="noopener">MySQL事务隔离级别详解</a></li>
<li><a href="https://blog.csdn.net/baidu_37107022/article/details/77481670" target="_blank" rel="noopener">数据库隔离级别</a></li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性搞，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。</p>
<p>视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。</p>
<h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol>
<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的，这些视图有如下特征：</p>
<p>　　a.有UNIQUE等集合操作符的视图。</p>
<p>　　b.有GROUP BY子句的视图。</p>
<p>　　c.有诸如AVG\SUM\MAX等聚合函数的视图。</p>
<p>　　d.使用DISTINCT关键字的视图。</p>
<p>　　e.连接表的视图（其中有些例外）</p>
</li>
</ol>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程。一旦定义，触发器将被保存在数据库服务器中。任何用户对表的增、删、改操作均由服务器自动激活相应的触发器，在关系数据库管理系统核心层进行集中的完整性控制。触发器类似于约束，但是比约束更加灵活，可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</p>
<h2 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h2><p>三者都表示删除，但是三者有一些差别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Delete</th>
<th align="center">Truncate</th>
<th align="center">Drop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">属于DML</td>
<td align="center">属于DDL</td>
<td align="center">属于DDL</td>
</tr>
<tr>
<td align="center">回滚</td>
<td align="center">可回滚</td>
<td align="center">不可回滚</td>
<td align="center">不可回滚</td>
</tr>
<tr>
<td align="center">删除内容</td>
<td align="center">表结构还在，删除表的全部或者一部分数据行</td>
<td align="center">表结构还在，删除表中的所有数据</td>
<td align="center">从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td align="center">删除速度</td>
<td align="center">删除速度慢,需要逐行删除</td>
<td align="center">删除速度快</td>
<td align="center">删除速度快</td>
</tr>
</tbody></table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvh9340z9oj30kd0emdgz.jpg" alt=""></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<blockquote>
<p>获取最新资讯，请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网校招面试必备——Java多线程</title>
    <url>/thread/</url>
    <content><![CDATA[<p>本文是我刷了几十篇一线互联网校招java后端开发岗位的面经后总结的多线程相关题目，虽然有点小长，但是面试前看一看，相信能帮你轻松啃下多线程这块大骨头。</p>
<blockquote>
<p>什么是进程，什么是线程？为什么需要多线程编程？</p>
</blockquote>
<blockquote>
<p>进程间的通信方式、线程间的通信方式</p>
</blockquote>
<blockquote>
<p>实现多线程的三种方法</p>
</blockquote>
<blockquote>
<p>三种创建多线程方法的对比</p>
</blockquote>
<blockquote>
<p>线程状态</p>
</blockquote>
<blockquote>
<p>线程控制</p>
</blockquote>
<blockquote>
<p>wait、notify、notifyAll的区别</p>
</blockquote>
<blockquote>
<p>sleep() 和 wait() 有什么区别?</p>
</blockquote>
<blockquote>
<p>锁类型</p>
</blockquote>
<blockquote>
<p>什么是乐观锁和悲观锁</p>
</blockquote>
<blockquote>
<p>乐观锁的实现方式（CAS）</p>
</blockquote>
<blockquote>
<p>CAS的缺点</p>
</blockquote>
<blockquote>
<p>实现一个死锁</p>
</blockquote>
<blockquote>
<p>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</p>
</blockquote>
<blockquote>
<p>volatile</p>
</blockquote>
<blockquote>
<p>volatile使用建议</p>
</blockquote>
<blockquote>
<p>volatile和synchronized区别</p>
</blockquote>
<blockquote>
<p>synchronized</p>
</blockquote>
<blockquote>
<p>synchronized的三种应用方式</p>
</blockquote>
<blockquote>
<p>Lock</p>
</blockquote>
<blockquote>
<p>Lock接口中获取锁的方法</p>
</blockquote>
<blockquote>
<p>Condition类</p>
</blockquote>
<blockquote>
<p>Condition与Object中的wait, notify, notifyAll区别</p>
</blockquote>
<blockquote>
<p>synchronized和lock的区别</p>
</blockquote>
<blockquote>
<p>锁的状态</p>
</blockquote>
<blockquote>
<p>偏向锁、轻量级锁、重量级锁、自旋锁、自适应自旋锁</p>
</blockquote>
<blockquote>
<p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</p>
</blockquote>
<blockquote>
<p>AQS</p>
</blockquote>
<blockquote>
<p>线程池</p>
</blockquote>
<blockquote>
<p>使用线程池的好处</p>
</blockquote>
<blockquote>
<p>线程池都有哪几种工作队列 </p>
</blockquote>
<h2 id="什么是进程，什么是线程？为什么需要多线程编程？"><a href="#什么是进程，什么是线程？为什么需要多线程编程？" class="headerlink" title="什么是进程，什么是线程？为什么需要多线程编程？"></a>什么是进程，什么是线程？为什么需要多线程编程？</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它占用了更多的 CPU 资源。</p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><ul>
<li>锁机制：包括互斥锁、条件变量、读写锁 <ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
</ul>
<blockquote>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 </p>
</blockquote>
<h2 id="实现多线程的三种方法"><a href="#实现多线程的三种方法" class="headerlink" title="实现多线程的三种方法"></a>实现多线程的三种方法</h2><ul>
<li>继承Thread类，重写父类run()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class thread1 extends Thread &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;我是线程&quot;+this.getId());</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                thread1 th1 &#x3D; new thread1();</span><br><span class="line">                thread1 th2 &#x3D; new thread1();</span><br><span class="line">                th1.start();</span><br><span class="line">                th2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现runnable接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class thread2 implements Runnable &#123;</span><br><span class="line">        public String ThreadName;</span><br><span class="line">        public thread2(String tName)&#123;</span><br><span class="line">                ThreadName &#x3D; tName;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        System.out.println(ThreadName);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建一个Runnable接口实现类的对象</span><br><span class="line">                thread2 th1 &#x3D; new thread2(&quot;线程A:&quot;);</span><br><span class="line">                thread2 th2 &#x3D; new thread2(&quot;线程B:&quot;);</span><br><span class="line">                &#x2F;&#x2F; 将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程</span><br><span class="line">                Thread myth1 &#x3D; new Thread(th1);</span><br><span class="line">                Thread myth2 &#x3D; new Thread(th2);</span><br><span class="line">                &#x2F;&#x2F; 调用start()方法，启动线程并执行run()方法</span><br><span class="line">                myth1.start();</span><br><span class="line">                myth2.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Callable和Future创建线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for(;i&lt;100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        CallableThreadTest ctt &#x3D; new CallableThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);</span><br><span class="line">            if(i&#x3D;&#x3D;20)&#123;</span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());</span><br><span class="line">        &#125; catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种创建多线程方法的对比"><a href="#三种创建多线程方法的对比" class="headerlink" title="三种创建多线程方法的对比"></a>三种创建多线程方法的对比</h3><p>1、采用实现Runnable、Callable接口的方式创建多线程时，线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。缺点是编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2、使用继承Thread类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。缺点是线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>3、Runnable和Callable的区别</p>
<p>(1) Callable规定重写call()，Runnable重写run()。</p>
<p>(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</p>
<p>(3) call方法可以抛出异常，run方法不可以。</p>
<p>(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvao00n1s4j30zk0i8jvt.jpg" alt=""></p>
<ul>
<li>新建状态：新建线程对象，并没有调用start()方法之前</li>
<li>就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。</li>
<li>运行状态：线程被设置为当前线程，获得CPU后，开始执行run()方法，就是线程进入运行状态。</li>
<li>阻塞状态：处于运行的状态的线程，除非执行时间非常非常非常短，否则它会因为系统对资源的调度而被中断进入阻塞状态。比如说调用sleep()方法后线程就进入阻塞状态。</li>
<li>死亡状态：处于运行状态的线程，当它主动或者被动结束，线程就处于死亡状态。结束的形式，通常有以下几种：1. 线程执行完成，线程正常结束；2. 线程执行过程中出现异常或者错误，被动结束；3. 线程主动调用stop方法结束线程。</li>
</ul>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><ul>
<li>join()：等待。让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。</li>
<li>sleep()：睡眠。让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。</li>
<li>yield()：线程让步。将线程从运行状态转换为就绪状态。当某个线程调用 yiled() 方法从运行状态转换到就绪状态后，CPU 会从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。</li>
<li>setPriority()：改变线程的优先级。每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值：MAX_PRIORITY：10；MIN_PRIORITY：1；NORM_PRIORITY：5。</li>
</ul>
<blockquote>
<p>PS: 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 </p>
</blockquote>
<ul>
<li>setDaemon(true)：设置为后台线程。后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。当所有的前台线程都进入死亡状态时，后台线程会自动死亡。</li>
</ul>
<blockquote>
<p>sleep() 和 yield() 两者的区别：</p>
</blockquote>
<blockquote>
<p>① sleep()方法会给其他线程运行的机会，不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会。yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</p>
</blockquote>
<blockquote>
<p>② 当线程执行了 sleep(long millis) 方法，将转到阻塞状态，参数millis指定睡眠时间。当线程执行了yield()方法，将转到就绪状态。</p>
</blockquote>
<blockquote>
<p>③ sleep() 方法声明抛出InterruptedException异常，而 yield() 方法没有声明抛出任何异常。 </p>
</blockquote>
<h2 id="wait、notify、notifyAll的区别"><a href="#wait、notify、notifyAll的区别" class="headerlink" title="wait、notify、notifyAll的区别"></a>wait、notify、notifyAll的区别</h2><p>wait、notify、notifyAll是java同步机制中重要的组成部分，结合synchronized关键字使用，可以建立很多优秀的同步模型。这3个方法并不是Thread类或者是Runnable接口的方法，而是Object类的3个本地方法。</p>
<p>调用一个Object的wait与notify/notifyAll的时候，必须保证调用代码对该Object是同步的，也就是说必须在作用等同于synchronized(obj){&#8230;&#8230;}的内部才能够去调用obj的wait与notify/notifyAll三个方法，否则就会报错：<code>java.lang.IllegalMonitorStateException:current thread not owner</code></p>
<blockquote>
<p>先说两个概念：锁池和等待池</p>
</blockquote>
<blockquote>
<p>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
</blockquote>
<blockquote>
<p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</p>
</blockquote>
<blockquote>
<p>@知乎&#8211;<a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener">文龙</a> </p>
</blockquote>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>wait：线程自动释放其占有的对象锁，并等待notify</p>
</li>
<li><p>notify：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁</p>
</li>
<li><p>notifyAll：唤醒所有正在wait当前对象锁的线程</p>
<p>notify和notifyAll的最主要的区别是：notify只是唤醒一个正在wait当前对象锁的线程，而notifyAll唤醒所有。值得注意的是：notify是本地方法，具体唤醒哪一个线程由虚拟机控制；notifyAll后并不是所有的线程都能马上往下执行，它们只是跳出了wait状态，接下来它们还会是竞争对象锁。</p>
</li>
</ul>
<h4 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h4><p>sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用 sleep 不会释放对象锁。wait() 是 Object 类的方法，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。</p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><ul>
<li>可重入锁：广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。即在执行对象中所有同步方法不用再次获得锁。ReentrantLock和synchronized都是可重入锁。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</li>
<li>可中断锁：在等待获取锁过程中可中断。synchronized就不是可中断锁，而Lock是可中断锁。</li>
<li>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利。非公平锁即无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。synchronized是非公平锁，它无法保证等待的线程获取锁的顺序。对于ReentrantLock和ReentrantReadWriteLock，默认情况下是非公平锁，但是可以设置为公平锁。</li>
<li>读写锁：对资源读取和写入的时候拆分为2部分处理，一个读锁和一个写锁。读的时候可以多线程一起读，写的时候必须同步地写。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li>
</ul>
<h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><p>（1）乐观锁：很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会去判断在此期间有没有人去更新这个数据（可以使用版本号等机制）。如果因为冲突失败就重试。乐观锁适用于写比较少的情况下，即冲突比较少发生，这样可以省去了锁的开销，加大了系统的整个吞吐量。像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>（2）悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，因此每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁，效率比较低。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<h3 id="乐观锁的实现方式（CAS）"><a href="#乐观锁的实现方式（CAS）" class="headerlink" title="乐观锁的实现方式（CAS）"></a>乐观锁的实现方式（CAS）</h3><p>乐观锁的实现主要就两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p>
<p>CAS：CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 ”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p>
<blockquote>
<p>乐观锁是一种思想，CAS是这种思想的一种实现方式。 </p>
</blockquote>
<h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><ol>
<li><p>ABA问题</p>
<blockquote>
<p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。ava并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
</blockquote>
</li>
<li><p>循环时间长开销很大</p>
<blockquote>
<p>自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p>
</blockquote>
</li>
<li><p>只能保证一个共享变量的原子操作。</p>
<blockquote>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
</blockquote>
</li>
</ol>
<h2 id="实现一个死锁"><a href="#实现一个死锁" class="headerlink" title="实现一个死锁"></a>实现一个死锁</h2><p>什么是死锁：两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<p>产生死锁的四个必要条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p>考虑如下情形：</p>
<p>（1）线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。</p>
<p>（2）线程A试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2释放。</p>
<p>（3）如果此时线程B也在试图获取lock1，同理线程也会阻塞。</p>
<p>（4）两者都在等待对方所持有但是双方都不释放的锁，这时便会一直阻塞形成死锁。</p>
<p>死锁的解决方法:</p>
<p>a 撤消陷于死锁的全部进程；</p>
<p>b 逐个撤消陷于死锁的进程，直到死锁不存在；</p>
<p>c 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</p>
<p>d 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态</p>
<h3 id="如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><a href="#如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？" class="headerlink" title="如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？"></a>如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>　　对于过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>
<ul>
<li><p>防止重排序</p>
<blockquote>
<p>问题：操作系统可以对指令进行重排序，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果</p>
</blockquote>
<blockquote>
<p>解决原理：volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
</blockquote>
<blockquote>
<p>1、在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</p>
</blockquote>
<blockquote>
<p>2、在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 </p>
</blockquote>
</li>
<li><p>实现可见性</p>
<blockquote>
<p>问题：可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到</p>
</blockquote>
<blockquote>
<p>解决原理：（1）修改volatile变量时会强制将修改后的值刷新的主内存中。</p>
</blockquote>
<blockquote>
<p>（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 </p>
</blockquote>
</li>
<li><p>注：volatile并不保证变量更新的原子性</p> </p>
</li>
</ul>
<h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p>
<p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</p>
<p>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p>
<h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><p>1、volatile不会进行加锁操作：</p>
<p>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p>
<p>2、volatile变量作用类似于同步变量读写操作：</p>
<p>从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p>
<p>3、volatile不如synchronized安全：</p>
<p>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</p>
<p>4、volatile无法同时保证内存可见性和原子性：</p>
<p>加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。</p>
<p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>
<p>1、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</p>
<p>2、该变量没有包含在具有其他变量的不变式中。</p>
<p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Synchronized主要有以下三个作用：保证互斥性、保证可见性、保证顺序性。</p>
<h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><ul>
<li><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。实现原理：指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static synchronized void increase()&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。实现原理：使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static AccountingSync instance&#x3D;new AccountingSync();</span><br><span class="line">synchronized(instance)&#123;</span><br><span class="line">    for(int j&#x3D;0;j&lt;1000000;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock是一个接口，它的的实现类提供了比synchronized更广泛意义上锁操作，它允许用户更灵活的代码结构，更多的不同特效。Lock的实现类主要有ReentrantLock和ReentrantReadWriteLock。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock lock&#x3D;new ReentrantLock()；</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    &#x2F;&#x2F; 如果有return要写在try块中</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock接口中获取锁的方法"><a href="#Lock接口中获取锁的方法" class="headerlink" title="Lock接口中获取锁的方法"></a>Lock接口中获取锁的方法</h3><ul>
<li>void lock()：lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。在发生异常时，它不会自动释放锁，要记得在finally块中释放锁，以保证锁一定被被释放，防止死锁的发生。</li>
<li>void lockInterruptibly()：可以响应中断，当通过这个方法去获取锁时，如果线程 正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。</li>
<li>boolean tryLock()：有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true；如果获取失败（即锁已被其他线程获取），则返回false。</li>
<li>boolean tryLock(long time, TimeUnit unit)：和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。</li>
</ul>
<h3 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h3><p>Condition是Java提供来实现等待/通知的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
<p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。</p>
<p>其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h4 id="Condition与Object中的wait-notify-notifyAll区别"><a href="#Condition与Object中的wait-notify-notifyAll区别" class="headerlink" title="Condition与Object中的wait, notify, notifyAll区别"></a>Condition与Object中的wait, notify, notifyAll区别</h4><p>1.Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。</p>
<p>不同的是，Object中的这些方法是和同步锁捆绑使用的；而Condition是需要与互斥锁/共享锁捆绑使用的。</p>
<p>2.Condition它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。</p>
<p>例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒&#8221;读线程&#8221;；当从缓冲区读出数据之后，唤醒&#8221;写线程&#8221;；并且当缓冲区满的时候，&#8221;写线程&#8221;需要等待；当缓冲区为空时，&#8221;读线程&#8221;需要等待。</p>
<p>如果采用Object类中的wait(),notify(),notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒&#8221;读线程&#8221;时，不可能通过notify()或notifyAll()明确的指定唤醒&#8221;读线程&#8221;，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。 但是，通过Condition，就能明确的指定唤醒读线程。</p>
<h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存在层次</td>
<td align="center">Java的关键字</td>
<td align="center">是一个接口</td>
</tr>
<tr>
<td align="center">锁的释放</td>
<td align="center">1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td>
<td align="center">在finally中必须释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td align="center">锁的获取</td>
<td align="center">假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td>
<td align="center">Lock可以让等待锁的线程响应中断</td>
</tr>
<tr>
<td align="center">锁状态</td>
<td align="center">无法判断</td>
<td align="center">可以判断有没有成功获取锁</td>
</tr>
<tr>
<td align="center">锁类型</td>
<td align="center">可重入 不可中断 非公平</td>
<td align="center">可重入 可中断 公平/非公平</td>
</tr>
</tbody></table>
<p>性能方面，JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。多线程环境下，synchronized的吞吐量下降的非常严重，而ReentrankLock则能基本保持在同一个比较稳定的水平上。</p>
<p>到了JDK1.6，synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p>
<h2 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h2><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。轻量级锁是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p>自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p>
<h3 id="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"><a href="#偏向锁、轻量级锁、重量级锁适用于不同的并发场景" class="headerlink" title="偏向锁、轻量级锁、重量级锁适用于不同的并发场景"></a>偏向锁、轻量级锁、重量级锁适用于不同的并发场景</h3><p>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</p>
<p>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</p>
<p>重量级锁：有实际竞争，且锁竞争时间长。</p>
<p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p>
<p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p>
<blockquote>
<p>锁膨胀的过程：只有一个线程进入临界区（偏向锁），多个线程交替进入临界区（轻量级锁），多线程同时进入临界区（重量级锁）。 </p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AbstractQueuedSynchronizer是一个抽象类，主要是维护了一个int类型的state属性和一个非阻塞、先进先出的线程等待队列；其中state是用volatile修饰的，保证线程之间的可见性，队列的入队和出对操作都是无锁操作，基于自旋锁和CAS实现；另外AQS分为两种模式：独占模式和共享模式，像ReentrantLock是基于独占模式模式实现的，CountDownLatch、CyclicBarrier等是基于共享模式。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>线程池的产生和数据库的连接池类似，系统启动一个线程的代价是比较高昂的，如果在程序启动的时候就初始化一定数量的线程，放入线程池中，在需要是使用时从池子中去，用完再放回池子里，这样能大大的提高程序性能，再者，线程池的一些初始化配置，也可以有效的控制系统并发的数量，防止因为消耗过多的内存，而把服务器累趴下。</p>
<p>通过Executors工具类可以创建各种类型的线程池，如下为常见的四种：</p>
<ul>
<li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li>
<li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li>
<li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
<li>对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现</li>
</ul>
<h3 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h3><p>1、ArrayBlockingQueue</p>
<p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
<p>2、LinkedBlockingQueue</p>
<p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p>
<p>3、SynchronousQueue</p>
<p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>
<p>4、PriorityBlockingQueue</p>
<p>一个具有优先级的无限阻塞队列。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/java-interview-bible/multi-thread.html" target="_blank" rel="noopener">Java 多线程</a></p>
<p><a href="http://www.importnew.com/23535.html" target="_blank" rel="noopener">Java并发：volatile内存可见性和指令重排</a></p>
<p><a href="https://juejin.im/post/5a43ad786fb9a0450909cb5f" target="_blank" rel="noopener">并发编程的锁机制：synchronized和lock</a></p>
<p><a href="https://juejin.im/post/5a5c09d051882573282164ae" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁</a></p>
<blockquote>
<p>获取最新资讯，请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>同步</tag>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞定BAT面试——Java 集合类</title>
    <url>/collections/</url>
    <content><![CDATA[<h3 id="1-Iterator接口"><a href="#1-Iterator接口" class="headerlink" title="1. Iterator接口"></a>1. Iterator接口</h3><p>Iterator接口，这是一个用于遍历集合中元素的接口，主要包含hashNext(),next(),remove()三种方法。它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious()。也就是说如果是先Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常无序集合实现的都是这个接口，比如HashSet，HashMap；而那些元素有序的集合，实现的一般都是LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个元素，比如ArrayList。</p>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><p>List是元素有序并且可以重复的集合。</p>
<p>List的主要实现：ArrayList, LinkedList, Vector。</p>
<h4 id="2-ArrayList、LinkedList、Vector-的区别"><a href="#2-ArrayList、LinkedList、Vector-的区别" class="headerlink" title="2. ArrayList、LinkedList、Vector 的区别"></a>2. ArrayList、LinkedList、Vector 的区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ArrayList</th>
<th align="center">LinkedList</th>
<th align="center">Vector</th>
</tr>
</thead>
<tbody><tr>
<td align="center">底层实现</td>
<td align="center">数组</td>
<td align="center">双向循环链表</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">同步性及效率</td>
<td align="center">不同步，非线程安全，效率高</td>
<td align="center">不同步，非线程安全，效率高</td>
<td align="center">同步，线程安全，效率低</td>
</tr>
<tr>
<td align="center">特点</td>
<td align="center">查询快,增删慢</td>
<td align="center">查询慢,增删快</td>
<td align="center">查询快,增删慢</td>
</tr>
<tr>
<td align="center">默认容量</td>
<td align="center">10</td>
<td align="center">/</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">扩容机制</td>
<td align="center">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5 倍</td>
<td align="center">/</td>
<td align="center">2 倍</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>总结</strong>：</p>
</blockquote>
<blockquote>
<p>&#8211; ArrayList 和 Vector 基于数组实现，对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</p>
</blockquote>
<blockquote>
<p>&#8211; LinkedList 不会出现扩容的问题，所以比较适合随机位置增、删。但是其基于链表实现，所以在定位时需要线性扫描，效率比较低。</p>
</blockquote>
<blockquote>
<p>&#8211; 当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；</p>
</blockquote>
<blockquote>
<p>&#8211; 当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。 </p>
</blockquote>
<h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h3><p>Set集合中的对象不按特定的方式排序(存入和取出的顺序不一定一致)，并且没有重复对象。</p>
<p>Set的主要实现类：HashSet, TreeSet。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HashSet</th>
<th align="center">TreeSet</th>
<th align="center">LinkedHashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">底层实现</td>
<td align="center">HashMap</td>
<td align="center">红黑树</td>
<td align="center">LinkedHashMap</td>
</tr>
<tr>
<td align="center">重复性</td>
<td align="center">不允许重复</td>
<td align="center">不允许重复</td>
<td align="center">不允许重复</td>
</tr>
<tr>
<td align="center">有/无序</td>
<td align="center">无序</td>
<td align="center">有序，支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</td>
<td align="center">有序，以元素插入的顺序来维护集合的链接表</td>
</tr>
<tr>
<td align="center">时间复杂度</td>
<td align="center">add()，remove()，contains()方法的时间复杂度是O(1)</td>
<td align="center">add()，remove()，contains()方法的时间复杂度是O(logn)</td>
<td align="center">LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet，时间复杂度是 O(1)。</td>
</tr>
<tr>
<td align="center">同步性</td>
<td align="center">不同步，线程不安全</td>
<td align="center">不同步，线程不安全</td>
<td align="center">不同步，线程不安全</td>
</tr>
<tr>
<td align="center">null值</td>
<td align="center">允许null值</td>
<td align="center">不支持null值，会抛出 java.lang.NullPointerException 异常。因为TreeSet应用 compareTo() 方法于各个元素来比较他们，当比较null值时会抛出 NullPointerException异常。</td>
<td align="center">允许null值</td>
</tr>
<tr>
<td align="center">比较</td>
<td align="center">equals()</td>
<td align="center">compareTo()</td>
<td align="center">equals()</td>
</tr>
</tbody></table>
<h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p>
<p>hashCode（）与equals（）的相关规定：</p>
<ul>
<li><p>如果两个对象相等，则hashcode一定也是相同的</p>
</li>
<li><p>两个对象相等,对两个equals方法返回true</p>
</li>
<li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
</li>
<li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p>
<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
</li>
</ul>
<blockquote>
<p>总结：</p>
</blockquote>
<blockquote>
<p>HashSet是一个通用功能的Set，而LinkedHashSet 提供元素插入顺序保证，TreeSet是一个SortedSet实现，由Comparator 或者 Comparable指定的元素顺序存储元素。 </p>
</blockquote>
<h3 id="4-Map"><a href="#4-Map" class="headerlink" title="4. Map"></a>4. Map</h3><p>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。 Map没有继承于Collection接口从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>
<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HashMap</th>
<th align="center">HashTable</th>
</tr>
</thead>
<tbody><tr>
<td align="center">底层实现</td>
<td align="center">数组+链表</td>
<td align="center">数组+链表</td>
</tr>
<tr>
<td align="center">同步性</td>
<td align="center">线程不同步</td>
<td align="center">同步</td>
</tr>
<tr>
<td align="center">null值</td>
<td align="center">允许 key 和 Vale 是 null，但是只允许一个 key 为 null,且这个元素存放在哈希表 0 角标位置</td>
<td align="center">不允许key、value 是 null</td>
</tr>
<tr>
<td align="center">hash</td>
<td align="center">使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值</td>
<td align="center">直接使用 key 的 hashCode() 返回值作为 hash 值</td>
</tr>
<tr>
<td align="center">容量</td>
<td align="center">容量为 2^4 且容量一定是 2^n</td>
<td align="center">默认容量是11,不一定是 2^n</td>
</tr>
<tr>
<td align="center">扩容</td>
<td align="center">两倍，且哈希桶的下标使用 &amp;运算代替了取模</td>
<td align="center">2倍+1，取哈希桶下标是直接用模运算</td>
</tr>
</tbody></table>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><p><strong>1. HashMap 的工作原理？</strong></p>
<p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高效率。</p>
<p><strong>2.get和put的原理吗？equals()和hashCode()的都有什么作用？</strong></p>
<p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>3. HashMap 的长度为什么是2的幂次方？</strong></p>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<h4 id="HashMap-和-LinkedHashMap-的区别"><a href="#HashMap-和-LinkedHashMap-的区别" class="headerlink" title="HashMap 和 LinkedHashMap 的区别"></a>HashMap 和 LinkedHashMap 的区别</h4><ul>
<li>LinkedHashMap 拥有与 HashMap 相同的底层哈希表结构，即数组 + 单链表 + 红黑树，也拥有相同的扩容机制。</li>
<li>LinkedHashMap 相比 HashMap 的拉链式存储结构，内部额外通过 Entry 维护了一个双向链表。</li>
<li>HashMap 元素的遍历顺序不一定与元素的插入顺序相同，而 LinkedHashMap 则通过遍历双向链表来获取元素，所以遍历顺序在一定条件下等于插入顺序。</li>
<li>LinkedHashMap 可以通过构造参数 accessOrder 来指定双向链表是否在元素被访问后改变其在双向链表中的位置。</li>
</ul>
<h4 id="HashMap-amp-TreeMap-的区别"><a href="#HashMap-amp-TreeMap-的区别" class="headerlink" title="HashMap &amp; TreeMap 的区别"></a>HashMap &amp; TreeMap 的区别</h4><p>HashMap实现了Map接口，不保障元素顺序。</p>
<p>TreeMap实现了SortedMap接口，是一个有序的Map。内部采用红黑树实现，红黑树是一种维护有序数据的高效数据结构</p>
<h4 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<p>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p>实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<p>JDK1.7的ConcurrentHashMap：</p>
<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://juejin.im/post/5b7e955be51d4538de11550c" target="_blank" rel="noopener">这几道Java集合框架面试题在面试中几乎必问</a></li>
<li><a href="https://juejin.im/post/5ad6313df265da2386706662" target="_blank" rel="noopener">搞懂 HashSet &amp; LinkedHashSet 源码以及集合常见面试题目</a></li>
</ul>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法总结] 13 道题搞定 BAT 面试——字符串</title>
    <url>/13string/</url>
    <content><![CDATA[<h3 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h3><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li>
<li><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">从头到尾彻底理解KMP</a></li>
<li><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法?</a></li>
<li><a href="https://blog.sengxian.com/algorithms/kmp" target="_blank" rel="noopener">KMP 算法详细解析</a></li>
<li><a href="http://blog.jobbole.com/76611/" target="_blank" rel="noopener">图解 KMP 算法</a></li>
<li><a href="https://www.bilibili.com/video/av3246487/?from=search&seid=17173603269940723925" target="_blank" rel="noopener">汪都能听懂的KMP字符串匹配算法【双语字幕】</a></li>
<li><a href="https://www.bilibili.com/video/av11866460?from=search&seid=12730654434238709250" target="_blank" rel="noopener">KMP字符串匹配算法1</a></li>
</ul>
<h3 id="1-1-BM-算法"><a href="#1-1-BM-算法" class="headerlink" title="1.1 BM 算法"></a>1.1 BM 算法</h3><p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p>
<h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/replacespace/" target="_blank" rel="noopener">替换空格</a></p>
</blockquote>
<blockquote>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &amp;gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                res.append(<span class="string">"02%"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h3><blockquote>
<p>Leetcode: <a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">最长公共前缀</a></p>
</blockquote>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &#8220;&#8221;。 </p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyg2oa3fkj31ec0eoabx.jpg" alt=""></p>
<p>首先对字符串数组进行排序，然后拿数组中的第一个和最后一个字符串进行比较，从第 0 位开始，如果相同，把它加入 res 中，不同则退出。最后返回 res</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">char</span> [] first = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">char</span> [] last = strs[strs.length - <span class="number">1</span>].toCharArray();</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = first.length &amp;lt; last.length ? first.length : last.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first[i] == last[i])&#123;</span><br><span class="line">                res.append(first[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-最长回文串"><a href="#4-最长回文串" class="headerlink" title="4. 最长回文串"></a>4. 最长回文串</h3><blockquote>
<p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">最长回文串</a></p>
</blockquote>
<blockquote>
<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 &#8220;Aa&#8221; 不能当做一个回文字符串。 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuygx8mx9lj31ek0e0tae.jpg" alt=""></p>
<p>统计字母出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashSet&amp;lt;Character&amp;gt; hs = <span class="keyword">new</span> HashSet&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&amp;lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.contains(s.charAt(i)))&#123;</span><br><span class="line">                hs.remove(s.charAt(i));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hs.add(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hs.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-验证回文串"><a href="#4-1-验证回文串" class="headerlink" title="4.1 验证回文串"></a>4.1 验证回文串</h3><blockquote>
<p>Leetcode: <a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">验证回文串</a></p>
</blockquote>
<blockquote>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
</blockquote>
<blockquote>
<p>说明：本题中，我们将空字符串定义为有效的回文串。 </p>
</blockquote>
<p>两个指针比较头尾。要注意只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyht2qfgej31e40diwfz.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &amp;lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(l)))&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(r)))&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-最长回文子串"><a href="#4-2-最长回文子串" class="headerlink" title="4.2 最长回文子串"></a>4.2 最长回文子串</h3><blockquote>
<p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">最长回文子串</a></p>
</blockquote>
<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fuyi05yg94j31eg0eqgnb.jpg" alt=""></p>
<p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index, len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; s.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            PalindromeHelper(s, i, i);</span><br><span class="line">            PalindromeHelper(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(index, index+len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PalindromeHelper</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &amp;gt;= <span class="number">0</span> &amp;&amp; r &amp;lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &amp;lt; r - l - <span class="number">1</span>)&#123;</span><br><span class="line">            index = l + <span class="number">1</span>;</span><br><span class="line">            len = r - l - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-最长回文子序列"><a href="#4-3-最长回文子序列" class="headerlink" title="4.3 最长回文子序列"></a>4.3 最长回文子序列</h3><blockquote>
<p>LeetCode: <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">最长回文子序列</a></p>
</blockquote>
<blockquote>
<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
</blockquote>
<blockquote>
<p><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，&#8221;bbbb&#8221;可以使字符串&#8221;bbbab&#8221;的子序列但不是子串。</strong> </p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fuyo76q586j31eg0r4tb8.jpg" alt=""></p>
<p>动态规划：</p>
<p>dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j)</p>
<p>otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i&amp;gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &amp;lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-字符串的排列"><a href="#5-字符串的排列" class="headerlink" title="5. 字符串的排列"></a>5. 字符串的排列</h3><blockquote>
<p>Leetcode: <a href="https://leetcode-cn.com/problems/permutation-in-string/description/" target="_blank" rel="noopener">字符串的排列</a></p>
</blockquote>
<blockquote>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
</blockquote>
<blockquote>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuyfz1pt9tj31eq0gwjtg.jpg" alt=""></p>
<p>我们不用真的去算出s1的全排列，只要统计字符出现的次数即可。可以使用一个哈希表配上双指针来做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> l2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">if</span>(l1 &amp;gt; l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&amp;lt;l1; i++)&#123;</span><br><span class="line">            count[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(allZero(count))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l1; i&amp;lt;l2; i++)&#123;</span><br><span class="line">            count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">            count[s2.charAt(i-l1) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(allZero(count))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allZero</span><span class="params">(<span class="keyword">int</span> [] count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = count.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-打印字符串的全排列"><a href="#6-打印字符串的全排列" class="headerlink" title="6. 打印字符串的全排列"></a>6. 打印字符串的全排列</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/permutation/" target="_blank" rel="noopener">字符串的排列</a></p>
</blockquote>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 </p>
</blockquote>
<p>把问题拆解成简单的步骤：</p>
<p>第一步求所有可能出现在第一个位置的字符（即把第一个字符和后面的所有字符交换[相同字符不交换]）；</p>
<p>第二步固定第一个字符，求后面所有字符的排列。这时候又可以把后面的所有字符拆成两部分（第一个字符以及剩下的所有字符），依此类推。这样，我们就可以用递归的方法来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;String&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;String&amp;gt; Permutation(String str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PermutationHelper(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(str));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &amp;lt; str.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i &amp;&amp; str[i] == str[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">                PermutationHelper(str, i+<span class="number">1</span>);</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-第一个只出现一次的字符"><a href="#7-第一个只出现一次的字符" class="headerlink" title="7. 第一个只出现一次的字符"></a>7. 第一个只出现一次的字符</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/firstnotrepeatingchar/" target="_blank" rel="noopener">第一个只出现一次的字符</a></p>
</blockquote>
<blockquote>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1. </p>
</blockquote>
<p>先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数。也可以用数组代替hash表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(str.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> value = map.get(str.charAt(i));</span><br><span class="line">                map.put(str.charAt(i), value+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(str.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-翻转单词顺序列"><a href="#8-翻转单词顺序列" class="headerlink" title="8. 翻转单词顺序列"></a>8. 翻转单词顺序列</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/reversesentence/" target="_blank" rel="noopener">翻转单词顺序列</a></p>
</blockquote>
<blockquote>
<p>LeetCode: <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/description/" target="_blank" rel="noopener">翻转字符串里的单词</a> </p>
</blockquote>
<p>借助trim()和 split()就很容易搞定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.trim().length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s.trim();</span><br><span class="line">        String [] temp = s.trim().split(<span class="string">" +"</span>);</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res += temp[i] + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + temp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-旋转字符串"><a href="#9-旋转字符串" class="headerlink" title="9. 旋转字符串"></a>9. 旋转字符串</h3><blockquote>
<p>Leetcode: <a href="https://leetcode-cn.com/problems/rotate-string/description/" target="_blank" rel="noopener">旋转字符串</a></p>
</blockquote>
<blockquote>
<p>给定两个字符串, A 和 B。</p>
</blockquote>
<blockquote>
<p>A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = &#8216;abcde&#8217;，在移动一次之后结果就是&#8217;bcdea&#8217; 。如果在若干次旋转操作之后，A 能变成B，那么返回True。 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fuyp75lk0yj31e60b8dhb.jpg" alt=""></p>
<p>一行代码搞定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.length() == B.length() &amp;&amp; (A+A).contains(B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-1-左旋转字符串"><a href="#9-1-左旋转字符串" class="headerlink" title="9.1 左旋转字符串"></a>9.1 左旋转字符串</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/leftrotatestring/" target="_blank" rel="noopener">左旋转字符串</a></p>
</blockquote>
<blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ </p>
</blockquote>
<p>在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。注意字符串长度为 0 的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        n = n % len;</span><br><span class="line">        String s1 = str.substring(n, len);</span><br><span class="line">        String s2 = str.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> s1+s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-反转字符串"><a href="#9-2-反转字符串" class="headerlink" title="9.2 反转字符串"></a>9.2 反转字符串</h3><blockquote>
<p>LeetCode: <a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">反转字符串</a></p>
</blockquote>
<blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuypdj7b5vj31e40dk75w.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> [] strs = s.toCharArray(); </span><br><span class="line">        <span class="keyword">while</span>(l &amp;lt; r)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = strs[l];</span><br><span class="line">            strs[l] = strs[r];</span><br><span class="line">            strs[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-把字符串转换成整数"><a href="#10-把字符串转换成整数" class="headerlink" title="10. 把字符串转换成整数"></a>10. 把字符串转换成整数</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/strtoint/" target="_blank" rel="noopener">把字符串转换成整数</a></p>
</blockquote>
<blockquote>
<p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'+'</span>)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> start = flag &amp;gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start) &amp;gt; <span class="string">'9'</span> || str.charAt(start) &amp;lt; <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + (str.charAt(start) - <span class="string">'0'</span>);</span><br><span class="line">            start ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">2</span> ? -(<span class="keyword">int</span>)res : (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-正则表达式匹配"><a href="#11-正则表达式匹配" class="headerlink" title="11. 正则表达式匹配"></a>11. 正则表达式匹配</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/match/" target="_blank" rel="noopener">正则表达式匹配</a></p>
</blockquote>
<blockquote>
<p>请实现一个函数用来匹配包括’.’和’&#42;’的正则表达式。模式中的字符’.’表示任意一个字符，而’&#42;’表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab&#42;ac&#42;a”匹配，但是与”aa.a”和”ab*a”均不匹配 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuyqunzeuxj31e40s6jvg.jpg" alt=""></p>
<p>动态规划：</p>
<p>这里我们采用dp[i+1][j+1]代表s[0..i]匹配p[0..j]的结果，结果自然是采用布尔值True/False来表示。</p>
<p>首先，对边界进行赋值，显然dp[0][0] = true，两个空字符串的匹配结果自然为True;</p>
<p>接着，我们对dp[0][j+1]进行赋值，因为 i=0 是空串，如果一个空串和一个匹配串想要匹配成功，那么只有可能是p.charAt(j) == &#8216;*&#8217; &amp;&amp; dp[0][j-1]</p>
<p>之后，就可以愉快地使用动态规划递推方程了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i &amp;lt; p.length(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &amp;lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-表示数值的字符串"><a href="#12-表示数值的字符串" class="headerlink" title="12. 表示数值的字符串"></a>12. 表示数值的字符串</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/isnumeric/" target="_blank" rel="noopener">表示数值的字符串</a></p>
</blockquote>
<blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。 </p>
</blockquote>
<p>设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &amp;gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &amp;lt; <span class="string">'0'</span> || str[i] &amp;gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-字符流中第一个不重复的字符"><a href="#13-字符流中第一个不重复的字符" class="headerlink" title="13. 字符流中第一个不重复的字符"></a>13. 字符流中第一个不重复的字符</h3><blockquote>
<p>剑指offer: <a href="https://www.weiweiblog.cn/firstappearingonce/" target="_blank" rel="noopener">字符流中第一个不重复的字符</a></p>
</blockquote>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 </p>
</blockquote>
<p>用一个哈希表来存储每个字符及其出现的次数，另外用一个字符串 s 来保存字符流中字符的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;Character, Integer&amp;gt;();</span><br><span class="line">    StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s.append(ch);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>String</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法总结] 6 道题搞定 BAT 面试——堆栈和队列</title>
    <url>/stack_and_queue/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于我的个人博客：<a href="https://www.weiweiblog.cn/stack_and_queue/" target="_blank" rel="noopener">尾尾部落</a> </p>
</blockquote>
<h3 id="0-基础概念"><a href="#0-基础概念" class="headerlink" title="0. 基础概念"></a>0. 基础概念</h3><p><strong>栈</strong>：后进先出（LIFO）</p>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fux9mbb808j30bf0640sv.jpg" alt=""></p>
<p><strong>队列</strong>：先进先出（FIFO）</p>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fux9li0phxj30w006pt9d.jpg" alt=""></p>
<h3 id="1-栈的-java-实现"><a href="#1-栈的-java-实现" class="headerlink" title="1. 栈的 java 实现"></a>1. 栈的 java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//栈顶位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> init)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(init &amp;lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            init = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入栈的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == array.length)&#123;</span><br><span class="line">            array = Arrays.copyOf(array, size*<span class="number">2</span>);   <span class="comment">//扩容操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈顶元素，但栈顶元素不出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;  <span class="comment">//空栈</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"栈是空的"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[size-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈，同时获取栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> item = peek();  <span class="comment">//获取栈顶元素</span></span><br><span class="line">        size--;  <span class="comment">//直接使元素个数减1，不用清除元素，下次入栈会覆盖旧元素的值</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-队列的-java-实现"><a href="#2-队列的-java-实现" class="headerlink" title="2. 队列的 java 实现"></a>2. 队列的 java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] queue;  <span class="comment">//声明一个数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入队成功与否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == (tail+<span class="number">1</span>)%queue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[tail] = o;</span><br><span class="line">        tail = (tail+<span class="number">1</span>)%queue.length;  <span class="comment">//tail标记后移一位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队首元素，但不出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            <span class="comment">//队空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue[head];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = queue[head];</span><br><span class="line">        queue[head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == (tail+<span class="number">1</span>)%queue.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail&amp;gt;=head)&#123;</span><br><span class="line">            <span class="keyword">return</span> tail-head;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (tail+queue.length)-head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-用两个栈实现队列"><a href="#3-用两个栈实现队列" class="headerlink" title="3. 用两个栈实现队列"></a>3. 用两个栈实现队列</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">用两个栈实现队列</a></p>
</blockquote>
<blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Implement Queue using Stacks</a> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; input = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; output = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!input.isEmpty())</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.isEmpty() &amp;&amp; output.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-用队列实现栈"><a href="#4-用队列实现栈" class="headerlink" title="4. 用队列实现栈"></a>4. 用队列实现栈</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Implement Stack using Queues</a> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&amp;lt;Integer&amp;gt; q1 = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Queue&amp;lt;Integer&amp;gt; q2 = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.isEmpty())&#123;</span><br><span class="line">            q1.add(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; q2.size(); i++)&#123;</span><br><span class="line">                q1.add(q2.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q2.add(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; q1.size(); i++)&#123;</span><br><span class="line">                q2.add(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() ? q2.poll() : q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() ? q2.peek() : q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-包含min函数的栈"><a href="#5-包含min函数的栈" class="headerlink" title="5. 包含min函数的栈"></a>5. 包含min函数的栈</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">包含min函数的栈</a></p>
</blockquote>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(temp.isEmpty() || temp.peek() &amp;gt;= x)</span><br><span class="line">            temp.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> min = temp.peek();</span><br><span class="line">        <span class="keyword">if</span>(x == min)</span><br><span class="line">            temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temp.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-栈的压入、弹出序列"><a href="#6-栈的压入、弹出序列" class="headerlink" title="6. 栈的压入、弹出序列"></a>6. 栈的压入、弹出序列</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">栈的压入、弹出序列</a></p>
</blockquote>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA, <span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length != popA.length || </span><br><span class="line">               pushA.length == <span class="number">0</span> ||</span><br><span class="line">               popA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法总结] 20 道题搞定 BAT 面试——二叉树</title>
    <url>/20tree/</url>
    <content><![CDATA[<h3 id="0-几个概念"><a href="#0-几个概念" class="headerlink" title="0. 几个概念"></a>0. 几个概念</h3><p>完全二叉树：若二叉树的高度是h，除第h层之外，其他（1<del>h-1）层的节点数都达到了最大个数，并且第h层的节点都连续的集中在最左边。想到点什么没？实际上，完全二叉树和堆联系比较紧密哈</del></p>
<p>满二叉树：除最后一层外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点。</p>
<p>哈夫曼树：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。</p>
<p>二叉排序树：又称二叉查找树（Binary Search Tree），亦称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的节点</li>
</ul>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<p>平衡二叉树：又称 AVL 树。平衡二叉树是二叉搜索树的进化版，所谓平衡二叉树指的是，左右两个子树的高度差的绝对值不超过 1。</p>
<p>红黑树：红黑树是每个节点都带颜色的树，节点颜色或是红色或是黑色，红黑树是一种查找树。红黑树有一个重要的性质，从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍。对于红黑树，插入，删除，查找的复杂度都是O（log N）。</p>
<h3 id="1-求二叉树中的节点个数"><a href="#1-求二叉树中的节点个数" class="headerlink" title="1. 求二叉树中的节点个数"></a>1. 求二叉树中的节点个数</h3><p>递归解法：</p>
<p>（1）如果二叉树为空，节点个数为0</p>
<p>（2）如果不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</p>
<p>参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeNumRec</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">return</span> getNodeNumRec(root.left) + getNodeNumRec(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-求二叉树的最大层数-最大深度"><a href="#2-求二叉树的最大层数-最大深度" class="headerlink" title="2. 求二叉树的最大层数(最大深度)"></a>2. 求二叉树的最大层数(最大深度)</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/treedepth/">二叉树的深度</a></p>
</blockquote>
<blockquote>
<p>递归解法：</p>
</blockquote>
<blockquote>
<p>（1）如果二叉树为空，二叉树的深度为0</p>
</blockquote>
<blockquote>
<p>（2）如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1</p>
</blockquote>
<blockquote>
<p>参考代码如下： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-二叉树的最小深度"><a href="#2-1-二叉树的最小深度" class="headerlink" title="2.1 二叉树的最小深度"></a>2.1 二叉树的最小深度</h3><blockquote>
<p>LeetCode：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a></p>
</blockquote>
<blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
</blockquote>
<blockquote>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuwr1dxogtj31e80ek0u8.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) ? left + right + <span class="number">1</span> : Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-先序遍历-前序遍历"><a href="#3-先序遍历-前序遍历" class="headerlink" title="3. 先序遍历/前序遍历"></a>3. 先序遍历/前序遍历</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Preorder Traversal</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，返回其节点值的前序遍历。 </p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv7z3zzmpj31e20dmgmr.jpg" alt=""></p>
<p><code>根 - 左 - 右</code></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&amp;lt;Integer&amp;gt; preOrderReverse(TreeNode root)&#123;</span><br><span class="line">    ArrayList&amp;lt;Integer&amp;gt; result = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    preOrder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4. 中序遍历"></a>4. 中序遍历</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Inorder Traversal</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，返回其节点值的中序遍历。 </p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv7x8fbwkj31e60dyq43.jpg" alt=""></p>
<p><code>左 - 根 - 右</code></p>
<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-后序遍历"><a href="#5-后序遍历" class="headerlink" title="5. 后序遍历"></a>5. 后序遍历</h3><blockquote>
<p>Leetcode：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，返回其节点值的后序遍历。 </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuv7s7s13wj31e20dogmr.jpg" alt=""></p>
<p><code>左 - 右 - 根</code></p>
<h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root,ArrayList&amp;lt;Integer&amp;gt; result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left, result);</span><br><span class="line">    preOrder(root.right, result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h4><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; ans = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            <span class="comment">//采用逆序插入的方式</span></span><br><span class="line">            ans.addFirst(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode visited = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span> &amp;&amp; cur.right != visited)&#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                    visited = cur;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    cur = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三(推荐)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; result = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Deque&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> ArrayDeque&amp;lt;&amp;gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                result.addFirst(p.val);  <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">                p = p.right;             <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line">                p = node.left;           <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-分层遍历"><a href="#6-分层遍历" class="headerlink" title="6. 分层遍历"></a>6. 分层遍历</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a></p>
</blockquote>
<blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/printfromtoptobottom/">从上往下打印二叉树</a></p>
</blockquote>
<blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/print/">把二叉树打印成多行</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，返回其节点值的级别顺序遍历。 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv7qgpmmhj31ee0jiq4s.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&amp;lt;Integer&amp;gt; level = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">            <span class="keyword">int</span> l = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;l;i++)&#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-自下而上分层遍历"><a href="#6-1-自下而上分层遍历" class="headerlink" title="6.1 自下而上分层遍历"></a>6.1 自下而上分层遍历</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，返回其节点值的自下而上级别顺序遍历。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;count; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次都添加到第一个位置</span></span><br><span class="line">            res.add(<span class="number">0</span>, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-按之字形顺序打印二叉树"><a href="#6-2-按之字形顺序打印二叉树" class="headerlink" title="6.2 按之字形顺序打印二叉树"></a>6.2 按之字形顺序打印二叉树</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/printz/">按之字形顺序打印二叉树</a></p>
</blockquote>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 </p>
</blockquote>
<p>设两个栈，s2存放奇数层，s1存放偶数层</p>
<p>遍历s2节点的同时按照左子树、右子树的顺序加入s1，</p>
<p>遍历s1节点的同时按照右子树、左子树的顺序加入s2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s1 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s2 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        s2.push(pRoot);</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">            temp.clear();</span><br><span class="line">            flag ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-求二叉树第K层的节点个数"><a href="#7-求二叉树第K层的节点个数" class="headerlink" title="7. 求二叉树第K层的节点个数"></a>7. 求二叉树第K层的节点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_k_level_number</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || k &amp;lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_k_level_number(root.left, k-<span class="number">1</span>) + get_k_level_number(root.right, k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-求二叉树第K层的叶子节点个数"><a href="#8-求二叉树第K层的叶子节点个数" class="headerlink" title="8. 求二叉树第K层的叶子节点个数"></a>8. 求二叉树第K层的叶子节点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_k_level_leaf_number</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || k &amp;lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_k_level_number(root.left, k-<span class="number">1</span>) + get_k_level_number(root.right, k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-判断两棵二叉树是否结构相同"><a href="#9-判断两棵二叉树是否结构相同" class="headerlink" title="9. 判断两棵二叉树是否结构相同"></a>9. 判断两棵二叉树是否结构相同</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Same Tree</a></p>
</blockquote>
<blockquote>
<p>给定两个二叉树，编写一个函数来检查它们是否相同。 </p>
</blockquote>
<p>递归解法：</p>
<p>（1）如果两棵二叉树都为空，返回真</p>
<p>（2）如果两棵二叉树一棵为空，另一棵不为空，返回假</p>
<p>（3）如果两棵二叉树都不为空，如果对应的左子树和右子树都同构返回真，其他返回假</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val == q.val)</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-判断二叉树是不是平衡二叉树"><a href="#10-判断二叉树是不是平衡二叉树" class="headerlink" title="10. 判断二叉树是不是平衡二叉树"></a>10. 判断二叉树是不是平衡二叉树</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Balanced Binary Tree</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，确定它是否是高度平衡的。</p>
</blockquote>
<blockquote>
<p>对于此问题，高度平衡二叉树定义为： 一个二叉树，其中每个节点的两个子树的深度差不相差超过1。 </p>
</blockquote>
<p>递归解法：</p>
<p>（1）如果二叉树为空，返回真</p>
<p>（2）如果二叉树不为空，如果左子树和右子树高度相差不大于1且左子树和右子树都是AVL树，返回真，其他返回假</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxHigh(root.left) - maxHigh(root.right)) &amp;lt;= <span class="number">1</span> </span><br><span class="line">            &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHigh</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxHigh(root.left), maxHigh(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-求二叉树的镜像"><a href="#11-求二叉树的镜像" class="headerlink" title="11. 求二叉树的镜像"></a>11. 求二叉树的镜像</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/mirrortree/" target="_blank" rel="noopener">二叉树的镜像</a></p>
</blockquote>
<blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Invert Binary Tree</a></p>
</blockquote>
<blockquote>
<p>反转二叉树 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuv7ea8p94j31ei0jq0u4.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-1-对称二叉树"><a href="#11-1-对称二叉树" class="headerlink" title="11.1 对称二叉树"></a>11.1 对称二叉树</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/issymmetrical/">[剑指offer] 对称的二叉树</a></p>
</blockquote>
<blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Symmetric Tree</a></p>
</blockquote>
<blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuws1gopizj31eo0jwq4x.jpg" alt=""> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || isSymmetricHelper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricHelper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricHelper(left.left, right.right) &amp;&amp; isSymmetricHelper(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-求二叉树中两个节点的最低公共祖先节点"><a href="#12-求二叉树中两个节点的最低公共祖先节点" class="headerlink" title="12. 求二叉树中两个节点的最低公共祖先节点"></a>12. 求二叉树中两个节点的最低公共祖先节点</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a></p>
</blockquote>
<blockquote>
<p>给定二叉树，找到树中两个给定节点的最低共同祖先（LCA）。 </p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv818buisj31du0rgjvi.jpg" alt=""></p>
<p>递归解法：</p>
<p>（1）如果两个节点分别在根节点的左子树和右子树，则返回根节点</p>
<p>（2）如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-1-求二叉搜索树的最近公共祖先"><a href="#12-1-求二叉搜索树的最近公共祖先" class="headerlink" title="12.1 求二叉搜索树的最近公共祖先"></a>12.1 求二叉搜索树的最近公共祖先</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Search Tree</a></p>
</blockquote>
<blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<blockquote>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw3xgeyd0j31dw0r4dk0.jpg" alt=""></p>
<p>注意二叉搜索树的特性：<code>左子树</code> &lt; <code>根节点</code> &lt; <code>右子树</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &amp;gt; p.val &amp;&amp; root.val &amp;gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &amp;lt; p.val &amp;&amp; root.val &amp;lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-求二叉树的直径"><a href="#13-求二叉树的直径" class="headerlink" title="13. 求二叉树的直径"></a>13. 求二叉树的直径</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">Diameter of Binary Tree</a></p>
</blockquote>
<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fuw3a12zjaj31ek0e20ua.jpg" alt=""></p>
<p>递归解法：对于每个节点，它的最长路径等于左子树的最长路径+右子树的最长路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        diamHelper(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">diamHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = diamHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = diamHelper(root.right);</span><br><span class="line">        path = Math.max(path, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-由前序遍历序列和中序遍历序列重建二叉树"><a href="#14-由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="14. 由前序遍历序列和中序遍历序列重建二叉树"></a>14. 由前序遍历序列和中序遍历序列重建二叉树</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/reconstructbinarytree/" target="_blank" rel="noopener">重建二叉树</a></p>
</blockquote>
<blockquote>
<p>LeetCode：<a href="">Construct Binary Tree from Preorder and Inorder Traversal</a></p>
</blockquote>
<blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。 </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw48smh0cj31dw0g6tai.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pre_start, <span class="keyword">int</span> pre_end, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_start &amp;gt; pre_end || in_start &amp;gt; in_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_start]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = in_start; i &amp;lt;= in_end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[pre_start])&#123;</span><br><span class="line">                <span class="comment">// 左子树的长度：i-is</span></span><br><span class="line">                root.left = buildTreeHelper(preorder, pre_start + <span class="number">1</span>, pre_start + i - in_start, inorder, in_start, i - <span class="number">1</span>);</span><br><span class="line">                root.right = buildTreeHelper(preorder, pre_start + i - in_start + <span class="number">1</span>, pre_end, inorder, i + <span class="number">1</span>, in_end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-1-从中序与后序遍历序列构造二叉树"><a href="#14-1-从中序与后序遍历序列构造二叉树" class="headerlink" title="14.1 从中序与后序遍历序列构造二叉树"></a>14.1 从中序与后序遍历序列构造二叉树</h3><blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">Construct Binary Tree from Inorder and Postorder Traversal</a></p>
</blockquote>
<blockquote>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。 </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fuw5432j6cj31dy0goabw.jpg" alt=""></p>
<p>本题与“从前序与中序遍历序列构造二叉树”是一个套路。唯一的区别是，后序序列的最后一个节点是根节点，因此我们要从后序序列的最后一个节点入手，再去中序序列中找到这个节点。在这个节点左侧的属于根节点的左子树部分，右侧的属于根节点右子树部分。然后根据左右子树节点的数量，在后序序列中找到他们各自的后序序列。比左子树节点个数为5，那么在后序序列中前五个节点就是左子树节点，之后的节点除了最后一个节点都是右子树节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> post_start, <span class="keyword">int</span> post_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_start &amp;gt; in_end || post_start &amp;gt; post_end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[post_end]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = in_start; i &amp;lt;= in_end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[post_end])&#123;</span><br><span class="line">                root.left = buildTreeHelper(inorder, in_start, i - <span class="number">1</span>, postorder, post_start, post_start + i - in_start - <span class="number">1</span>);</span><br><span class="line">                root.right = buildTreeHelper(inorder, i + <span class="number">1</span>, in_end, postorder, post_start + i - in_start, post_end - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：根据前序和后序遍历无法构造出唯一的二叉树 </p>
</blockquote>
<h3 id="15-判断二叉树是不是完全二叉树"><a href="#15-判断二叉树是不是完全二叉树" class="headerlink" title="15. 判断二叉树是不是完全二叉树"></a>15. 判断二叉树是不是完全二叉树</h3><p>完全二叉树是指最后一层左边是满的，右边可能慢也不能不满，然后其余层都是满的，根据这个特性，利用层遍历。如果我们当前遍历到了NULL结点，如果后续还有非NULL结点，说明是非完全二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">_CheckCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="keyword">true</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-树的子结构"><a href="#16-树的子结构" class="headerlink" title="16. 树的子结构"></a>16. 树的子结构</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/issubtree/">树的子结构</a></p>
</blockquote>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsSubtree(root1, root2) || </span><br><span class="line">               HasSubtree(root1.left, root2) ||</span><br><span class="line">               HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要先判断roo2, 不然&#123;8,8,7,9,2,#,#,#,#,4,7&#125;,&#123;8,9,2&#125;这个测试用例通不过。</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> IsSubtree(root1.left, root2.left) &amp;&amp; </span><br><span class="line">                IsSubtree(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-二叉树中和为某一值的路径"><a href="#17-二叉树中和为某一值的路径" class="headerlink" title="17. 二叉树中和为某一值的路径"></a>17. 二叉树中和为某一值的路径</h3><blockquote>
<p>剑指offer：<a href="https://www.weiweiblog.cn/findpath/" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></p>
</blockquote>
<blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">    ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        target -= root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            FindPath(root.left, target);</span><br><span class="line">            FindPath(root.right, target);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-二叉树的下一个结点"><a href="#18-二叉树的下一个结点" class="headerlink" title="18. 二叉树的下一个结点"></a>18. 二叉树的下一个结点</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/getnext/">二叉树的下一个结点</a></p>
</blockquote>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode node = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode root = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNode == root.left)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            pNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-序列化二叉树"><a href="#19-序列化二叉树" class="headerlink" title="19. 序列化二叉树"></a>19. 序列化二叉树</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/serialize/">序列化二叉树</a></p>
</blockquote>
<blockquote>
<p>LeetCode：<a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a></p>
</blockquote>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树 </p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuwsmry0fsj31e20f4mym.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer(root.val + <span class="string">","</span>);</span><br><span class="line">        res.append(serialize(root.left));</span><br><span class="line">        res.append(serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String [] d = data.split(<span class="string">","</span>);</span><br><span class="line">        Queue&amp;lt;String&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; d.length; i++)&#123;</span><br><span class="line">            queue.offer(d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pre</span><span class="params">(Queue&amp;lt;String&amp;gt; queue)</span></span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(<span class="string">"#"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        node.left = pre(queue);</span><br><span class="line">        node.right = pre(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-二叉搜索树的第k个结点"><a href="#20-二叉搜索树的第k个结点" class="headerlink" title="20. 二叉搜索树的第k个结点"></a>20. 二叉搜索树的第k个结点</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/kthnode/">二叉搜索树的第k个结点</a></p>
</blockquote>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 </p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuwt2r4qi6j31ec0q0jtp.jpg" alt=""></p>
<p>因为二叉搜索树按照中序遍历的顺序打印出来就是排好序的，所以，我们按照中序遍历找到第k个结点就是题目所求的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span>(count == k)</span><br><span class="line">                    <span class="keyword">return</span> node.val;</span><br><span class="line">                p = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法总结] 17 题！ BAT面试涉及的链表题都在这里了</title>
    <url>/linkedlist_summary/</url>
    <content><![CDATA[<p>链表是面试过程中经常被问到的，这里把剑指offer 和 LeetCode 中的相关题目做一个汇总，方便复习。</p>
<h4 id="1-在-O-1-时间删除链表节点"><a href="#1-在-O-1-时间删除链表节点" class="headerlink" title="1. 在 O(1) 时间删除链表节点"></a>1. 在 O(1) 时间删除链表节点</h4><p><strong>题目描述</strong>：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p>
<p><strong>解题思路</strong>：常规的做法是从链表的头结点开始遍历，找到需要删除的节点的前驱节点，把它的 next 指向要删除节点的下一个节点，平均时间复杂度为O(n)，不满足题目要求。</p>
<p>那是不是一定要得到被删除的节点的前一个节点呢？其实不用的。我们可以很方面地得到要删除节点的下一个节点，如果我们把下一个节点的内容复制到要删除的节点上覆盖原有的内容，再把下一个节点删除，那就相当于把当前要删除的节点删除了。举个栗子，我们要删除的节点i，先把i的下一个节点j的内容复制到i，然后把i的指针指向节点j的下一个节点。此时再删除节点j，其效果刚好是把节点i给删除了。</p>
<p>要注意两种情况：</p>
<ol>
<li>如果链表中只有一个节点，即头节点等于要删除的节点，此时我们在删除节点之后，还需要把链表的头节点设置为NULL。</li>
<li>如果要删除的节点位于链表的尾部，那么它就没有下一个节点，这时我们就要从链表的头节点开始，顺序遍历得到该节点的前序节点，并完成删除操作。</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode toBeDeleted)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果输入参数有空值就返回表头结点  </span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || toBeDeleted == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果删除的是头结点，直接返回头结点的下一个结点  </span></span><br><span class="line">    <span class="keyword">if</span> (head == toBeDeleted) &#123;  </span><br><span class="line">        <span class="keyword">return</span> head.next;  </span><br><span class="line">    &#125;  </span><br><span class="line">      <span class="comment">// 下面的情况链表至少有两个结点  </span></span><br><span class="line">    <span class="comment">// 在多个节点的情况下，如果删除的是最后一个元素  </span></span><br><span class="line">    <span class="keyword">if</span> (toBeDeleted.next == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 找待删除元素的前驱  </span></span><br><span class="line">        ListNode tmp = head;  </span><br><span class="line">        <span class="keyword">while</span> (tmp.next != toBeDeleted) &#123;  </span><br><span class="line">            tmp = tmp.next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 删除待结点  </span></span><br><span class="line">        tmp.next = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 在多个节点的情况下，如果删除的是某个中间结点  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 将下一个结点的值输入当前待删除的结点  </span></span><br><span class="line">        toBeDeleted.value = toBeDeleted.next.value;  </span><br><span class="line">        <span class="comment">// 待删除的结点的下一个指向原先待删除引号的下下个结点，即将待删除的下一个结点删除  </span></span><br><span class="line">        toBeDeleted.next = toBeDeleted.next.next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 返回删除节点后的链表头结点  </span></span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="2-翻转单链表"><a href="#2-翻转单链表" class="headerlink" title="2. 翻转单链表"></a>2. 翻转单链表</h4><p><strong>题目描述</strong>：输出一个单链表的逆序反转后的链表。</p>
<p><strong>解题思路</strong>：用三个临时指针 prev、cur、next 在链表上循环一遍即可。</p>
<blockquote>
<p><a href="https://weiweiblog.cn/printlistfromtailtohead/">[剑指offer] 从尾到头打印链表</a></p>
</blockquote>
<blockquote>
<p><a href="https://weiweiblog.cn/reverselist/">[剑指offer] 反转链表</a> </p>
</blockquote>
<h4 id="3-翻转部分单链表："><a href="#3-翻转部分单链表：" class="headerlink" title="3. 翻转部分单链表："></a>3. 翻转部分单链表：</h4><p><strong>题目描述</strong>：给定一个单向链表的头结点head,以及两个整数from和to,在单链表上把第from个节点和第to个节点这一部分进行反转</p>
<blockquote>
<p>举例：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null, from = 2, to = 4</p>
</blockquote>
<blockquote>
<p>结果：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    ListNode reversedNewHead = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转后的头结点</span></span><br><span class="line">    ListNode reversedTail = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转后的尾结点</span></span><br><span class="line">    ListNode oldHead = head;<span class="comment">// 原链表的头结点</span></span><br><span class="line">    ListNode reversePreNode = <span class="keyword">null</span>;<span class="comment">// 反转部分链表反转前其头结点的前一个结点</span></span><br><span class="line">    ListNode reverseNextNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;gt; n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span>) &#123;</span><br><span class="line">            reversePreNode = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;gt;= m &amp;&amp; i &amp;lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                reversedTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseNextNode = head.next;</span><br><span class="line">            head.next = reversedNewHead;</span><br><span class="line">            reversedNewHead = head;</span><br><span class="line">            head = reverseNextNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    reversedTail.next = reverseNextNode;</span><br><span class="line">    <span class="keyword">if</span> (reversePreNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reversePreNode.next = reversedNewHead;</span><br><span class="line">        <span class="keyword">return</span> oldHead;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reversedNewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-旋转单链表"><a href="#4-旋转单链表" class="headerlink" title="4. 旋转单链表"></a>4. 旋转单链表</h4><p><strong>题目描述</strong>：给定一个单链表，设计一个算法实现链表向右旋转 K 个位置。</p>
<p>举例： 给定 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, K=3</p>
<p>则4-&gt;5-&gt;6-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p><strong>解题思路</strong>：</p>
<ul>
<li><strong>方法一</strong> 双指针，快指针先走k步，然后两个指针一起走，当快指针走到末尾时，慢指针的下一个位置是新的顺序的头结点，这样就可以旋转链表了。</li>
<li><strong>方法二</strong> 先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n &#8211; k % n个节点就到达新链表的头结点前一个点，这时断开链表即可。</li>
</ul>
<p>方法二代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        <span class="keyword">int</span> m = n - k % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; m; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead = cur.next;</span><br><span class="line">        cur.next = NULL;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-删除单链表倒数第-n-个节点"><a href="#5-删除单链表倒数第-n-个节点" class="headerlink" title="5. 删除单链表倒数第 n 个节点"></a>5. 删除单链表倒数第 n 个节点</h4><p><strong>题目描述</strong>：删除单链表倒数第 n 个节点，1 &lt;= n &lt;= length，尽量在一次遍历中完成。</p>
<p><strong>解题思路</strong>：双指针法，找到倒数第 n+1 个节点，将它的 next 指向倒数第 n-1个节点。</p>
<blockquote>
<p><a href="https://weiweiblog.cn/findkthtotail/">[剑指offer] 链表中倒数第k个结点</a> </p>
</blockquote>
<h4 id="6-求单链表的中间节点"><a href="#6-求单链表的中间节点" class="headerlink" title="6. 求单链表的中间节点"></a>6. 求单链表的中间节点</h4><p><strong>题目描述</strong>：求单链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>
<p><strong>解题思路</strong>：快慢指针，慢的走一步，快的走两步，当快指针到达尾节点时，慢指针移动到中间节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历一次，找出单链表的中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMiddleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-链表划分"><a href="#7-链表划分" class="headerlink" title="7. 链表划分"></a>7. 链表划分</h4><p><strong>题目描述</strong>： 给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head: The first node of linked list.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x: an integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: a ListNode </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode left = leftDummy, right = rightDummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &amp;lt; x) &#123;</span><br><span class="line">                left.next = head;</span><br><span class="line">                left = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.next = head;</span><br><span class="line">                right = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right.next = <span class="keyword">null</span>;</span><br><span class="line">        left.next = rightDummy.next;</span><br><span class="line">        <span class="keyword">return</span> leftDummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-链表求和"><a href="#8-链表求和" class="headerlink" title="8. 链表求和"></a>8. 链表求和</h4><p><strong>题目描述</strong>：你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p>
<p><strong>解题思路</strong>：做个大循环，对每一位进行操作：</p>
<blockquote>
<p>当前位：(A[i]+B[i])%10</p>
</blockquote>
<blockquote>
<p>进位：（A[i]+B[i]）/10 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode c1 = l1;</span><br><span class="line">        ListNode c2 = l2;</span><br><span class="line">        ListNode sentinel = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode d = sentinel;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (c1 != <span class="keyword">null</span> || c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (c1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum += c1.val;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sum += c2.val;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            d = d.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum / <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-单链表排序"><a href="#9-单链表排序" class="headerlink" title="9. 单链表排序"></a>9. 单链表排序</h4><p><strong>题目描述</strong>：在O(nlogn)时间内对链表进行排序。</p>
<p><strong>快速排序</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用快速排序</span></span><br><span class="line">   quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != end) &#123;</span><br><span class="line">        ListNode node = partion(head, end);</span><br><span class="line">        quickSort(head, node);</span><br><span class="line">        quickSort(node.next, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partion</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head, p2 = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到末尾才停</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != end) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于key值时，p1向前走一步，交换p1与p2的值</span></span><br><span class="line">        <span class="keyword">if</span> (p2.val &amp;lt; head.val) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有序时，不交换p1和key值</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != head) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        head.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>归并排序</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用归并排序</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取中间结点</span></span><br><span class="line">    ListNode mid = getMid(head);</span><br><span class="line">    ListNode right = mid.next;</span><br><span class="line">    mid.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">return</span> mergeSort(sortList(head), sortList(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的中间结点,偶数时取中间第一个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    ListNode slow = head, quick = head;</span><br><span class="line">    <span class="comment">//快2步，慢一步</span></span><br><span class="line">    <span class="keyword">while</span> (quick.next != <span class="keyword">null</span> &amp;&amp; quick.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 归并两个有序的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head1, p2 = head2, head;</span><br><span class="line">   <span class="comment">//得到头节点的指向</span></span><br><span class="line">    <span class="keyword">if</span> (head1.val &amp;lt; head2.val) &#123;</span><br><span class="line">        head = head1;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//比较链表中的值</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1.val &amp;lt;= p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一条链表空了</span></span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-合并两个排序的链表"><a href="#10-合并两个排序的链表" class="headerlink" title="10. 合并两个排序的链表"></a>10. 合并两个排序的链表</h4><p><strong>题目描述</strong>：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<blockquote>
<p><a href="https://weiweiblog.cn/mergelinklist/">[剑指offer] 合并两个排序的链表</a> </p>
</blockquote>
<h4 id="11-复杂链表的复制"><a href="#11-复杂链表的复制" class="headerlink" title="11. 复杂链表的复制"></a>11. 复杂链表的复制</h4><p><strong>题目描述</strong>：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<blockquote>
<p><a href="https://weiweiblog.cn/clonelink/">[剑指offer] 复杂链表的复制</a> </p>
</blockquote>
<h4 id="12-删除链表中重复的结点"><a href="#12-删除链表中重复的结点" class="headerlink" title="12. 删除链表中重复的结点"></a>12. 删除链表中重复的结点</h4><p><strong>题目描述</strong>：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<blockquote>
<p><a href="https://weiweiblog.cn/deleteduplication/">[剑指offer] 删除链表中重复的结点</a> </p>
</blockquote>
<h4 id="13-判断单链表是否存在环"><a href="#13-判断单链表是否存在环" class="headerlink" title="13. 判断单链表是否存在环"></a>13. 判断单链表是否存在环</h4><p><strong>题目描述</strong>：判断一个单链表是否有环</p>
<p>分析：快慢指针，慢指针每次移动一步，快指针每次移动两步，如果存在环，那么两个指针一定会在环内相遇。</p>
<h4 id="14-单链表是否有环扩展：找到环的入口点"><a href="#14-单链表是否有环扩展：找到环的入口点" class="headerlink" title="14. 单链表是否有环扩展：找到环的入口点"></a>14. 单链表是否有环扩展：找到环的入口点</h4><p><strong>题目描述</strong>：判断单链表是否有环，如果有，找到环的入口点</p>
<p><strong>解题思路</strong>：在第 5 题两个指针相遇后，让其中一个指针回到链表的头部，另一个指针在原地，同时往前每次走一步，当它们再次相遇时，就是在环路的入口点。</p>
<blockquote>
<p><a href="https://weiweiblog.cn/entrynodeofloop/">[剑指offer] 链表中环的入口结点</a> </p>
</blockquote>
<h4 id="15-判断两个无环单链表是否相交"><a href="#15-判断两个无环单链表是否相交" class="headerlink" title="15. 判断两个无环单链表是否相交"></a>15. 判断两个无环单链表是否相交</h4><p><strong>题目描述</strong>：给出两个无环单链表</p>
<p><strong>解题思路</strong>：</p>
<ul>
<li><strong>方法一</strong> 最直接的方法是判断 A 链表的每个节点是否在 B 链表中，但是这种方法的时间复杂度为 O(Length(A) * Length(B))。</li>
<li><strong>方法二</strong> 转化为环的问题。把 B 链表接在 A 链表后面，如果得到的链表有环，则说明两个链表相交。可以之前讨论过的快慢指针来判断是否有环，但是这里还有更简单的方法。如果 B 链表和 A 链表相交，把 B 链表接在 A 链表后面时，B 链表的所有节点都在环内，所以此时只需要遍历 B 链表，看是否会回到起点就可以判断是否相交。这个方法需要先遍历一次 A 链表，找到尾节点，然后还要遍历一次 B 链表，判断是否形成环，时间复杂度为 O(Length(A) + Length(B))。</li>
<li><strong>方法三</strong> 除了转化为环的问题，还可以利用“如果两个链表相交于某一节点，那么之后的节点都是共有的”这个特点，如果两个链表相交，那么最后一个节点一定是共有的。所以可以得出另外一种解法，先遍历 A 链表，记住尾节点，然后遍历 B 链表，比较两个链表的尾节点，如果相同则相交，不同则不相交。时间复杂度为 O(Length(A) + Length(B))，空间复杂度为 O(1)，思路比解法 2 更简单。</li>
</ul>
<p>方法三的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIntersect</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == headA || <span class="keyword">null</span> == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != headA.next) &#123;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != headB.next) &#123;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headA == headB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-两个链表相交扩展：求两个无环单链表的第一个相交点"><a href="#16-两个链表相交扩展：求两个无环单链表的第一个相交点" class="headerlink" title="16. 两个链表相交扩展：求两个无环单链表的第一个相交点"></a>16. 两个链表相交扩展：求两个无环单链表的第一个相交点</h4><p><strong>题目描述</strong>：找到两个无环单链表第一个相交点，如果不相交返回空，要求在线性时间复杂度和常量空间复杂度内完成。</p>
<p><strong>解题思路</strong>：</p>
<ul>
<li><strong>方法一</strong> 如果两个链表存在公共结点，那么它们从公共结点开始一直到链表的结尾都是一样的，因此我们只需要从链表的结尾开始，往前搜索，找到最后一个相同的结点即可。但是题目给出的单向链表，我们只能从前向后搜索，这时，我们就可以借助栈来完成。先把两个链表依次装到两个栈中，然后比较两个栈的栈顶结点是否相同，如果相同则出栈，如果不同，那最后相同的结点就是我们要的返回值。</li>
<li><strong>方法二</strong> 先找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走，直到找到第一个公共结点。</li>
<li><strong>方法三</strong> 由于2个链表都没有环，我们可以把第二个链表接在第一个链表后面，这样就把问题转化为求环的入口节点问题。</li>
<li><strong>方法四</strong> 两个指针p1和p2分别指向链表A和链表B，它们同时向前走，当走到尾节点时，转向另一个链表，比如p1走到链表 A 的尾节点时，下一步就走到链表B，p2走到链表 B 的尾节点时，下一步就走到链表 A，当p1==p2 时，就是链表的相交点</li>
</ul>
<p>方法四的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == headA || <span class="keyword">null</span> == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    ListNode p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 遍历完所在链表后从另外一个链表再开始</span></span><br><span class="line">        <span class="comment">// 当 p1 和 p2 都换到另一个链表时，它们对齐了：</span></span><br><span class="line">        <span class="comment">// （1）如果链表相交，p1 == p2 时为第一个相交点</span></span><br><span class="line">        <span class="comment">// （2）如果链表不相交，p1 和 p2 同时移动到末尾，p1 = p2 = null，然后退出循环</span></span><br><span class="line">        p1 = (<span class="keyword">null</span> == p1) ? headB : p1.next;</span><br><span class="line">        p2 = (<span class="keyword">null</span> == p2) ? headA : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://weiweiblog.cn/findfirstcommonnode/">[剑指offer] 两个链表的第一个公共结点</a> </p>
</blockquote>
<h4 id="17-两个链表相交扩展：判断两个有环单链表是否相交"><a href="#17-两个链表相交扩展：判断两个有环单链表是否相交" class="headerlink" title="17. 两个链表相交扩展：判断两个有环单链表是否相交"></a>17. 两个链表相交扩展：判断两个有环单链表是否相交</h4><p><strong>题目描述</strong>：上面的问题是针对无环链表的，如果是链表有环呢？</p>
<p><strong>解题思路</strong>：如果两个有环单链表相交，那么它们一定共有一个环，即环上的任意一个节点都存在于两个链表上。因此可以先用之前快慢指针的方式找到两个链表中位于环内的两个节点，如果相交的话，两个节点在一个环内，那么移动其中一个节点，在一次循环内肯定可以与另外一个节点相遇。</p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法总结] 十大排序算法</title>
    <url>/10sort/</url>
    <content><![CDATA[<p>排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。</p>
<p>下面介绍几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序的思想，其代码均采用Java实现。</p>
<h3 id="1-冒泡排序-O-n-2"><a href="#1-冒泡排序-O-n-2" class="headerlink" title="1. 冒泡排序 $O(n^2)$"></a>1. 冒泡排序 $O(n^2)$</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/640.gif" alt="冒泡排序"></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &amp;gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop j</span></span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;<span class="comment">// method bubbleSort</span></span><br></pre></td></tr></table></figure>

<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n^2 )。因此，算法在数据基本有序的情况下，性能最好。</p>
<p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &amp;gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        swap=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &amp;gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swap=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop j</span></span><br><span class="line">        <span class="keyword">if</span> (swap==<span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;<span class="comment">// method bubbleSort</span></span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序-O-n-2"><a href="#2-选择排序-O-n-2" class="headerlink" title="2. 选择排序 $O(n^2)$"></a>2. 选择排序 $O(n^2)$</h3><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/640-1.gif" alt="选择排序"></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="comment">// 循环查找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &amp;lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &amp;gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><p>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。</p>
<p>不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是不稳定的。</p>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n^2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p>
<h3 id="3-插入排序-O-n-2"><a href="#3-插入排序-O-n-2" class="headerlink" title="3. 插入排序 $O(n^2)$"></a>3. 插入排序 $O(n^2)$</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。</li>
<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。</li>
<li>重复上述过程直到最后一个元素被插入有序子数组中。</li>
</ol>
<h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/849589-20171015225645277-1151100000.gif" alt="插入排序"></p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> position=i;</span><br><span class="line">        <span class="keyword">while</span> (position&amp;gt;<span class="number">0</span> &amp;&amp; arr[position-<span class="number">1</span>]&amp;gt;value)&#123;</span><br><span class="line">            arr[position] = arr[position-<span class="number">1</span>];</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[position] = value;</span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法。</p>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>插入排序由于O( n^2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</p>
<h3 id="4-归并排序-O-N-logN"><a href="#4-归并排序-O-N-logN" class="headerlink" title="4. 归并排序 $O(N*logN)$"></a>4. 归并排序 $O(N*logN)$</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>两种方法</p>
<ul>
<li>递归法（Top-down）</li>
</ul>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<ul>
<li>迭代法（Bottom-up）</li>
</ul>
<p>原理如下（假设序列共有n个元素）：</p>
<ol>
<li>将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ol>
<h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp =<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    internalMergeSort(arr, temp, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalMergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">    <span class="keyword">if</span> (left&amp;lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        internalMergeSort(arr, temp, left, middle);          <span class="comment">//左子数组</span></span><br><span class="line">        internalMergeSort(arr, temp, middle+<span class="number">1</span>, right);       <span class="comment">//右子数组</span></span><br><span class="line">        mergeSortedArray(arr, temp, left, middle, right);    <span class="comment">//合并两个子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序子序列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortedArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=left;      </span><br><span class="line">    <span class="keyword">int</span> j=middle+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&amp;lt;=middle &amp;&amp; j&amp;lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[i] &amp;lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &amp;lt;=middle)&#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&amp;lt;=right)&#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&amp;lt;k; ++i)&#123;</span><br><span class="line">        arr[left+i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h4><p>因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。</p>
<h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p>
<h3 id="5-快速排序-O-N-logN"><a href="#5-快速排序-O-N-logN" class="headerlink" title="5. 快速排序 $O(N*logN)$"></a>5. 快速排序 $O(N*logN)$</h3><p>快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。</p>
<h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>从数列中挑出一个元素，称为&#8221;基准&#8221;（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &amp;gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(arr, low, high);        <span class="comment">//将数组分为两部分</span></span><br><span class="line">    qsort(arr, low, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></span><br><span class="line">    qsort(arr, pivot+<span class="number">1</span>, high);                  <span class="comment">//递归排序右子数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];     <span class="comment">//基准</span></span><br><span class="line">    <span class="keyword">while</span> (low &amp;lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &amp;lt; high &amp;&amp; arr[high] &amp;gt;= pivot) --high;</span><br><span class="line">        arr[low]=arr[high];             <span class="comment">//交换比基准大的记录到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &amp;lt; high &amp;&amp; arr[low] &amp;lt;= pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];           <span class="comment">//交换比基准小的记录到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描完成，基准到位</span></span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="comment">//返回的是基准的位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h4><p>快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p>
<h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h4><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p>
<h3 id="6-堆排序-O-N-logN"><a href="#6-堆排序-O-N-logN" class="headerlink" title="6. 堆排序 $O(N*logN)$"></a>6. 堆排序 $O(N*logN)$</h3><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p>
<h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><p>关于树的概念请参考：<a href="">[算法总结] 二叉树</a></p>
<h4 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h4><p>堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p>
<p>如下图，是一个堆和数组的相互关系：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fufzubvoquj30fo052dga.jpg" alt=""></p>
<p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<p>二叉堆一般分为两种：最大堆和最小堆。</p>
<p><strong>最大堆：</strong></p>
<p>最大堆中的最大元素值出现在根结点（堆顶）</p>
<p>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fug00fssjwj30ad034q35.jpg" alt=""></p>
<p><strong>最小堆：</strong></p>
<p>最小堆中的最小元素值出现在根结点（堆顶）</p>
<p>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fug00saf77j30aa034mxd.jpg" alt=""></p>
<h4 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h4><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p>
<ul>
<li><p>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p>
</li>
<li><p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</p>
</li>
<li><p>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p>
<p>继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变</p>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fug05te8saj30fm05eaah.jpg" alt=""></p>
<p>相应的，几个计算公式也要作出相应调整：</p>
<ul>
<li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li>
<li>Left(i) = 2i + 1，i 的左子节点下标</li>
<li>Right(i) = 2(i + 1)，i 的右子节点下标</li>
</ul>
<h4 id="堆的建立和维护"><a href="#堆的建立和维护" class="headerlink" title="堆的建立和维护"></a>堆的建立和维护</h4><p>堆可以支持多种操作，但现在我们关心的只有两个问题：</p>
<ol>
<li>给定一个无序数组，如何建立为堆？</li>
<li>删除堆顶元素后，如何调整数组成为新堆？</li>
</ol>
<p>先看第二个问题。假定我们已经有一个现成的大根堆。现在我们删除了根元素，但并没有移动别的元素。想想发生了什么：根元素空了，但其它元素还保持着堆的性质。我们可以把<strong>最后一个元素</strong>（代号A）移动到根元素的位置。如果不是特殊情况，则堆的性质被破坏。但这仅仅是由于A小于其某个子元素。于是，我们可以把A和这个子元素调换位置。如果A大于其所有子元素，则堆调整好了；否则，重复上述过程，A元素在树形结构中不断“下沉”，直到合适的位置，数组重新恢复堆的性质。上述过程一般称为“筛选”，方向显然是自上而下。</p>
<blockquote>
<p>删除后的调整，是把最后一个元素放到堆顶，自上而下比较 </p>
</blockquote>
<p>删除一个元素是如此，插入一个新元素也是如此。不同的是，我们把新元素放在<strong>末尾</strong>，然后和其父节点做比较，即自下而上筛选。</p>
<blockquote>
<p>插入是把新元素放在末尾，自下而上比较 </p>
</blockquote>
<p>那么，第一个问题怎么解决呢？</p>
<p>常规方法是从第一个非叶子结点向下筛选，直到根元素筛选完毕。这个方法叫“筛选法”，需要循环筛选n/2个元素。</p>
<p>但我们还可以借鉴“插入排序”的思路。我们可以视第一个元素为一个堆，然后不断向其中添加新元素。这个方法叫做“插入法”，需要循环插入(n-1)个元素。</p>
<p>由于筛选法和插入法的方式不同，所以，相同的数据，它们建立的堆一般不同。大致了解堆之后，堆排序就是水到渠成的事情了。</p>
<h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt=""></p>
<h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>我们需要一个升序的序列，怎么办呢？我们可以建立一个最小堆，然后每次输出根元素。但是，这个方法需要额外的空间（否则将造成大量的元素移动，其复杂度会飙升到O(n^2) ）。如果我们需要就地排序（即不允许有O(n)空间复杂度），怎么办？</p>
<p>有办法。我们可以建立最大堆，然后我们倒着输出，在最后一个位置输出最大值，次末位置输出次大值……由于每次输出的最大元素会腾出第一个空间，因此，我们恰好可以放置这样的元素而不需要额外空间。很漂亮的想法，是不是？</p>
<h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLeftChildIndex</span><span class="params">(<span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整堆。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right, j;</span><br><span class="line">        left = getLeftChildIndex(i);</span><br><span class="line">        <span class="keyword">while</span> (left &amp;lt;= len) &#123;</span><br><span class="line">            right = left + <span class="number">1</span>;</span><br><span class="line">            j = left;</span><br><span class="line">            <span class="keyword">if</span> (j &amp;lt; len &amp;&amp; arr[left] &amp;lt; arr[right]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &amp;lt; arr[j]) &#123;</span><br><span class="line">                swap(array, i, j);</span><br><span class="line">                i = j;</span><br><span class="line">                left = getLeftChildIndex(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 停止筛选</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = getParentIndex(last); i &amp;gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjustHeap(i, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆调整</span></span><br><span class="line">        <span class="keyword">while</span> (last &amp;gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            swap(<span class="number">0</span>, last--);</span><br><span class="line">            adjustHeap(<span class="number">0</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-5"><a href="#稳定性-5" class="headerlink" title="稳定性"></a>稳定性</h4><p>堆排序存在大量的筛选和移动过程，属于不稳定的排序算法。</p>
<h4 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h4><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>
<h3 id="7-希尔排序（插入排序的改良版）-O-N-logN"><a href="#7-希尔排序（插入排序的改良版）-O-N-logN" class="headerlink" title="7. 希尔排序（插入排序的改良版）$O(N*logN)$"></a>7. 希尔排序（插入排序的改良版）$O(N*logN)$</h3><p>在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：</p>
<ol>
<li>插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。</li>
<li>但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。</li>
</ol>
<h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt=""></p>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><p>Donald Shell增量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> delta = arr.length/<span class="number">2</span>; delta&amp;gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;                              <span class="comment">//对每个增量进行一次排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=delta; i&amp;lt;arr.length; i++)&#123;              </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&amp;gt;=delta &amp;&amp; arr[j]&amp;lt;arr[j-delta]; j-=delta)&#123; <span class="comment">//注意每个地方增量和差值都是delta</span></span><br><span class="line">                temp = arr[j-delta];</span><br><span class="line">                arr[j-delta] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop i</span></span><br><span class="line">    &#125;<span class="comment">//loop delta</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>O(n^(3/2)) by Knuth</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (delta &amp;lt; arr.length/<span class="number">3</span>)&#123;<span class="comment">//generate delta</span></span><br><span class="line">        delta=delta*<span class="number">3</span>+<span class="number">1</span>;    <span class="comment">// &amp;lt;O(n^(3/2)) by Knuth,1973&amp;gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; delta&amp;gt;=<span class="number">1</span>; delta/=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=delta; i&amp;lt;arr.length; i++)&#123;              </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&amp;gt;=delta &amp;&amp; arr[j]&amp;lt;arr[j-delta]; j-=delta)&#123;</span><br><span class="line">                temp = arr[j-delta];</span><br><span class="line">                arr[j-delta] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop i</span></span><br><span class="line">    &#125;<span class="comment">//loop delta</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序的增量"><a href="#希尔排序的增量" class="headerlink" title="希尔排序的增量"></a>希尔排序的增量</h4><p>希尔排序的增量数列可以任取，需要的唯一条件是最后一个一定为1（因为要保证按1有序）。但是，不同的数列选取会对算法的性能造成极大的影响。上面的代码演示了两种增量。</p>
<p>切记：增量序列中每两个元素最好不要出现1以外的公因子！（很显然，按4有序的数列再去按2排序意义并不大）。</p>
<p>下面是一些常见的增量序列。</p>
<p>&#8211; 第一种增量是最初Donald Shell提出的增量，即折半降低直到1。据研究，使用希尔增量，其时间复杂度还是O(n2)。</p>
<p>第二种增量Hibbard：{1, 3, &#8230;, 2^k-1}。该增量序列的时间复杂度大约是O(n^1.5)。</p>
<p>第三种增量Sedgewick增量：(1, 5, 19, 41, 109,&#8230;)，其生成序列或者是9_4^i &#8211; 9_2^i + 1或者是4^i &#8211; 3*2^i + 1。</p>
<h4 id="稳定性-6"><a href="#稳定性-6" class="headerlink" title="稳定性"></a>稳定性</h4><p>我们都知道插入排序是稳定算法。但是，Shell排序是一个多次插入的过程。在一次插入中我们能确保不移动相同元素的顺序，但在多次的插入中，相同元素完全有可能在不同的插入轮次被移动，最后稳定性被破坏，因此，Shell排序不是一个稳定的算法。</p>
<h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h4><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀&#8211;快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p>
<h3 id="计数排序-O-n-k"><a href="#计数排序-O-n-k" class="headerlink" title="计数排序 $O(n+k)$"></a>计数排序 $O(n+k)$</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ol>
<h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt=""></p>
<h4 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//存储数组</span></span><br><span class="line">     <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];<span class="comment">//计数数组</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num = min; num &amp;lt;= max; num++) &#123;</span><br><span class="line">        <span class="comment">//初始化各元素值为0，数组下标从0开始因此减min</span></span><br><span class="line">        count[num - min] = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = a[i];</span><br><span class="line">        count[num - min]++;<span class="comment">//每出现一个值，计数数组对应元素的值+1</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> num = min + <span class="number">1</span>; num &amp;lt;= max; num++) &#123;</span><br><span class="line">        <span class="comment">//加总数组元素的值为计数数组对应元素及左边所有元素的值的总和</span></span><br><span class="line">        count[num - min] += count[num - min - <span class="number">1</span>]</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; a.length; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> num = a[i];<span class="comment">//源数组第i位的值</span></span><br><span class="line">          <span class="keyword">int</span> index = count[num - min] - <span class="number">1</span>;<span class="comment">//加总数组中对应元素的下标</span></span><br><span class="line">          b[index] = num;<span class="comment">//将该值存入存储数组对应下标中</span></span><br><span class="line">          count[num - min]--;<span class="comment">//加总数组中，该值的总和减少1。</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//将存储数组的值一一替换给源数组</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;a.length;i++)&#123;</span><br><span class="line">         a[i] = b[i];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-7"><a href="#稳定性-7" class="headerlink" title="稳定性"></a>稳定性</h4><p>最后给 b 数组赋值是倒着遍历的，而且放进去一个就将C数组对应的值（表示前面有多少元素小于或等于A[i]）减去一。如果有相同的数x1,x2，那么相对位置后面那个元素x2放在（比如下标为4的位置），相对位置前面那个元素x1下次进循环就会被放在x2前面的位置3。从而保证了稳定性。</p>
<h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h4><p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p>
<blockquote>
<p>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。网络中很多博文写的桶排序实际上都是计数排序，并非标准的桶排序，要注意辨别。 </p>
</blockquote>
<h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>找出待排序数组中的最大值max、最小值min</li>
<li>我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1</li>
<li>遍历数组 arr，计算每个元素 arr[i] 放的桶</li>
<li>每个桶各自排序</li>
<li>遍历桶数组，把排序好的元素放进输出数组</li>
</ol>
<h4 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuhazwnaezj30rp0q4go7.jpg" alt=""></p>
<h4 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(bucketArr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-8"><a href="#稳定性-8" class="headerlink" title="稳定性"></a>稳定性</h4><p>可以看出，在分桶和从桶依次输出的过程是稳定的。但是，由于我们在对每个桶进行排序时使用了其他算法，所以，桶排序的稳定性依赖于这一步。如果我们使用了快排，显然，算法是不稳定的。</p>
<h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h4><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<h4 id="动图"><a href="#动图" class="headerlink" title="动图"></a>动图</h4><p><img src="https://www.weiweiblog.cn/wp-content/uploads/2018/08/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt=""></p>
<h4 id="算法实现-9"><a href="#算法实现-9" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSorter</span> <span class="keyword">extends</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> radix;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">RadixSorter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          radix = <span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 数组的第一维表示可能的余数0-radix，第二维表示array中的等于该余数的元素</span></span><br><span class="line">          <span class="comment">// 如：十进制123的个位为3，则bucket[3][] = &#123;123&#125;</span></span><br><span class="line">          <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[radix][array.length];</span><br><span class="line">          <span class="keyword">int</span> distance = getDistance(array); <span class="comment">// 表示最大的数有多少位</span></span><br><span class="line">          <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> round = <span class="number">1</span>; <span class="comment">// 控制键值排序依据在哪一位</span></span><br><span class="line">          <span class="keyword">while</span> (round &amp;lt;= distance) &#123;</span><br><span class="line">               <span class="comment">// 用来计数：数组counter[i]用来表示该位是i的数的个数</span></span><br><span class="line">               <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[radix];</span><br><span class="line">               <span class="comment">// 将array中元素分布填充到bucket中，并进行计数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> which = (array[i] / temp) % radix;</span><br><span class="line">                    bucket[which][counter[which]] = array[i];</span><br><span class="line">                    counter[which]++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">// 根据bucket中收集到的array中的元素，根据统计计数，在array中重新排列</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; radix; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counter[i] != <span class="number">0</span>)</span><br><span class="line">                         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; counter[i]; j++) &#123;</span><br><span class="line">                              array[index] = bucket[i][j];</span><br><span class="line">                              index++;</span><br><span class="line">                         &#125;</span><br><span class="line">                    counter[i] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               temp *= radix;</span><br><span class="line">               round++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> max = computeMax(array);</span><br><span class="line">          <span class="keyword">int</span> digits = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> temp = max / radix;</span><br><span class="line">          <span class="keyword">while</span>(temp != <span class="number">0</span>) &#123;</span><br><span class="line">               digits++;</span><br><span class="line">               temp = temp / radix;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> digits + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeMax</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;array.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(array[i]&amp;gt;max) &#123;</span><br><span class="line">                    max = array[i];</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定性-9"><a href="#稳定性-9" class="headerlink" title="稳定性"></a>稳定性</h4><p>通过上面的排序过程，我们可以看到，每一轮映射和收集操作，都保持从左到右的顺序进行，如果出现相同的元素，则保持他们在原始数组中的顺序。可见，基数排序是一种稳定的排序。</p>
<h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h4><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuhcs1ji9yj30qc0qm43d.jpg" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li>LeetCode领扣:<a href="https://mp.weixin.qq.com/s/VX9LwTK77RUPLBFHPS1Z1A" target="_blank" rel="noopener">面试 | 常用的排序算法总结</a></li>
<li>飞翔的猫咪: <a href="http://blog.51cto.com/flyingcat2013" target="_blank" rel="noopener">用Java写算法</a></li>
<li>bubkoo: <a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法</a></li>
</ol>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>基数排序</tag>
        <tag>堆排序</tag>
        <tag>希尔排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>排序算法</tag>
        <tag>插入排序</tag>
        <tag>桶排序</tag>
        <tag>计数排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] JAVA版题解（完整版）</title>
    <url>/jzoffer_java/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">题解</th>
<th align="center">牛客 OJ</th>
<th align="center">数据结构类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">03</td>
<td align="center"><a href="https://www.weiweiblog.cn/find2array/" target="_blank" rel="noopener">[剑指offer] 二维数组中的查找</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">二维数组中的查找</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center"><a href="https://www.weiweiblog.cn/replacespace/" target="_blank" rel="noopener">[剑指offer] 替换空格</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">替换空格</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">05</td>
<td align="center"><a href="https://www.weiweiblog.cn/printlistfromtailtohead/" target="_blank" rel="noopener">[剑指offer] 从尾到头打印链表</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从尾到头打印链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">06</td>
<td align="center"><a href="https://www.weiweiblog.cn/reconstructbinarytree/" target="_blank" rel="noopener">[剑指offer] 重建二叉树</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">重建二叉树</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">07</td>
<td align="center"><a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">[剑指offer] 用两个栈实现队列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">用两个栈实现队列</a></td>
<td align="center">栈、队列</td>
</tr>
<tr>
<td align="center">08</td>
<td align="center"><a href="https://www.weiweiblog.cn/minnumberinrotatearray/" target="_blank" rel="noopener">[剑指offer] 旋转数组的最小数字</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">旋转数组的最小数字</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">09</td>
<td align="center"><a href="https://www.weiweiblog.cn/fibonacci/" target="_blank" rel="noopener">[剑指offer] 斐波那契数列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">斐波那契数列</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="https://www.weiweiblog.cn/numberof1/" target="_blank" rel="noopener">[剑指offer] 二进制中1的个数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二进制中1的个数</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="https://www.weiweiblog.cn/power/" target="_blank" rel="noopener">[剑指offer] 数值的整数次方</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数值的整数次方</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="https://www.weiweiblog.cn/reorderarray/" target="_blank" rel="noopener">[剑指offer] 调整数组顺序使奇数位于偶数前面</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">调整数组顺序使奇数位于偶数前面</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="https://www.weiweiblog.cn/findkthtotail/" target="_blank" rel="noopener">[剑指offer] 链表中倒数第k个结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">链表中倒数第k个结点</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="https://www.weiweiblog.cn/reverselist/" target="_blank" rel="noopener">[剑指offer] 反转链表</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">反转链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="https://www.weiweiblog.cn/mergelinklist/" target="_blank" rel="noopener">[剑指offer] 合并两个排序的链表</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">合并两个排序的链表</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="https://www.weiweiblog.cn/issubtree/" target="_blank" rel="noopener">[剑指offer] 树的子结构</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">树的子结构</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="https://www.weiweiblog.cn/mirrortree/" target="_blank" rel="noopener">[剑指offer] 二叉树的镜像</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的镜像</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="https://www.weiweiblog.cn/printmatrix/" target="_blank" rel="noopener">[剑指offer] 顺时针打印矩阵</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">顺时针打印矩阵</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">[剑指offer] 包含min函数的栈</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">包含min函数的栈</a></td>
<td align="center">栈</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">[剑指offer] 栈的压入、弹出序列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">栈的压入、弹出序列</a></td>
<td align="center">栈</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="https://www.weiweiblog.cn/printfromtoptobottom/" target="_blank" rel="noopener">[剑指offer] 从上往下打印二叉树</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从上往下打印二叉树</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="https://www.weiweiblog.cn/verifysquenceofbst/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树的后序遍历序列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="https://www.weiweiblog.cn/findpath/" target="_blank" rel="noopener">[剑指offer] 二叉树中和为某一值的路径</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="https://www.weiweiblog.cn/clonelink/" target="_blank" rel="noopener">[剑指offer] 复杂链表的复制</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">复杂链表的复制</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="https://www.weiweiblog.cn/converttree/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树与双向链表</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树与双向链表</a></td>
<td align="center">树、链表</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="https://www.weiweiblog.cn/permutation/" target="_blank" rel="noopener">[剑指offer] 字符串的排列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">字符串的排列</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="https://www.weiweiblog.cn/morethanhalfnum_solution/" target="_blank" rel="noopener">[剑指offer] 数组中出现次数超过一半的数字</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="https://www.weiweiblog.cn/getleastnumbers_solution/" target="_blank" rel="noopener">[剑指offer] 最小的K个数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">最小的k个数</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="https://www.weiweiblog.cn/findgreatestsumofsubarray/" target="_blank" rel="noopener">[剑指offer] 连续子数组的最大和</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">连续子数组的最大和</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="https://www.weiweiblog.cn/numberof1between1andn_solution/" target="_blank" rel="noopener">[剑指offer] 整数中1出现的次数（从1到n整数中1出现的次数）</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">从1到n整数中1出现的次数</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="https://www.weiweiblog.cn/printminnumber/" target="_blank" rel="noopener">[剑指offer] 把数组排成最小的数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把数组排成最小的数</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="https://www.weiweiblog.cn/getuglynumber_solution/" target="_blank" rel="noopener">[剑指offer] 丑数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">丑数</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="https://www.weiweiblog.cn/firstnotrepeatingchar/" target="_blank" rel="noopener">[剑指offer] 第一个只出现一次的字符</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">第一个只出现一次的字符</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="https://www.weiweiblog.cn/inversepairs/" target="_blank" rel="noopener">[剑指offer] 数组中的逆序对</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中的逆序对</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="https://www.weiweiblog.cn/findfirstcommonnode/" target="_blank" rel="noopener">[剑指offer] 两个链表的第一个公共结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">两个链表的第一个公共结点</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="https://www.weiweiblog.cn/getnumberofk/" target="_blank" rel="noopener">[剑指offer] 数字在排序数组中出现的次数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数字在排序数组中出现的次数</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://www.weiweiblog.cn/treedepth/" target="_blank" rel="noopener">[剑指offer] 二叉树的深度</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的深度</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://www.weiweiblog.cn/findnumsappearonce/" target="_blank" rel="noopener">[剑指offer] 数组中只出现一次的数字</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中只出现一次的数字</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">41</td>
<td align="center"><a href="https://www.weiweiblog.cn/findnumberswithsum/" target="_blank" rel="noopener">[剑指offer] 和为S的两个数字</a> VS <a href="https://www.weiweiblog.cn/findcontinuoussequence/" target="_blank" rel="noopener">[剑指offer] 和为S的连续正数序列</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">和为s的两个数字</a> VS <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">和为S的连续正数序列</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="https://www.weiweiblog.cn/reversesentence/" target="_blank" rel="noopener">[剑指offer] 翻转单词顺序列</a> VS <a href="https://www.weiweiblog.cn/leftrotatestring/" target="_blank" rel="noopener">[剑指offer] 左旋转字符串</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">翻转单词顺序</a> VS <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">左旋转字符串</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="https://www.weiweiblog.cn/iscontinuous/" target="_blank" rel="noopener">[剑指offer] 扑克牌顺子</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">扑克牌的顺子</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center"><a href="https://www.weiweiblog.cn/lastremaining_solution/" target="_blank" rel="noopener">[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">圆圈中最后剩下的数字</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center"><a href="https://www.weiweiblog.cn/sum_solution/" target="_blank" rel="noopener">[剑指offer] 求1+2+3+…+n</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">求1+2+…+n 233</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://www.weiweiblog.cn/add/" target="_blank" rel="noopener">[剑指offer] 不用加减乘除做加法</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">不用加减乘除做加法</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center"><a href="https://www.weiweiblog.cn/strtoint/" target="_blank" rel="noopener">[剑指offer] 把字符串转换成整数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把字符串转换成整数</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="https://www.weiweiblog.cn/duplicate/" target="_blank" rel="noopener">[剑指offer] 数组中重复的数字</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数组中重复的数字</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center"><a href="https://www.weiweiblog.cn/multiply/" target="_blank" rel="noopener">[剑指offer] 构建乘积数组</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">构建乘积数组</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="https://www.weiweiblog.cn/match/" target="_blank" rel="noopener">[剑指offer] 正则表达式匹配</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">正则表达式匹配</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center"><a href="https://www.weiweiblog.cn/isnumeric/" target="_blank" rel="noopener">[剑指offer] 表示数值的字符串</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">表示数值的字符串</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">55</td>
<td align="center"><a href="https://www.weiweiblog.cn/firstappearingonce/" target="_blank" rel="noopener">[剑指offer] 字符流中第一个不重复的字符</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">字符流中第一个不重复的字符</a></td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">56</td>
<td align="center"><a href="https://www.weiweiblog.cn/entrynodeofloop/" target="_blank" rel="noopener">[剑指offer] 链表中环的入口结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">链表中环的入口结点</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">57</td>
<td align="center"><a href="https://www.weiweiblog.cn/deleteduplication/" target="_blank" rel="noopener">[剑指offer] 删除链表中重复的结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">删除链表中重复的结点</a></td>
<td align="center">链表</td>
</tr>
<tr>
<td align="center">58</td>
<td align="center"><a href="https://www.weiweiblog.cn/getnext/" target="_blank" rel="noopener">[剑指offer] 二叉树的下一个结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉树的下一个结点</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">59</td>
<td align="center"><a href="https://www.weiweiblog.cn/issymmetrical/" target="_blank" rel="noopener">[剑指offer] 对称的二叉树</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">对称的二叉树</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">60</td>
<td align="center"><a href="https://www.weiweiblog.cn/printz/" target="_blank" rel="noopener">[剑指offer] 按之字形顺序打印二叉树</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">61</td>
<td align="center"><a href="https://www.weiweiblog.cn/print/" target="_blank" rel="noopener">[剑指offer] 把二叉树打印成多行</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">把二叉树打印成多行</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">62</td>
<td align="center"><a href="https://www.weiweiblog.cn/serialize/" target="_blank" rel="noopener">[剑指offer] 序列化二叉树</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">序列化二叉树</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">63</td>
<td align="center"><a href="https://www.weiweiblog.cn/kthnode/" target="_blank" rel="noopener">[剑指offer] 二叉搜索树的第k个结点</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">二叉搜索树的第k个结点</a></td>
<td align="center">树</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center"><a href="https://www.weiweiblog.cn/getmedian/" target="_blank" rel="noopener">[剑指offer] 数据流中的中位数</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">数据流中的中位数</a></td>
<td align="center">数值</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center"><a href="https://www.weiweiblog.cn/maxinwindows/" target="_blank" rel="noopener">[剑指offer] 滑动窗口的最大值</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">滑动窗口的最大值</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">66</td>
<td align="center"><a href="https://www.weiweiblog.cn/haspath/" target="_blank" rel="noopener">[剑指offer] 矩阵中的路径</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">矩阵中的路径</a></td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">67</td>
<td align="center"><a href="https://www.weiweiblog.cn/movingcount/" target="_blank" rel="noopener">[剑指offer] 机器人的运动范围</a></td>
<td align="center"><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">机器人的运动范围</a></td>
<td align="center">数组</td>
</tr>
</tbody></table>
<h3 id="Array-数组题目汇总-18题"><a href="#Array-数组题目汇总-18题" class="headerlink" title="Array 数组题目汇总[18题]"></a>Array 数组题目汇总[18题]</h3><ul>
<li><a href="https://weiweiblog.cn/find2array/">[剑指offer] 二维数组中的查找</a></li>
<li><a href="https://weiweiblog.cn/minnumberinrotatearray/">[剑指offer] 旋转数组的最小数字</a></li>
<li><a href="https://weiweiblog.cn/reorderarray/">[剑指offer] 调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="https://weiweiblog.cn/printmatrix/">[剑指offer] 顺时针打印矩阵</a></li>
<li><a href="https://weiweiblog.cn/morethanhalfnum_solution/">[剑指offer] 数组中出现次数超过一半的数字</a></li>
<li><a href="https://weiweiblog.cn/getleastnumbers_solution/">[剑指offer] 最小的K个数</a></li>
<li><a href="https://weiweiblog.cn/findgreatestsumofsubarray/">[剑指offer] 连续子数组的最大和</a></li>
<li><a href="https://weiweiblog.cn/jzoffer_java/">[剑指offer] 把数组排成最小的数</a></li>
<li><a href="https://weiweiblog.cn/inversepairs/">[剑指offer] 数组中的逆序对</a></li>
<li><a href="https://weiweiblog.cn/getnumberofk/">[剑指offer] 数字在排序数组中出现的次数</a></li>
<li><a href="https://weiweiblog.cn/findnumsappearonce/">[剑指offer] 数组中只出现一次的数字</a></li>
<li><a href="https://weiweiblog.cn/iscontinuous/">[剑指offer] 扑克牌顺子</a></li>
<li><a href="https://weiweiblog.cn/lastremaining_solution/">[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)</a></li>
<li><a href="https://weiweiblog.cn/duplicate/">[剑指offer] 数组中重复的数字</a></li>
<li><a href="https://weiweiblog.cn/multiply/">[剑指offer] 构建乘积数组</a></li>
<li><a href="https://weiweiblog.cn/maxinwindows/">[剑指offer] 滑动窗口的最大值</a></li>
<li><a href="https://weiweiblog.cn/haspath/">[剑指offer] 矩阵中的路径</a></li>
<li><a href="https://weiweiblog.cn/movingcount/">[剑指offer] 机器人的运动范围</a></li>
</ul>
<h3 id="链表题目汇总-8题"><a href="#链表题目汇总-8题" class="headerlink" title="链表题目汇总[8题]"></a>链表题目汇总[8题]</h3><ul>
<li><a href="https://weiweiblog.cn/printlistfromtailtohead/">[剑指offer] 从尾到头打印链表</a></li>
<li><a href="https://weiweiblog.cn/reverselist/">[剑指offer] 反转链表</a></li>
<li><a href="https://weiweiblog.cn/findkthtotail/">[剑指offer] 链表中倒数第k个结点</a></li>
<li><a href="https://weiweiblog.cn/mergelinklist/">[剑指offer] 合并两个排序的链表</a></li>
<li><a href="https://weiweiblog.cn/clonelink/">[剑指offer] 复杂链表的复制</a></li>
<li><a href="https://weiweiblog.cn/deleteduplication/">[剑指offer] 删除链表中重复的结点</a></li>
<li><a href="https://weiweiblog.cn/entrynodeofloop/">[剑指offer] 链表中环的入口结点</a></li>
<li><a href="https://weiweiblog.cn/findfirstcommonnode/">[剑指offer] 两个链表的第一个公共结点</a></li>
</ul>
<blockquote>
<p>更多关于链表面试题的总结，请移步<a href="https://weiweiblog.cn/linkedlist_summary/">[算法总结] 一文搞懂面试链表题</a> </p>
</blockquote>
<h3 id="二叉树题目汇总-13题"><a href="#二叉树题目汇总-13题" class="headerlink" title="二叉树题目汇总[13题]"></a>二叉树题目汇总[13题]</h3><ul>
<li><a href="https://weiweiblog.cn/reconstructbinarytree/">[剑指offer] 重建二叉树</a></li>
<li><a href="https://weiweiblog.cn/issubtree/">[剑指offer] 树的子结构</a></li>
<li><a href="https://weiweiblog.cn/mirrortree/">[剑指offer] 二叉树的镜像</a></li>
<li><a href="https://weiweiblog.cn/printfromtoptobottom/">[剑指offer] 从上往下打印二叉树</a></li>
<li><a href="https://weiweiblog.cn/verifysquenceofbst/">[剑指offer] 二叉搜索树的后序遍历序列</a></li>
<li><a href="https://weiweiblog.cn/findpath/">[剑指offer] 二叉树中和为某一值的路径</a></li>
<li><a href="https://weiweiblog.cn/treedepth/">[剑指offer] 二叉树的深度</a></li>
<li><a href="https://weiweiblog.cn/getnext/">[剑指offer] 二叉树的下一个结点</a></li>
<li><a href="https://weiweiblog.cn/issymmetrical/">[剑指offer] 对称的二叉树</a></li>
<li><a href="https://weiweiblog.cn/printz/">[剑指offer] 按之字形顺序打印二叉树</a></li>
<li><a href="https://weiweiblog.cn/print/">[剑指offer] 把二叉树打印成多行</a></li>
<li><a href="https://weiweiblog.cn/serialize/">[剑指offer] 序列化二叉树</a></li>
<li><a href="https://weiweiblog.cn/kthnode/">[剑指offer] 二叉搜索树的第k个结点</a></li>
</ul>
<blockquote>
<p>更多关于二叉树面试题的总结，请移步 <a href="https://www.weiweiblog.cn/20tree/" target="_blank" rel="noopener">[算法总结] 20 道题搞定 BAT 面试——二叉树</a> </p>
</blockquote>
<h3 id="堆栈和队列题目汇总-3题"><a href="#堆栈和队列题目汇总-3题" class="headerlink" title="堆栈和队列题目汇总[3题]"></a>堆栈和队列题目汇总[3题]</h3><ul>
<li><a href="https://www.weiweiblog.cn/stacktoqueue/" target="_blank" rel="noopener">[剑指offer] 用两个栈实现队列</a></li>
<li><a href="https://www.weiweiblog.cn/minstack/" target="_blank" rel="noopener">[剑指offer] 包含min函数的栈</a></li>
<li><a href="https://www.weiweiblog.cn/ispoporder/" target="_blank" rel="noopener">[剑指offer] 栈的压入、弹出序列</a></li>
</ul>
<blockquote>
<p>更多关于堆栈和队列面试题的总结，请移步 <a href="https://www.weiweiblog.cn/stack_and_queue/" target="_blank" rel="noopener">[算法总结] 6 道题搞定 BAT 面试——堆栈和队列</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法总结] 二分查找</title>
    <url>/algorithm_binarysearch/</url>
    <content><![CDATA[<p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，但它有一个前提，就是必须在有序数据中进行查找。</p>
<p>二分查找很好写，却很难写对，据统计只有10%的程序员可以写出没有bug的的二分查找代码。出错原因主要集中在判定条件和边界值的选择上，很容易就会导致越界或者死循环的情况。</p>
<p>下面对二分查找及其变形进行总结：</p>
<h3 id="1-最基本的二分查找"><a href="#1-最基本的二分查找" class="headerlink" title="1. 最基本的二分查找"></a>1. 最基本的二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &amp;lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &amp;gt; target)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，有几个要注意的点：</p>
<ol>
<li><p>循环的判定条件是：<code>low &lt;= high</code></p>
</li>
<li><p>为了防止数值溢出，<code>mid = low + (high - low)/2</code></p>
</li>
<li><p>当 <code>A[mid]</code>不等于<code>target</code>时，<code>high = mid - 1</code>或<code>low = mid + 1</code></p>
</li>
</ol>
<blockquote>
<p>leetcode参考：<a href="https://leetcode.com/problems/search-insert-position/description/" target="_blank" rel="noopener">Search Insert Position</a> </p>
</blockquote>
<h3 id="2-查找目标值区域的左边界-查找与目标值相等的第一个位置-查找第一个不小于目标值数的位置"><a href="#2-查找目标值区域的左边界-查找与目标值相等的第一个位置-查找第一个不小于目标值数的位置" class="headerlink" title="2. 查找目标值区域的左边界/查找与目标值相等的第一个位置/查找第一个不小于目标值数的位置"></a>2. 查找目标值区域的左边界/查找与目标值相等的第一个位置/查找第一个不小于目标值数的位置</h3><blockquote>
<p>A = [1,3,3,5, <strong>7</strong> ,7,7,7,8,14,14]</p>
</blockquote>
<blockquote>
<p>target = 7</p>
</blockquote>
<blockquote>
<p>return 4 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchLowerBound</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &amp;lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &amp;lt;= A[mid])&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low &amp;lt; A.length &amp;&amp; A[low] == target)</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-查找目标值区域的右边界-查找与目标值相等的最后一个位置-查找最后一个不大于目标值数的位置"><a href="#3-查找目标值区域的右边界-查找与目标值相等的最后一个位置-查找最后一个不大于目标值数的位置" class="headerlink" title="3. 查找目标值区域的右边界/查找与目标值相等的最后一个位置/查找最后一个不大于目标值数的位置"></a>3. 查找目标值区域的右边界/查找与目标值相等的最后一个位置/查找最后一个不大于目标值数的位置</h3><blockquote>
<p>A = [1,3,3,5,7,7,7, <strong>7</strong> ,8,14,14]</p>
</blockquote>
<blockquote>
<p>target = 7</p>
</blockquote>
<blockquote>
<p>return 7 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchUpperBound</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &amp;lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &amp;gt;= A[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(high &amp;gt;= <span class="number">0</span> &amp;&amp; A[high] == target)</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题以可变形为<code>查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数</code>，我们已经找到了最后一个不大于目标值的数，那么再往后进一位，返回<code>high + 1</code>，就是第一个大于目标值的数。</p>
<blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/getnumberofk/">数字在排序数组中出现的次数</a> </p>
</blockquote>
<h3 id="4-查找最后一个小于目标值的数-查找比目标值小但是最接近目标值的数"><a href="#4-查找最后一个小于目标值的数-查找比目标值小但是最接近目标值的数" class="headerlink" title="4. 查找最后一个小于目标值的数/查找比目标值小但是最接近目标值的数"></a>4. 查找最后一个小于目标值的数/查找比目标值小但是最接近目标值的数</h3><p>此题以可由第 2 题变形而来，我们已经找到了目标值区域的下（左）边界，那么再往左退一位，即<code>low - 1</code>，就是最后一个小于目标值的数。其实<code>low - 1</code>也是退出循环后<code>high</code>的值，因为此时 <code>high</code>刚好等于<code>low - 1</code>，它小于<code>low</code>，所以 while 循环结束。我们只要判断<code>high</code>是否超出边界即可。</p>
<blockquote>
<p>A = [1,3,3, <strong>5</strong> ,7,7,7,7,8,14,14]</p>
</blockquote>
<blockquote>
<p>target = 7</p>
</blockquote>
<blockquote>
<p>return 3 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = n, mid;</span><br><span class="line"><span class="keyword">while</span>(low &amp;lt;= high)&#123;</span><br><span class="line">    mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target &amp;lt;= A[mid])&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> high &amp;lt; <span class="number">0</span> ? -<span class="number">1</span> : high;</span><br></pre></td></tr></table></figure>

<h3 id="5-查找第一个大于目标值的数-查找比目标值大但是最接近目标值的数"><a href="#5-查找第一个大于目标值的数-查找比目标值大但是最接近目标值的数" class="headerlink" title="5. 查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数"></a>5. 查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数</h3><p>此题以可由第 3 题变形而来，我们已经找到了目标值区域的上（右）边界，那么再往右进一位，即<code>high + 1</code>，就是第一个大于目标值的数。其实<code>high + 1</code>也是退出循环后<code>low</code>的值，因为此时 <code>low</code>刚好等于<code>high + 1</code>，它大于<code>high</code>，所以 while 循环结束。我们只要判断<code>low</code>是否超出边界即可。</p>
<blockquote>
<p>A = [1,3,3,5,7,7,7,7, <strong>8</strong> ,14,14]</p>
</blockquote>
<blockquote>
<p>target = 7</p>
</blockquote>
<blockquote>
<p>return 8 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = n, mid;</span><br><span class="line"><span class="keyword">while</span>(low &amp;lt;= high)&#123;</span><br><span class="line">    mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target &amp;gt;= A[mid])&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low &amp;gt; n ? -<span class="number">1</span> : low;</span><br></pre></td></tr></table></figure>

<h3 id="6-旋转数组返回最小元素"><a href="#6-旋转数组返回最小元素" class="headerlink" title="6. 旋转数组返回最小元素"></a>6. 旋转数组返回最小元素</h3><h4 id="6-1-查找旋转数组的最小元素（假设不存在重复数字）"><a href="#6-1-查找旋转数组的最小元素（假设不存在重复数字）" class="headerlink" title="6.1 查找旋转数组的最小元素（假设不存在重复数字）"></a>6.1 查找旋转数组的最小元素（假设不存在重复数字）</h4><blockquote>
<p>LeetCode: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a></p>
</blockquote>
<blockquote>
<p>Input: [3,4,5,<strong>1</strong>,2]</p>
</blockquote>
<blockquote>
<p>Output: 1 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &amp;gt; nums[right])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里和之前的二分查找的几点区别：</p>
<ol>
<li><p>循环判定条件为<code>left &lt; right</code>，没有等于号</p>
</li>
<li><p>循环中，通过比较nums[left]与num[mid]的值来判断mid所在的位置:</p>
<ul>
<li>如果<code>nums[mid] &gt; nums[right]</code>，说明前半部分是有序的，最小值在后半部分，令<code>left = mid + 1</code>；</li>
<li>如果<code>nums[mid] &lt;= num[right]</code>，说明最小值在前半部分，令<code>right = mid</code>。</li>
</ul>
</li>
</ol>
<p>最后，left会指向最小值元素所在的位置。</p>
<h4 id="6-2-查找旋转数组的最小元素（存在重复项）"><a href="#6-2-查找旋转数组的最小元素（存在重复项）" class="headerlink" title="6.2 查找旋转数组的最小元素（存在重复项）"></a>6.2 查找旋转数组的最小元素（存在重复项）</h4><blockquote>
<p>LeetCode: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array II</a></p>
</blockquote>
<blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/minnumberinrotatearray/">旋转数组的最小数字</a></p>
</blockquote>
<blockquote>
<p>Input: [2,2,2,****,1]</p>
</blockquote>
<blockquote>
<p>Output: 0 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &amp;gt; nums[right])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &amp;lt; nums[right])</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前不存在重复项的差别是：当<code>nums[mid] == nums[right]</code>时，我们不能确定最小值在 <code>mid</code>的左边还是右边，所以我们就让右边界减一。</p>
<h3 id="7-在旋转排序数组中搜索"><a href="#7-在旋转排序数组中搜索" class="headerlink" title="7. 在旋转排序数组中搜索"></a>7. 在旋转排序数组中搜索</h3><h4 id="7-1-不考虑重复项"><a href="#7-1-不考虑重复项" class="headerlink" title="7.1 不考虑重复项"></a>7.1 不考虑重复项</h4><blockquote>
<p>LeetCode: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">Search in Rotated Sorted Array</a> </p>
</blockquote>
<p>法一：</p>
<ul>
<li>先利用方法 6.1 查找数组中的最小元素，即确定分界点的位置</li>
<li>把旋转的数组当成偏移，用<code>(offset + mid) % len</code>来求真实的 mid 的位置。</li>
<li>然后用二分查找来定位目标值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &amp;gt; nums[right])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> offset = left;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> realmid = (mid + offset) % len;</span><br><span class="line">        <span class="keyword">if</span>(nums[realmid] == target)</span><br><span class="line">            <span class="keyword">return</span> realmid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[realmid] &amp;lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：其实没有必要找到旋转数组的分界点，对于搜索左侧还是右侧我们是可以根据mid跟high的元素大小来判定出来的，直接根据target的值做二分搜索就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &amp;lt;= nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &amp;lt; nums[mid] &amp;&amp; target &amp;gt;= nums[left])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &amp;lt;= nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &amp;gt; nums[mid] &amp;&amp; target &amp;lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-存在重复项"><a href="#7-2-存在重复项" class="headerlink" title="7.2 存在重复项"></a>7.2 存在重复项</h4><blockquote>
<p>LeetCode: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Search in Rotated Sorted Array II</a> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &amp;gt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &amp;lt; nums[mid] &amp;&amp; target &amp;gt;= nums[left])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &amp;lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &amp;gt; nums[mid] &amp;&amp; target &amp;lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-二维数组中的查找"><a href="#8-二维数组中的查找" class="headerlink" title="8. 二维数组中的查找"></a>8. 二维数组中的查找</h3><blockquote>
<p>剑指offer：<a href="https://weiweiblog.cn/find2array/">二维数组中的查找</a> </p>
</blockquote>
<p>二维数组是有序的，从右上角来看，向左数字递减，向下数字递增。因此可以利用二分查找的思想，从右上角出发：</p>
<ul>
<li>当要查找数字比右上角数字大时，下移；</li>
<li>当要查找数字比右上角数字小时，左移；</li>
</ul>
<blockquote>
<p>获取更多最新资讯，免费获取百G视频教程</p>
</blockquote>
<blockquote>
<p>请关注微信公众号：南强说晚安 </p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fve778tdrvj30hs0ad75t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二进制中1的个数</title>
    <url>/numberof1/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
<p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<blockquote>
<p>来源于牛客网@菩提旭光 </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>位运算</tag>
        <tag>剑指offer</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 矩形覆盖</title>
    <url>/rectcover/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>依旧是斐波那契数列</p>
<p>f(1) = 1</p>
<p>f(2) = 2</p>
<p>当n=3时，它可以由n=2的情况再覆盖一块得到，也可以由 n=1的情况再覆盖 2 块得到，所以 f(3) = f(1) + f(2)，依次往下推，可以得到</p>
<p>f(n) = 1, (n=1)</p>
<p>f(n) = 2, (n=2)</p>
<p>f(n) = f(n-1) + f(n-2), (n&gt;2)</p>
<p>用递归的方法即可实现</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&amp;lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>|| target ==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 变态跳台阶</title>
    <url>/jumpfloorii/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(1) &#x3D; 1</span><br><span class="line">f(2) &#x3D; f(2-1) + f(2-2)        </span><br><span class="line">f(3) &#x3D; f(3-1) + f(3-2) + f(3-3) </span><br><span class="line">...</span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) </span><br></pre></td></tr></table></figure>

<p>因为青蛙可以跳上任意级的台阶，所以以青蛙跳上一个 4 级的台阶为例进行分析，它可以在开始直接跳 4 级到 4 级台阶，也可以从 1 级台阶上往上跳 3 个台阶到 4 级，也可以从 2 级台阶往上跳 2 个台阶到 4 级，还可以从 3 级台阶上跳 3 级到 4 级。所以<code>f(4) = f(4-1) + f(4-2) + f(4-3) + f(4-4)</code></p>
<p>可以得出以下的公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) </span><br><span class="line">&#x3D;&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)</span><br><span class="line">又因为：</span><br><span class="line">f(n-1) &#x3D; f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) </span><br><span class="line">       &#x3D; f(0) + f(1) + f(2) + f(3) + ... + f(n-2)</span><br><span class="line">f(n) &#x3D; f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) &#x3D; f(n-1) + f(n-1)</span><br><span class="line">     &#x3D; 2 * f(n-1)</span><br></pre></td></tr></table></figure>

<p>最后可以得到</p>
<p>f(n) = 1, (n=0)</p>
<p>f(n) = 1, (n=1)</p>
<p>f(n) = 2*f(n-1),(n&gt;=2)</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&amp;lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>||target ==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 跳台阶</title>
    <url>/jumpfloor/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>按照题意，</p>
<p>1 级 &#8212;- 1 种</p>
<p>2 级 &#8212;- 2 种</p>
<p>3 级 &#8212;- 3 种</p>
<p>4 级 &#8212;- 5 种</p>
<p>5 级 &#8212;- 8 种</p>
<p>我们可以得到一种规律，如果要跳 6 级，可以从 5 级跳一步到 6 级，5 级的方案中有多少种就有多少种跳法跳到 6 级；还可以从 4 级跳两步到 6 级，同理，4 级的方案有多少种就有多少种方法从 4 级跳到 6 级，所以可以得到公式<code>f(n) = f(n-1) + f(n-2)</code>，再结合 1 级和 2 级的情况，可以得以如下的规律：</p>
<p>f(n) = 1, (n=1)</p>
<p>f(n) = 2, (n=2)</p>
<p>f(n) = f(n-1)+f(n-2) ,(n&gt;2,n为整数)</p>
<p>这就是斐波那契数列的变形，因此可以用递归来实现。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&amp;lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>|| target == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>)+JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 斐波那契数列</title>
    <url>/fibonacci/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>公式:</p>
<p>f(n) = n, n &lt;= 1</p>
<p>f(n) = f(n-1) + f(n-2), n &gt; 1</p>
<p>可以直接使用递归的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(n&lt;&#x3D;1) return n;</span><br><span class="line">else return Fibonacci(n-1)+Fibonacci(n-2);</span><br></pre></td></tr></table></figure>

<p>递归的方法可能会遇到Stack Overflow，</p>
<p>所以我们可以考虑用动态规划的方法来实现。</p>
<p>采用自底向上方法来保存了先前计算的值，为后面的调用服务。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> fn1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fn2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&amp;lt;=n; i++)&#123;</span><br><span class="line">            fn2 += fn1;</span><br><span class="line">            fn1 = fn2 - fn1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态规划</tag>
        <tag>剑指offer</tag>
        <tag>斐波那契数列</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 旋转数组的最小数字</title>
    <url>/minnumberinrotatearray/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>采用二分查找法。</p>
<p>需要考虑三种情况：</p>
<ul>
<li><p>array[mid] &gt; array[high]:</p>
<p>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。</p>
<p><code>low = mid + 1</code></p> </p>
<ul>
<li><p>array[mid] == array[high]:</p>
<p>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边</p>
<p>还是右边,这时只好一个一个试</p>
<p><code>high = high - 1</code></p>
</li>
<li><p>array[mid] &lt; array[high]:</p>
<p>出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左</p>
<p>边。因为右边必然都是递增的。</p>
<p><code>high = mid</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字。比如 array = [4,6]， </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array[low] &#x3D; 4</span><br><span class="line">array[mid] &#x3D; 4 </span><br><span class="line">array[high] &#x3D; 6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果high = mid &#8211; 1，就会产生错误， 因此high = mid </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &amp;lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &amp;gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>二分查找</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 用两个栈实现队列</title>
    <url>/stacktoqueue/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>两个栈 stack1 和 stack2:</p>
<ul>
<li>push 动作都在 stack1 中进行，</li>
<li>pop 动作在 stack2 中进行。当 stack2 不为空时，直接 pop，当 stack2 为空时，先把 stack1 中的元素 pop 出来，push 到 stack2 中，再从 stack2 中 pop 元素。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; stack1 = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; stack2 = <span class="keyword">new</span> Stack&amp;lt;Integer&amp;gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty() &amp;&amp; stack2.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        <span class="keyword">int</span> node;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                node = stack1.pop();</span><br><span class="line">                stack2.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转微信 | 微信个人号自动回复，还能这样玩！</title>
    <url>/weixin_autorep/</url>
    <content><![CDATA[<p>先上图</p>
<p><img src="https://weiweiblog.cn/wp-content/uploads/2018/08/IMG_0031-225x300.png" alt="添加好友验证通过后，自动回复列表页"></p>
<p><img src="https://weiweiblog.cn/wp-content/uploads/2018/08/IMG_0033-225x300.png" alt="根据好友发送的数字，自动回复对应的信息"></p>
<p><img src="https://weiweiblog.cn/wp-content/uploads/2018/08/IMG_0032-225x300.png" alt="根据好友回复的关键词，自动回复对应的信息"></p>
<p>如今，通过微信进行营销的场景越来越多，比如常见的微商、淘宝客服、民宿预订、摄影约拍等，他们都会通过微信号与客户进行交流，为客户提供服务。但是随着客户量的增大，微信客户每天要回复客户的消息日益增多，而这些消息很多都是重复的，比如一个民宿的客服，每天有上百个客户会来询问民宿的价格，那么客服就要把同一段文字复制粘贴发送上百次。</p>
<p>作为一个工科技术宅，绝不能忍受同一个事情机械地重复 5 次以上。于是，我们就通过 python 调用 itchat 来实现微信个人号的消息自动回复功能。</p>
<p>itchat是一个开源的微信个人号接口，调用 itchat ，只需要编写少量的代码使，你就可以完成一个能够处理所有信息的微信机器人，让它帮你自动回复消息。</p>
<p>首先，我们要安装 itchat 这个包。</p>
<p>pip install itchat</p>
<p>安装完成之后，就可以开始编写代码了。</p>
<p>下面是一个简单的例子，给文件传输助手发一条信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入 itchat</span><br><span class="line">import itchat</span><br><span class="line"># 登陆微信</span><br><span class="line">itchat.auto_login()</span><br><span class="line"># 发送消息</span><br><span class="line">itchat.send(&#39;Hello, filehelper&#39;, toUserName&#x3D;&#39;filehelper&#39;)</span><br></pre></td></tr></table></figure>

<p>根据好友的消息自动回复</p>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fu6qg84pyvj31kw1144ho.jpg" alt=""></p>
<p>收到好友添加请求后自动通过验证，并发送自动回复消息的列表</p>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fu6qgh6dfcj30yq0ku44x.jpg" alt=""></p>
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>itchat</tag>
        <tag>微信</tag>
        <tag>自动回复</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 重建二叉树</title>
    <url>/reconstructbinarytree/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们知道，前序遍历的第一个节点就是树的根节点，所以我们先根据前序遍历序列的第一个数字创建根结点，接下来在中序遍历序列中找到根结点的位置，根节点的左边就是左子树，右边就是右子树，这样就能确定左、右子树结点的数量。在前序遍历和中序遍历的序列中划分了左、右子树结点的值之后，就可以递归地去分别构建它的左右子树。</p>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fu3vlvt9mqj312k0hsgq4.jpg" alt=""></p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length ==<span class="number">0</span> || in.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">ConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> [] in, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps &amp;gt; pe || is &amp;gt; ie)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = is; i&amp;lt;=ie; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre)&#123;</span><br><span class="line">                root.left = ConstructBinaryTree(pre, ps+<span class="number">1</span>, ps+i-is, in, is, i-<span class="number">1</span>);</span><br><span class="line">                root.right = ConstructBinaryTree(pre, ps+i-is+<span class="number">1</span>, pe, in, i+<span class="number">1</span>, ie);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 从尾到头打印链表</title>
    <url>/printlistfromtailtohead/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>一种方法是利用栈来实现；</p>
<p>另外一种方法是利用三个指针把链表反转，关键是 r 指针保存断开的节点。</p>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fu3v5nxz7zj30x40vw7ac.jpg" alt=""></p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        ListNode head = listNode;</span><br><span class="line">        ListNode cur = listNode.next;</span><br><span class="line">        <span class="keyword">while</span>( cur!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时listNode的next还指向第二个node，所以要让listNode.next=null,防止循环</span></span><br><span class="line">        listNode.next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 替换空格</title>
    <url>/replacespace/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很简单，从后往前遍历就对了。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &amp;gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                res.append(<span class="string">"02%"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二维数组中的查找</title>
    <url>/find2array/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fu3ua5razrj30ei0fydj3.jpg" alt=""></p>
<p>二维数组是有序的，从右上角来看，向左数字递减，向下数字递增。</p>
<p>因此从右上角开始查找，</p>
<ul>
<li>当要查找数字比右上角数字大时，下移；</li>
<li>当要查找数字比右上角数字小时，左移；</li>
<li>如果出了边界，则说明二维数组中不存在该整数。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[n][m];</span><br><span class="line">        <span class="keyword">while</span>(target != temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m&amp;gt;<span class="number">0</span> &amp;&amp; n&amp;lt;array.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&amp;gt;temp)&#123;</span><br><span class="line">                    n = n + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&amp;lt;temp)&#123;</span><br><span class="line">                    m = m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = array[n][m];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 平衡二叉树</title>
    <url>/isbalanced_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>定义：平衡二叉查找树，简称平衡二叉树。</p>
<ol>
<li>可以是空树。</li>
<li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1。</li>
</ol>
<p>遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxDept(root.left) - maxDept(root.right)) &amp;lt;=<span class="number">1</span> &amp;&amp;</span><br><span class="line">            IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDept</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDept(root.left), maxDept(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 按之字形顺序打印二叉树</title>
    <url>/printz/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>设两个栈，s2存放奇数层，s1存放偶数层</p>
<p>遍历s2节点的同时按照左子树、右子树的顺序加入s1，</p>
<p>遍历s1节点的同时按照右子树、左子树的顺序加入s2</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s1 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s2 = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        s2.push(pRoot);</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s2.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = s1.pop();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">            temp.clear();</span><br><span class="line">            flag ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
        <tag>层次遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 求1+2+3+…+n</title>
    <url>/sum_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>求1+2+3+&#8230;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>累加不能用循环的话，那就试试递归吧。</p>
<p>判断递归的终止条件不能用 if 和 switch，那就用短路与代替。</p>
<p><code>(n &gt; 0) &amp;&amp; (sum += Sum_Solution(n-1))&gt;0</code></p>
<p>只有满足n &gt; 0的条件，<code>&amp;&amp;</code>后面的表达式才会执行。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">boolean</span> t = (n &amp;gt; <span class="number">0</span>) &amp;&amp; (sum += Sum_Solution(n-<span class="number">1</span>))&amp;gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>递归</tag>
        <tag>短路与</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 扑克牌顺子</title>
    <url>/iscontinuous/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)&#8230;他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子&#8230;..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先统计王(0)的数量，再把牌排序，如果后面一个数比前面一个数大于1以上，那么中间的差值就必须用王来补了。看王的数量够不够，如果够就返回true，否则返回false。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>, dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                zero ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i+<span class="number">1</span>] - numbers[i] &amp;gt; <span class="number">1</span>)&#123;</span><br><span class="line">                dis += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero &amp;gt;= dis)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 和为S的连续正数序列</title>
    <url>/findcontinuoussequence/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>滑动窗口的方法：用两个数字 start 和 end 分别表示序列的最小值和最大值，首先将 start 初始化为1，end 初始化为2。如果从start到end的和大于sum，我们就从序列中去掉较小的值(即增大start),</p>
<p>相反，只需要增大end。</p>
<p>终止条件为：一直增加begin到(1+sum)/2并且end小于sum为止</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum &amp;lt; <span class="number">3</span>)</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = <span class="number">2</span>, mid = (<span class="number">1</span>+sum)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt; mid)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = totalSum(start, end);</span><br><span class="line">            <span class="keyword">if</span>(s == sum)&#123;</span><br><span class="line">                res.add(getSequence(start, end));</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &amp;lt; sum)&#123;</span><br><span class="line">                end ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &amp;gt; sum)&#123;</span><br><span class="line">                start ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalSum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &amp;lt;= end; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; getSequence(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &amp;lt;= end; i++)&#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 左旋转字符串</title>
    <url>/leftrotatestring/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很简单的题，在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。注意字符串长度为 0 的情况。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        n = n % len;</span><br><span class="line">        String s1 = str.substring(n, len);</span><br><span class="line">        String s2 = str.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> s1+s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>让网站成为 HTTPS 安全站点</title>
    <url>/https/</url>
    <content><![CDATA[<blockquote>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 </p>
</blockquote>
<p>简而言之，就是让你的网站有下图这个小绿标：</p>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1ftztx6vz4sj31bm0h27bu.jpg" alt=""></p>
<p>之前用过阿里云的 SSL 免费证书，但是期限只有一年，昨天过期了，看了其他收费的 SSL 证书，还是很贵的，在读小硕实在买不起，只能找找免费的 SSL 证书了。</p>
<p>我们可以从 Let’s Encrypt 获得网站域名的免费的证书。 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a>是Let’s Encrypt推出的获取证书的客户端，可以让我们免费快速地获取Let’s Encrypt证书。</p>
<p>下面，一步一步教你申请部署ssl证书，并自动续期。</p>
<ol>
<li><p>进入<a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a>官网，并选择你的系统和软件。我这边是 <code>Nginx</code>和<code>Ubuntu 16.04 (xenial)</code>。</p>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1ftzu0m3077j31e00rs789.jpg" alt=""></p> </p>
</li>
<li><p>选择好之后，就会出现具体的部署教程，如下图</p>
<p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1ftzu2t7gzoj319k2kukbm.jpg" alt=""></p>
</li>
</ol>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>先安装<code>python-certbot-nginx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install software-properties-common</span><br><span class="line">$ sudo add-apt-repository ppa:certbot&#x2F;certbot</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install python-certbot-nginx </span><br></pre></td></tr></table></figure>

<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><p>certbot有一个Nginx插件，运行它，按照提示一步一步操作就会自动帮你把证书部署好。</p>
<p>运行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo certbot --nginx</span><br></pre></td></tr></table></figure>

<p>选择你要激活 HTTPS 的域名，输入序号即可</p>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1ftzu8vq2esj31840l842x.jpg" alt=""></p>
<p>选择直接通过 HTTPS 访问并删除 HTTP 的方式，或者保留 HTTP，如何你确定你网站中所有的链接都是按照HTTPS来配置的，那么你可以像我这样选择 2。</p>
<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1ftzwb21yotj31100c8jtt.jpg" alt=""></p>
<p>之后，看到Congratulations!就表示部署成功了。</p>
<p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1ftzwee7gusj30x607y0u6.jpg" alt=""></p>
<h5 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h5><p>由于Let的加密证书的有效期是90天，90 天之后证书就会过期，如果要续期就要重复一次上面的步骤，这太麻烦了，Certbot提供了一个自动续期的功能，只需运行如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo certbot renew --dry-run</span><br></pre></td></tr></table></figure>

<p>至此，SSL证书的部署和自动续期的配置就完成，你的网站就不再是无证驾驶了。</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>Certbot</tag>
        <tag>Let’s Encrypt</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉树的下一个结点</title>
    <url>/getnext/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>中序遍历：左 -&gt; 根 -&gt; 右</p>
<p>分三种情况：</p>
<ol>
<li>如果当前节点为空，直接返回空；</li>
<li>如果当前节点有右子树，则返回右子树的最左子树；</li>
<li>如果当前节点没有右子树，再分两种情况： <ul>
<li>看看当前节点是不是它的父节点的左子树，如果是，则返回它的父节点；</li>
<li>如果当前节点不是它的父节点的左子树，则把父节点赋给当前节点，再判断当前节点是不是它的父节点的左子树，直到当前节点是不是它的父节点的左子树，返回它的父节点。</li>
</ul>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode node = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode root = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNode == root.left)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            pNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 表示数值的字符串</title>
    <url>/isnumeric/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&#8221;+100&#8243;,&#8221;5e2&#8243;,&#8221;-123&#8243;,&#8221;3.1416&#8243;和&#8221;-1E-16&#8243;都表示数值。 但是&#8221;12e&#8221;,&#8221;1a3.14&#8243;,&#8221;1.2.3&#8243;,&#8221;+-5&#8243;和&#8221;12e+4.3&#8243;都不是。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过。</p>
<ul>
<li><p>对于“+/-”： 正常来看它们第一次出现的话应该出现在字符串的第一个位置，如果它第一次出现在不是字符串首位，而且它的前面也不是“e/E”，那就不符合规则；如果是第二次出现，那么它就应该出现在“e/E”的后面，如果“+/-”的前面不是“e/E”，那也不符合规则。</p>
</li>
<li><p>对于“e/E”： 如果它的后面不接任何数字，就不符合规则；如果出现多个“e/E”也不符合规则。</p>
</li>
<li><p>对于“.”： 出现多个“.”是不符合规则的。还有“e/E”的字符串出现“.”也是不符合规则的。</p>
<p>同时，要保证其他字符均为 0-9 之间的数字。</p>
</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &amp;gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &amp;lt; <span class="string">'0'</span> || str[i] &amp;gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 构建乘积数组</title>
    <url>/multiply/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组A[0,1,&#8230;,n-1],请构建一个数组B[0,1,&#8230;,n-1],其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1ftulyouazej30wc0g4acb.jpg" alt=""></p>
<p>B[i]的值可以看作图中矩阵第 i 行所有元素的乘积。我们可以先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length &amp;lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt; A.length; i++)&#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = A.length - <span class="number">2</span>; j&amp;gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            temp *= A[j+<span class="number">1</span>];</span><br><span class="line">            B[j] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 序列化二叉树</title>
    <url>/serialize/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li>对于序列化：使用前序遍历，递归的将二叉树的值转化为字符，并且在每次二叉树的结点不为空时，在转化val所得的字符之后添加一个&#8217;,&#8217;作为分割; 对于空节点则以 &#8216;#,&#8217; 代替。</li>
<li>对于反序列化：将字符串按照“，”进行分割，插入到队列中，然后依次从队列中取出字符建立节点，递归创建一个二叉树。</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer(root.val + <span class="string">","</span>);</span><br><span class="line">        res.append(Serialize(root.left));</span><br><span class="line">        res.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String [] res = str.split(<span class="string">","</span>);</span><br><span class="line">        Queue&amp;lt;String&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;String&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; res.length; i++)&#123;</span><br><span class="line">            queue.offer(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">pre</span><span class="params">(Queue&amp;lt;String&amp;gt; queue)</span></span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(<span class="string">"#"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        node.left = pre(queue);</span><br><span class="line">        node.right = pre(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 把字符串转换成整数</title>
    <url>/strtoint/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>常规思路，先判断第一位是不是符号位，如果有符号，有flag 做标记。</p>
<p>遍历字符串中的每个字符，如果存在非数字的字符，直接返回 0，否则，用当前字符减去&#8217;0&#8217;得到当前的数字，再进行运算。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'+'</span>)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> start = flag &amp;gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start) &amp;gt; <span class="string">'9'</span> || str.charAt(start) &amp;lt; <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + (str.charAt(start) - <span class="string">'0'</span>);</span><br><span class="line">            start ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">2</span> ? -(<span class="keyword">int</span>)res : (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉树的深度</title>
    <url>/treedepth/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>法一：递归法。求二叉树的深度，就是求左子树、右子树的中深度最大的加上一个根节点，依此递归即可。</p>
<p>法二：层次遍历。每遍历一层，deep 加 1，直接到最后一层，输出 deep。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &amp;gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：层次遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            start ++;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                end = queue.size();</span><br><span class="line">                start = <span class="number">0</span>;</span><br><span class="line">                deep ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 字符流中第一个不重复的字符</title>
    <url>/firstappearingonce/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&#8221;go&#8221;时，第一个只出现一次的字符是&#8221;g&#8221;。当从该字符流中读出前六个字符“google&#8221;时，第一个只出现一次的字符是&#8221;l&#8221;。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用一个哈希表来存储每个字符及其出现的次数，另外用一个字符串 s 来保存字符流中字符的顺序。</p>
<ul>
<li>每次插入的时候，在字符串 s 中插入该字符，然后在哈希表中查看是否存在该字符，如果存在则它的 value 加1，如果不存在，它在哈希表中插入该字符，它的 value 为 1。</li>
<li>查找第一个只出现一次的字符时，按照 s 的顺序，依次查找 map 中字符出现的次数，当 value 为 1 时，该字符就是第一个只出现一次的字符。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;Character, Integer&amp;gt;();</span><br><span class="line">    StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s.append(ch);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 删除链表中重复的结点</title>
    <url>/deleteduplication/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li><p>首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况</p>
</li>
<li><p>设置 first ，second 指针， first 指针指向当前确定不重复的那个节点，而second指针相当于工作指针，一直往后面搜索。</p>
<p>![](<img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftpyv97q6rj30uy0cqdgb.jpg" alt=""></p>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = first.next;</span><br><span class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(second.next != <span class="keyword">null</span> &amp;&amp; second.val == second.next.val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(second.next != <span class="keyword">null</span> &amp;&amp; second.val == second.next.val)&#123;</span><br><span class="line">                    second = second.next;</span><br><span class="line">                &#125;</span><br><span class="line">                first.next = second.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 和为S的两个数字</title>
    <url>/findnumberswithsum/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>法一：哈希法。用一个HashMap，它的 key 存储数S与数组中每个数的差，value 存储当前的数字，比较S=15, 当前的数为 4，则往 hashmap 中插入(key=11, value=4)。我们遍历数组，判断hashmap 中的 key 是否存在当前的数字，如果存在，说明存在着另一个数与当前的数相加和为 S，我们就可以判断它们的乘积是否小于之前的乘积，如果小的话就替换之前的找到的数字，如果大就放弃当前找到的。如果hashmap 中的 key 不存在当前的数字，说明还没有找到相加和为 S 的两个数，那就把S与当前数字的差作为 key，当前数字作为 value 插入到 hashmap 中，继续遍历。</p>
<p>法二：左右夹逼的方法。a+b=sum，a和b越远乘积越小，因为数组是递增排序，所以一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况。</p>
<p>若ai + aj == sum，就是答案（相差越远乘积越小）</p>
<p>若ai + aj &gt; sum，说明 aj 太大了，j &#8212;</p>
<p>若ai + aj &lt; sum，说明 ai 太小了，i ++</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; FindNumbersWithSum(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&amp;lt;Integer, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;Integer, Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> less = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i] * map.get(array[i]) &amp;lt; less)&#123;</span><br><span class="line">                    less = array[i] * map.get(array[i]);</span><br><span class="line">                    res.clear();</span><br><span class="line">                    res.add(map.get(array[i]));</span><br><span class="line">                    res.add(array[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> key = sum - array[i];</span><br><span class="line">                map.put(key, array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：左右夹逼</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; FindNumbersWithSum(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length &amp;lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] + array[j] == sum)&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">                res.add(array[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i] + array[j] &amp;lt; sum)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 孩子们的游戏(圆圈中最后剩下的数)</title>
    <url>/lastremaining_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0&#8230;m-1报数&#8230;.这样下去&#8230;.直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用环形链表模拟圆圈。创建一个总共有 n 个结点的环形链表，然后每次在这个链表中删除第 m 个结点。注意，起步是-1 不是 0。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp;lt; <span class="number">1</span> || m &amp;lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; link = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; n; i++)</span><br><span class="line">            link.add(i);</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;   <span class="comment">//起步是 -1 不是 0</span></span><br><span class="line">        <span class="keyword">while</span>(link.size() &amp;gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index + m) % link.size();  <span class="comment">//对 link的长度求余不是对 n</span></span><br><span class="line">            link.remove(index);</span><br><span class="line">            index --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> link.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数组中重复的数字</title>
    <url>/duplicate/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>最简单的就是用一个数组或者哈希表来存储已经遍历过的数字，但是这样需要开辟额外的空间。</p>
<p>如果题目要求不能开辟额外的空间，那我们可以用如下的方法：</p>
<p>因为数组中的数字都在0~n-1的范围内，所以，如果数组中没有重复的数，那当数组排序后，数字i将出现在下标为i的位置。现在我们重排这个数组，从头到尾扫描每个数字，当扫描到下标为i的数字时，首先比较这个数字(记为m)是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和m 位置上的数字进行比较，如果它们相等，就找到了一个重复的数字（该数字在下标为i和m的位置都出现了），返回true；如果它和m位置上的数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再继续循环，直到最后还没找到认为没找到重复元素，返回false。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i != numbers[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[numbers[i]];</span><br><span class="line">                    numbers[numbers[i]] = numbers[i];</span><br><span class="line">                    numbers[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 把二叉树打印成多行</title>
    <url>/print/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>就是二叉树的层序遍历，用队列来实现。我们需要两个变量，一个start记录当前层已经打印的节点个数，一个end记录前当层所有的节点个数，当 start == end 时，表时当前层遍历完了，就可以开始下一层遍历。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; layer = <span class="keyword">new</span> LinkedList&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        layer.offer(pRoot);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!layer.isEmpty())&#123;</span><br><span class="line">            TreeNode node = layer.poll();</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            start ++;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                layer.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                layer.add(node.right);</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                start = <span class="number">0</span>;</span><br><span class="line">                res.add(temp);</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">                end = layer.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 对称的二叉树</title>
    <url>/issymmetrical/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>法一：递归。根节点的左右子树相同，左子树的左子树和右子树的右子树相同，左子树的右子树和右子树的左子树相同即可。</p>
<p>法二：非递归。非递归也是一样，采用栈或队列存取各级子树根节点。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val == right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSymmetrical(left.left, right.right) &amp;&amp; </span><br><span class="line">                isSymmetrical(left.right, right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：非递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; s = <span class="keyword">new</span> Stack&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        s.push(pRoot.left);</span><br><span class="line">        s.push(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">            TreeNode right = s.pop();</span><br><span class="line">            TreeNode left = s.pop();</span><br><span class="line">            <span class="keyword">if</span>(right == <span class="keyword">null</span> &amp;&amp; left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(right == <span class="keyword">null</span> || left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(right.val != left.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            s.push(left.left);</span><br><span class="line">            s.push(right.right);</span><br><span class="line">            s.push(left.right);</span><br><span class="line">            s.push(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 不用加减乘除做加法</title>
    <url>/add/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用位运算来实现。</p>
<ul>
<li>step1: 进行异或运算，计算两个数各个位置上的相加，不考虑进位；</li>
<li>step2: 进行位与运算，然后左移一位，计算进位值；</li>
<li>step3: 把异或运算的结果赋给 num1，把进位值赋给 num2，依此循环，进位值为空的时候结束循环，num1就是两数之和。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            carry = (num1 &amp; num2) &amp;lt;&amp;lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>位运算</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数组中只出现一次的数字</title>
    <url>/findnumsappearonce/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>法一：大家都能想到的HashMap法</p>
<p>法二：异或法</p>
<blockquote>
<p>任何一个数字异或它自己都等于0。 </p>
</blockquote>
<p>如果数组中只一个数字是只出现一次的，其他数字都是成双成对出现的，那么我们从头到尾依次异或数组中的每个数字，最终的结果刚好就是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了。</p>
<p>那么回到我们的题目，因为有两个只出现一次的数字，所以我们可以试着把原数组分成两个子数组，使得每个数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果这样拆分成两个数组，那么我们就可以按照之前的办法分别对两个数组进行异或运算找出两个只出现一次的数字。</p>
<p>问题来了，如何进行分组呢？</p>
<p>我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字异或的结果。由于这两个数字不一样，所以异或的结果至少有一位为1，我们在结果数字中找到第一个为1的位置，记为index位，现在我们以第index位是不是1为标准把原数组拆分成两个子数组，第一个子数组中的数组第index位都为1，第二个子数组中的数组第index位都为0，那么只出现一次的数字将被分配到两个子数组中去，于是每个子数组中只包含一个出现一次的数字，而其他数字都出现两次。这样我们就可以用之前的方法找到数组中只出现一次的数字了。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：hashmap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        HashMap&amp;lt;Integer, Integer&amp;gt; temp = <span class="keyword">new</span> HashMap&amp;lt;Integer, Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.containsKey(array[i]))</span><br><span class="line">                temp.remove(array[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp.put(array[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span> [array.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer k: temp.keySet())&#123;</span><br><span class="line">            a[i] = k;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        num2[<span class="number">0</span>] = a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：异或法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            num ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &amp;lt; <span class="number">8</span>)&#123;</span><br><span class="line">            num = num &amp;gt;&amp;gt; <span class="number">1</span>;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isa1(array[i], index))</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isa1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        i = i &amp;gt;&amp;gt; index;</span><br><span class="line">        <span class="keyword">return</span> (i &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>hashmap</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 翻转单词顺序列</title>
    <url>/reversesentence/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一翻转这些单词顺序可不在行，你能帮助他么？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很简单的题，也没啥好说的，注意一下测试用例为全是空格的情况：&#8221; &#8221;</p>
<blockquote>
<p>trim() : 去除字符串首尾空格</p>
</blockquote>
<blockquote>
<p>split() : 对字符串按照所传参数进行分割 </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        String [] temp = str.split(<span class="string">" "</span>);</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length - <span class="number">1</span>; i &amp;gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res += temp[i];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">                res += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉搜索树的第k个结点</title>
    <url>/kthnode/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为二叉搜索树按照中序遍历的顺序打印出来就是排好序的，所以，我们按照中序遍历找到第k个结点就是题目所求的结点。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode node = KthNode(pRoot.left, k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            index ++;</span><br><span class="line">            <span class="keyword">if</span>(index == k)</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            node = KthNode(pRoot.right, k);</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数据流中的中位数</title>
    <url>/getmedian/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们可以将数据排序后分为两部分，左边部分的数据总是比右边的数据小。那么，我们就可以用最大堆和最小堆来装载这些数据：</p>
<ul>
<li>最大堆装左边的数据，取出堆顶（最大的数）的时间复杂度是O(1)</li>
<li>最小堆装右边的数据，同样，取出堆顶（最小的数）的时间复杂度是O(1)</li>
</ul>
<p>从数据流中拿到一个数后，先按顺序插入堆中：如果左边的最大堆是否为空或者该数小于等于最大堆顶的数，则把它插入最大堆，否则插入最小堆。然后，我们要保证左边的最大堆的size等于右边的最小堆的size或者最大堆的size比最小堆的size大1。</p>
<p>要获取中位数的话，直接判断最大堆和最小堆的size，如果相等，则分别取出两个堆的堆顶除以2得到中位数，不然，就是最大堆的size要比最小堆的size大，这时直接取出最大堆的堆顶就是我们要的中位数。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小堆（右）</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&amp;lt;Integer&amp;gt; rHeap = <span class="keyword">new</span> PriorityQueue&amp;lt;&amp;gt;(); </span><br><span class="line">    <span class="comment">// 最大堆（左）</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&amp;lt;Integer&amp;gt; lHeap = <span class="keyword">new</span> PriorityQueue&amp;lt;Integer&amp;gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&amp;lt;Integer&amp;gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 保证lHeap.size()&amp;gt;=rHeap.size()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先按大小插入，再调整</span></span><br><span class="line">        <span class="keyword">if</span>(lHeap.isEmpty() || num &amp;lt;= lHeap.peek())</span><br><span class="line">            lHeap.offer(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rHeap.offer(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lHeap.size() &amp;lt; rHeap.size())&#123;</span><br><span class="line">            lHeap.offer(rHeap.peek());</span><br><span class="line">            rHeap.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lHeap.size() - rHeap.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            rHeap.offer(lHeap.peek());</span><br><span class="line">            lHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lHeap.size() &amp;gt; rHeap.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(lHeap.peek());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(lHeap.peek() + rHeap.peek())/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
        <tag>最大堆</tag>
        <tag>最小堆</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 滑动窗口的最大值</title>
    <url>/maxinwindows/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>法一：简单的暴力法</p>
<p>法二：双向队列</p>
<p>用一个双向队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次，判断当前最大值是否过期（当前最大值的位置是不是在窗口之外），新增加的值从队尾开始比较，把所有比他小的值丢掉。这样时间复杂度为O(n)。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：简单的暴力法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; maxInWindows(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length &amp;lt; size || size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; num.length - size + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            res.add(max(num, i, size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = num[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span>; i &amp;lt; index + size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &amp;gt; res)</span><br><span class="line">                res = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：双向队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; maxInWindows(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)&#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        LinkedList&amp;lt;Integer&amp;gt; deque = <span class="keyword">new</span> LinkedList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length == <span class="number">0</span> || size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; num.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst() &amp;lt;= i - size)</span><br><span class="line">                deque.poll();</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; num[deque.peekLast()] &amp;lt; num[i])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &amp;gt;= size)</span><br><span class="line">                res.add(num[deque.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 矩阵中的路径</title>
    <url>/haspath/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&#8221;bcced&#8221;的路径，但是矩阵中不包含&#8221;abcb&#8221;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>回溯法：</p>
<ol>
<li><p>将matrix字符串映射为一个字符矩阵（<code>index = i * cols + j</code>）</p>
</li>
<li><p>遍历matrix的每个坐标，与str的首个字符对比，如果相同，用flag做标记，matrix的坐标分别上、下、左、右、移动（判断是否出界或者之前已经走过[flag的坐标为1]），再和str的下一个坐标相比，直到str全部对比完，即找到路径，否则找不到。</p>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] flag = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(search(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">int</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m_i = i * cols + j;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;lt;<span class="number">0</span> || j&amp;lt;<span class="number">0</span> || i &amp;gt;= rows || j&amp;gt;=cols || flag[i][j] == <span class="number">1</span> || matrix[m_i] != str[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &amp;gt;= str.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        flag[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(search(matrix, rows, cols, i+<span class="number">1</span>, j, str, index+<span class="number">1</span>, flag) || </span><br><span class="line">            search(matrix, rows, cols, i-<span class="number">1</span>, j, str, index+<span class="number">1</span>, flag) || </span><br><span class="line">            search(matrix, rows, cols, i, j+<span class="number">1</span>, str, index+<span class="number">1</span>, flag) || </span><br><span class="line">            search(matrix, rows, cols, i, j-<span class="number">1</span>, str, index+<span class="number">1</span>, flag))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        flag[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 机器人的运动范围</title>
    <url>/movingcount/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>回溯法：从(0,0)开始走，每成功走一步用一个flag数组标记当前位置为1，然后从当前位置往四个方向探索，</p>
<p>返回1 + 4 个方向的探索值之和。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(threshold == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag[][] = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> count(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;lt;<span class="number">0</span> || j&amp;lt;<span class="number">0</span> || i&amp;gt;=rows || j&amp;gt;=cols || sum(i)+sum(j) &amp;gt; threshold || flag[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + count(threshold, rows, cols, i - <span class="number">1</span>, j, flag) + </span><br><span class="line">            count(threshold, rows, cols, i + <span class="number">1</span>, j, flag) +</span><br><span class="line">            count(threshold, rows, cols, i, j - <span class="number">1</span>, flag) +</span><br><span class="line">            count(threshold, rows, cols, i, j + <span class="number">1</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&amp;gt;<span class="number">0</span>)&#123;</span><br><span class="line">            s += i%<span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 链表中环的入口结点</title>
    <url>/entrynodeofloop/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>一种方法是用 hashmap来存储和查找节点;</p>
<p>另一种方法是双指针法。</p>
<p>假设环长度为<code>n</code>，进入环之前结点个数为<code>x</code>,slow在环内走了<code>k</code>个结点,fast绕环走了<code>m</code>圈,则有<code>2(x+k)=x+mn+k</code> 可以得出<code>x = mn - k</code>。此时slow距入口结点还剩 <code>n-k</code>个结点,<code>x=(m−1)n+n−k</code>，即一个指针从链表头节点走到环入口的长度等于另一个指针从相遇的位置走 <code>m-1</code>圈后再走<code>n-k</code>的长度，也就是说两个指针相遇后，让一个指针回到头节点，另一个指针不动，然后他们同时往前每次走一步，当他们相遇时，相遇的节点即为环入口节点。</p>
<p>所以，我们设置两个指针，一个是快指针fast，一个是慢指针slow，fast一次走两步，slow一次走一步，如果单链表有环那么当两个指针相遇时一定在环内。此时将一个指针指到链表头部，另一个不变，二者同时每次向前移一格,当两个指针再次相遇时即为环的入口节点。如果fast走到null则无环。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead.next == <span class="keyword">null</span> || pHead.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = pHead.next;</span><br><span class="line">        ListNode fast = pHead.next.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 正则表达式匹配</title>
    <url>/match/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来匹配包括&#8217;.&#8217;和&#8217;&#42;&#8217;的正则表达式。模式中的字符&#8217;.&#8217;表示任意一个字符，而&#8217;&#42;&#8217;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&#8221;aaa&#8221;与模式&#8221;a.a&#8221;和&#8221;ab&#42;ac&#42;a&#8221;匹配，但是与&#8221;aa.a&#8221;和&#8221;ab&#42;a&#8221;均不匹配</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>当模式中的第二个字符不是“&#42;”时：</p>
<p>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</p>
<p>2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<p>而当模式中的第二个字符是“&#42;”时：</p>
<p>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</p>
<p>1、模式后移2字符，相当于x&#42;被忽略；</p>
<p>2、字符串后移1字符，模式后移2字符；</p>
<p>3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sindex = <span class="number">0</span>, pindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, sindex, pindex, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> sindex, <span class="keyword">int</span> pindex, <span class="keyword">char</span>[] pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sindex &amp;gt;= str.length &amp;&amp; pindex == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pindex &amp;gt;= pattern.length &amp;&amp; sindex &amp;lt; str.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pindex+<span class="number">1</span> &amp;lt; pattern.length &amp;&amp; pattern[pindex+<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sindex &amp;lt; str.length &amp;&amp; (str[sindex] == pattern[pindex] || pattern[pindex] == <span class="string">'.'</span>) )&#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, sindex, pindex+<span class="number">2</span>, pattern) ||</span><br><span class="line">                    matchCore(str, sindex+<span class="number">1</span>, pindex+<span class="number">2</span>, pattern ) ||</span><br><span class="line">                    matchCore(str, sindex+<span class="number">1</span>, pindex, pattern);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, sindex, pindex+<span class="number">2</span>, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sindex &amp;lt; str.length &amp;&amp; (str[sindex] == pattern[pindex] || pattern[pindex] == <span class="string">'.'</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, sindex+<span class="number">1</span>, pindex+<span class="number">1</span>, pattern);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考牛客网@披萨大叔</p>
</blockquote>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>正则匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 13: Permission denied 解决方案</title>
    <url>/nginx-13-permission-denied/</url>
    <content><![CDATA[<p>今天在用uwsgi+nginx在部署flask应用时，遇到502的错误，<code>vim /var/log/nginx/error.log</code>查看nginx的错误日志，提示如下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018&#x2F;07&#x2F;22 00:46:36 [crit] 15890#15890: *74 connect() to unix:&#x2F;root&#x2F;jianshuvue&#x2F;jianshu.sock failed (13: Permission denied) while connecting to upstream, client: 120.42.13.98, server: jianshu.weiweiblog.cn, request: &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;, upstream: &quot;uwsgi:&#x2F;&#x2F;unix:&#x2F;root&#x2F;jianshuvue&#x2F;jianshu.sock:&quot;, host: &quot;jianshu.weiweiblog.cn&quot;, referrer: &quot;http:&#x2F;&#x2F;jianshu.weiweiblog.cn&#x2F;jianshu&#x2F;67eb7ed414d3&quot;</span><br></pre></td></tr></table></figure>

<p>Permission denied，一看就知道是权限出了问题，通过<code>ps -ef | grep nginx</code>,查看nginx的进程信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root     15889     1  0 00:01 ?        00:00:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -g daemon on; master_process on;</span><br><span class="line">www-data 15890 15889  0 00:01 ?        00:00:00 nginx: worker process</span><br><span class="line">root     16795 15654  0 00:48 pts&#x2F;3    00:00:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>

<p>发现nginx进程的用户是nginx，而我们创建/root/jianshuvue/jianshu.sock文件的用户是root，因此，只要把nginx的进程user改为root即可，<code>vim /etc/nginx/nginx.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 # user www-data;</span><br><span class="line">2 user root;</span><br><span class="line">3 worker_processes auto;</span><br><span class="line">4 pid &#x2F;run&#x2F;nginx.pid;</span><br></pre></td></tr></table></figure>

<p>之后，<code>/etc/init.d/nginx restart</code>重启nginx，就可以正常访问网站了。</p>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>nginx</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv -p python3 venv报错</title>
    <url>/virtualenv-p-python3-venv/</url>
    <content><![CDATA[<p>在阿里云服务器上，用virtualenv创建虚拟环境时，报了个错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@iZwz982qla1uxm1s5dnyo7Z:&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv-15.0.1.egg-info# virtualenv -p python3 venv</span><br><span class="line">Running virtualenv with interpreter &#x2F;usr&#x2F;bin&#x2F;python2</span><br><span class="line">New python executable in &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv-15.0.1.egg-info&#x2F;venv&#x2F;bin&#x2F;python2</span><br><span class="line">Not overwriting existing python script &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv-15.0.1.egg-info&#x2F;venv&#x2F;bin&#x2F;python (you must use &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv-15.0.1.egg-info&#x2F;venv&#x2F;bin&#x2F;python2)</span><br><span class="line">Please make sure you remove any previous custom paths from your &#x2F;root&#x2F;.pydistutils.cfg file.</span><br><span class="line">  1 [global]</span><br><span class="line">Installing setuptools, pkg_resources, pip, wheel...</span><br><span class="line">  Complete output from command &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dis...nfo&#x2F;venv&#x2F;bin&#x2F;python2 - setuptools pkg_resources pip wheel:</span><br><span class="line">  Collecting setuptools</span><br><span class="line">  Downloading http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;packages&#x2F;ff&#x2F;f4&#x2F;385715ccc461885f3cedf57a41ae3c12b5fec3f35cce4c8706b1a112a133&#x2F;setuptools-40.0.0-py2.py3-none-any.whl (567kB)</span><br><span class="line">Collecting pkg_resources</span><br><span class="line">Exception:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;basecommand.py&quot;, line 209, in main</span><br><span class="line">    status &#x3D; self.run(options, args)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;commands&#x2F;install.py&quot;, line 328, in run</span><br><span class="line">    wb.build(autobuilding&#x3D;True)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;wheel.py&quot;, line 748, in build</span><br><span class="line">    self.requirement_set.prepare_files(self.finder)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;req&#x2F;req_set.py&quot;, line 360, in prepare_files</span><br><span class="line">    ignore_dependencies&#x3D;self.ignore_dependencies))</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;req&#x2F;req_set.py&quot;, line 512, in _prepare_file</span><br><span class="line">    finder, self.upgrade, require_hashes)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;req&#x2F;req_install.py&quot;, line 273, in populate_link</span><br><span class="line">    self.link &#x3D; finder.find_requirement(self, upgrade)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;index.py&quot;, line 442, in find_requirement</span><br><span class="line">    all_candidates &#x3D; self.find_all_candidates(req.name)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;index.py&quot;, line 400, in find_all_candidates</span><br><span class="line">    for page in self._get_pages(url_locations, project_name):</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;index.py&quot;, line 545, in _get_pages</span><br><span class="line">    page &#x3D; self._get_page(location)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;index.py&quot;, line 648, in _get_page</span><br><span class="line">    return HTMLPage.get_page(link, session&#x3D;self.session)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;share&#x2F;python-wheels&#x2F;pip-8.1.1-py2.py3-none-any.whl&#x2F;pip&#x2F;index.py&quot;, line 760, in get_page</span><br><span class="line">    resp.raise_for_status()</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv-15.0.1.egg-info&#x2F;venv&#x2F;share&#x2F;python-wheels&#x2F;requests-2.9.1-py2.py3-none-any.whl&#x2F;requests&#x2F;models.py&quot;, line 840, in raise_for_status</span><br><span class="line">    raise HTTPError(http_error_msg, response&#x3D;self)</span><br><span class="line">HTTPError: 404 Client Error: Not Found for url: http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;pkg-resources&#x2F;</span><br><span class="line">----------------------------------------</span><br><span class="line">...Installing setuptools, pkg_resources, pip, wheel...done.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv.py&quot;, line 2363, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv.py&quot;, line 719, in main</span><br><span class="line">    symlink&#x3D;options.symlink)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv.py&quot;, line 988, in create_environment</span><br><span class="line">    download&#x3D;download,</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv.py&quot;, line 918, in install_wheel</span><br><span class="line">    call_subprocess(cmd, show_stdout&#x3D;False, extra_env&#x3D;env, stdin&#x3D;SCRIPT)</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;virtualenv.py&quot;, line 812, in call_subprocess</span><br><span class="line">    % (cmd_desc, proc.returncode))</span><br><span class="line">OSError: Command &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dis...nfo&#x2F;venv&#x2F;bin&#x2F;python2 - setuptools pkg_resources pip wheel failed with error code 2</span><br></pre></td></tr></table></figure>

<p>看到<code>HTTPError: 404 Client Error: Not Found for url: http://mirrors.aliyun.com/pypi/simple/pkg-resources/</code>以为是阿里云的安全组配置没配好，折腾了半天，原来是访问PyPI镜像源出了问题，将pip的默认的源地址改为国内源即可。具体操作如下：</p>
<p><code>vim ~/.pip/pip.conf</code>打开pip配置文件:</p>
<p>写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;e.pypi.python.org&#x2F;simple</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下这几个国内源都可以</p>
</blockquote>
<blockquote>
<p>e.pypi.python.org</p>
</blockquote>
<blockquote>
<p>pypi.douban.com</p>
</blockquote>
<blockquote>
<p>pypi.hustunique.com</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数字在排序数组中出现的次数</title>
    <url>/getnumberofk/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在排序数组中出现的次数。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>正常的思路就是二分查找了，我们用递归的方法实现了查找k第一次出现的下标，用循环的方法实现了查找k最后一次出现的下标。</p>
<p>除此之外，还有另一种奇妙的思路，因为data中都是整数，所以我们不用搜索k的两个位置，而是直接搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first = getFirst(array, k, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = getLast(array, k, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(first != -<span class="number">1</span> &amp;&amp; last != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt;= end)&#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &amp;lt;= array[mid])</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start &amp;lt; array.length &amp;&amp; array[start] == k)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt;= end)&#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &amp;gt;= array[mid])</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end &amp;gt;= <span class="number">0</span> &amp;&amp; array[end] == k)</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biSearch(array, k+<span class="number">0.5</span>) - biSearch(array, k-<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">double</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start  = <span class="number">0</span>, end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &amp;gt; k)&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>二分查找</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 两个链表的第一个公共结点</title>
    <url>/findfirstcommonnode/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果两个链表存在公共结点，那么它们从公共结点开始一直到链表的结尾都是一样的，因此我们只需要从链表的结尾开始，往前搜索，找到最后一个相同的结点即可。但是题目给出的单向链表，我们只能从前向后搜索，这时，我们就可以借助栈来完成。先把两个链表依次装到两个栈中，然后比较两个栈的栈顶结点是否相同，如果相同则出栈，如果不同，那最后相同的结点就是我们要的返回值。</p>
<p>还有一种方法，不需要借助栈。先找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走，直到找到第一个公共结点。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法1：Stack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        Stack&amp;lt;ListNode&amp;gt; s1 = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        Stack&amp;lt;ListNode&amp;gt; s2 = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(pHead1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(pHead1);</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pHead2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(pHead2);</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty() &amp;&amp; s1.peek() == s2.peek())&#123;</span><br><span class="line">            s1.pop();</span><br><span class="line">            res = s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">1</span>, count2 = <span class="number">1</span>;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1&amp;gt;count2)&#123;</span><br><span class="line">            <span class="keyword">int</span> dif = count1 - count2;</span><br><span class="line">            <span class="keyword">while</span>(dif != <span class="number">0</span>)&#123;</span><br><span class="line">                pHead1 = pHead1.next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dif = count2 - count1;</span><br><span class="line">            <span class="keyword">while</span>(dif != <span class="number">0</span>)&#123;</span><br><span class="line">                pHead2 = pHead2.next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pHead1 != <span class="keyword">null</span> &amp;&amp; pHead2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1 == pHead2)</span><br><span class="line">                <span class="keyword">return</span> pHead1;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数组中的逆序对</title>
    <url>/inversepairs/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>输入描述:</p>
<p>题目保证输入的数组中没有的相同的数字</p>
<h5 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h5><pre><code>对于%50的数据,size&lt;=10^4

对于%75的数据,size&lt;=10^5

对于%100的数据,size&lt;=2*10^5</code></pre><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>输入</p>
<blockquote>
<p>1,2,3,4,5,6,7,0 </p>
</blockquote>
<p>输出</p>
<blockquote>
<p>7 </p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很容易想到的方法就是遍历每一个元素，让其与后面的元素对比，如果大于则count++，但是这样的时间复杂度是O(n^2)，因此，我们可以用归并排序思路。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftay375qnij30h607waae.jpg" alt=""></p>
<p>例如7,5,4,6可以划分为两段7,5和4,6两个子数组</p>
<ol>
<li>在7,5中求出逆序对，因为7大于5所以有1对</li>
<li>在6,4中求出逆序对，因为6大于4所以逆序对再加1，为2</li>
<li>对7,5和6,4进行排序，结果为5,7,和4,6</li>
<li>设置两个指针分别指向两个子数组中的最大值，p1指向7，p2指向6</li>
<li>比较p1和p2指向的值，如果大于p2，因为p2指向的是最大值，所以第二个子数组中有几个元素就有几对逆序对(当前有两个元素，逆序对加2,2+2=4)，7&gt;6,比较完之后将p1指向的值放入辅助数组里，辅助数组里现在有一个数字7，然后将p1向前移动一位指向5</li>
<li>再次判断p1和p2指向的值，p1小于p2，因为p1指向的是第一个子数组中最大值，所以子数组中没有能和当前p2指向的6构成逆序对的数，将p2指向的值放入辅助数组，并向前移动一位指向4，此时辅助数组内为6,7</li>
<li>继续判断p1(指向5)和p2(指向4)，5&gt;4,第二个子数组中只有一个数字，逆序对加1，4+1=5，为5对，然后将5放入辅助数组，第一个子数组遍历完毕，只剩下第二个子数组，当前只有一个4，将4也放入辅助数组，函数结束。辅助数组此时为4,5,6,7.逆序对为5.</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(array== <span class="keyword">null</span> || len &amp;lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(array, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_count = mergeSort(array, start, mid);</span><br><span class="line">        <span class="keyword">int</span> right_count = mergeSort(array, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">int</span> i = mid, j = end;</span><br><span class="line">        <span class="keyword">int</span> [] copy = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> copy_index = end - start;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;gt;= start &amp;&amp; j &amp;gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &amp;gt; array[j])&#123;</span><br><span class="line">                copy[copy_index--] = array[i--];</span><br><span class="line">                count += j - mid;</span><br><span class="line">                <span class="keyword">if</span>(count &amp;gt; <span class="number">1000000007</span>)&#123;</span><br><span class="line">                    count %= <span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[copy_index--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;gt;= start)&#123;</span><br><span class="line">            copy[copy_index--] = array[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">            copy[copy_index--] = array[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &amp;lt;= end) &#123;</span><br><span class="line">            array[start++] = copy[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left_count+right_count+count)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 第一个只出现一次的字符</title>
    <url>/firstnotrepeatingchar/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数。也可以用数组代替hash表。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&amp;lt;Character, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(str.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> value = map.get(str.charAt(i));</span><br><span class="line">                map.put(str.charAt(i), value+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(str.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> [] s = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> [] m = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            m[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 丑数</title>
    <url>/getuglynumber_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>判断一个数是不是丑数，最简单的方法就是让这个数不断除以2，3，5。要求第N个丑数，只要从1开始，依次判断每个数是不是丑数，如果是，则相应的序号加1，直到序号为N，就是我们要的丑数了。但是这种方法时间效率很，通常面试官不会满意这样的答案。因此我们需要一个时间复杂度更低的解法。</p>
<p>换个思路，我们只求丑数，不要去管非丑数。每个丑数必然是由小于它的某个丑数乘以2，3或5得到的，这样我们把求得的丑数都保存下来，用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个我们要求的丑数。这种方法用空间换时间，时间复杂度为O(n)。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &amp;lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&amp;lt;index; i++)&#123;</span><br><span class="line">            res[i] = Math.min(res[t2]*<span class="number">2</span>, Math.min(res[t3]*<span class="number">3</span>, res[t5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t2]*<span class="number">2</span>) t2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t3]*<span class="number">3</span>) t3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t5]*<span class="number">5</span>) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态规划</tag>
        <tag>剑指offer</tag>
        <tag>丑数</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 把数组排成最小的数</title>
    <url>/printminnumber/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先将数组转换成字符串数组，然后对字符串数组按照规则排序，最后将排好序的字符串数组拼接出来。</p>
<p>关键就是制定排序规则：</p>
<ul>
<li>若ab &gt; ba 则 a &gt; b</li>
<li>若ab &lt; ba 则 a &lt; b</li>
<li>若ab = ba 则 a = b</li>
</ul>
<blockquote>
<p>解释说明：</p>
</blockquote>
<blockquote>
<p>a = 21</p>
</blockquote>
<blockquote>
<p>b = 2</p>
</blockquote>
<blockquote>
<p>因为 212 &lt; 221, 即 ab &lt; ba ，所以 a &lt; b</p>
</blockquote>
<blockquote>
<p>所以我们通过对ab和ba比较大小，来判断a在前或者b在前的。 </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(numbers[<span class="number">0</span>]);</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String [] str = <span class="keyword">new</span> String[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;len; i++)</span><br><span class="line">            str[i] = String.valueOf(numbers[i]);</span><br><span class="line">        Arrays.sort(str, <span class="keyword">new</span> Comparator&amp;lt;String&amp;gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                String c1 = s1 + s2;</span><br><span class="line">                String c2 = s2 + s1;</span><br><span class="line">                <span class="keyword">return</span> c1.compareTo(c2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;len; i++)</span><br><span class="line">            res.append(str[i]);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <url>/numberof1between1andn_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>三种解法：</p>
<ul>
<li>法一：依次遍历每个数，判断每个数里面是否包含1</li>
<li>法二：同法一，将数字转成字符串，直接判断</li>
<li>法三：归纳法</li>
</ul>
<blockquote>
<p>设N = abcde ,其中abcde分别为十进制中各位上的数字。</p>
</blockquote>
<blockquote>
<p>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。</p>
</blockquote>
<blockquote>
<p>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，&#8230;，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</p>
</blockquote>
<blockquote>
<p>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，&#8230;.，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。</p>
</blockquote>
<blockquote>
<p>③ 如果百位上数字大于1（2<del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100</del>199,1100<del>1199，2100</del>2199，&#8230;，11100<del>11199,12100</del>12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。</p>
</blockquote>
<blockquote>
<p>——参考牛客网@藍裙子的百合魂 </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= n; i++)</span><br><span class="line">            res += number1(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">number1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&amp;gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&amp;lt;=n; i++)&#123;</span><br><span class="line">            s.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String str = s.toString();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">'1'</span>)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, before = <span class="number">0</span>, after = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&amp;lt;=n)&#123;</span><br><span class="line">            before = n/(i*<span class="number">10</span>);</span><br><span class="line">            cur = (n/i)%<span class="number">10</span>;</span><br><span class="line">            after = n - n/i*i;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span></span><br><span class="line">                res += before * i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果为1, 出现1的次数由高位和低位决定,高位*当前位+低位+1</span></span><br><span class="line">                res += before * i + after + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果大于1, 出现1的次数由高位决定,（高位数字+1）* 当前位数</span></span><br><span class="line">                res += (before + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">            i *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 连续子数组的最大和</title>
    <url>/findgreatestsumofsubarray/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于一个数组中的一个数x，若是x的左边的数加起来非负，那么加上x能使得值变大，这样我们认为x之前的数的和对整体和是有贡献的。如果前几项加起来是负数，则认为有害于总和。</p>
<p>我们用cur记录当前值, 用max记录最大值，如果cur&lt;0,则舍弃之前的数，让cur等于当前的数字，否则，cur = cur+当前的数字。若cur和大于max更新max。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = array[<span class="number">0</span>], max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;array.length; i++)&#123;</span><br><span class="line">            cur = cur &amp;gt; <span class="number">0</span> ? cur + array[i] : array[i];</span><br><span class="line">            <span class="keyword">if</span>(max &amp;lt; cur)</span><br><span class="line">                max = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 最小的K个数</title>
    <url>/getleastnumbers_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>两种方法：</p>
<ul>
<li>法1：先对数组排序，然后取出前k个</li>
<li>法2：利用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || k ==<span class="number">0</span> || k &amp;gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; GetLeastNumbers_Solution(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || k ==<span class="number">0</span> || k &amp;gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PriorityQueue&amp;lt;Integer&amp;gt; maxHeap = <span class="keyword">new</span> PriorityQueue&amp;lt;Integer&amp;gt;(k, <span class="keyword">new</span> Comparator&amp;lt;Integer&amp;gt;() &#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1, Integer e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e2 - e1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;input.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() != k)</span><br><span class="line">                maxHeap.offer(input[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(maxHeap.peek() &amp;gt; input[i])&#123;</span><br><span class="line">                    maxHeap.poll();</span><br><span class="line">                    maxHeap.offer(input[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer i: maxHeap)&#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>最大堆</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数组中出现次数超过一半的数字</title>
    <url>/morethanhalfnum_solution/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>三种解法：</p>
<ul>
<li>法1：借助hashmap存储数组中每个数出现的次数，最后看是否有数字出现次数超过数组长度的一半；</li>
<li>法2：排序。数组排序后，如果某个数字出现次数超过数组的长度的一半，则一定会数组中间的位置。所以我们取出排序后中间位置的数，统计一下它的出现次数是否大于数组长度的一半；</li>
<li>法3：某个数字出现的次数大于数组长度的一半，意思就是它出现的次数比其他所有数字出现的次数和还要多。因此我们可以在遍历数组的时候记录两个值：1. 数组中的数字;2. 次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。最后再判断它是否符合条件。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        HashMap&amp;lt;Integer, Integer&amp;gt; map = <span class="keyword">new</span> HashMap&amp;lt;Integer, Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(array[i]))</span><br><span class="line">                map.put(array[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(array[i], map.get(array[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()*<span class="number">2</span>&amp;gt;length)</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="keyword">int</span> half = array.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == array[half])</span><br><span class="line">                count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &amp;gt; half)</span><br><span class="line">            <span class="keyword">return</span> array[half];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = array[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == res)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                res = array[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == res)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &amp;gt; array.length/<span class="number">2</span> ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>Array</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>手动生成sitemap</title>
    <url>/python_sitemap/</url>
    <content><![CDATA[<p>本来google的插件是很好用的，但无奈我的wordpress主题好像有问题，安装<code>Google XML Sitemaps</code>后，访问sitemap.xml页面会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error on line 2 at column 6: XML declaration allowed only at the start of the document</span><br></pre></td></tr></table></figure>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5qyiaubwj31cq0g8dgz.jpg" alt=""></p>
<blockquote>
<p>如果你也有遇到过同样的问题，并且你有好的解决方案，欢迎与我分享～ </p>
</blockquote>
<p>于是我们利用python手动生成网站的sitemap。</p>
<p>从Github上克隆<code>python-sitemap</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;c4software&#x2F;python-sitemap.git</span><br></pre></td></tr></table></figure>

<h4 id="编写shell-vim-get-sitemap-sh"><a href="#编写shell-vim-get-sitemap-sh" class="headerlink" title="编写shell vim get_sitemap.sh:"></a>编写shell <code>vim get_sitemap.sh</code>:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行main.py，且输出sitemap.xml放到wordpress根目录下</span></span><br><span class="line">/usr/bin/python3 /root/python-sitemap/main.py --domain https://weiweiblog.cn --output /var/www/wordpress/sitemap.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印时间</span></span><br><span class="line">echo "new sitemap get! --" + `date`</span><br></pre></td></tr></table></figure>

<h4 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h4><p><code>crontab -e</code></p>
<p>添加下面一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每天01：01分更新</span><br><span class="line">1 1 * * * bash &#x2F;root&#x2F;python-sitemap&#x2F;get_sitemap.sh &gt;&gt; &#x2F;root&#x2F;python-sitemap&#x2F;crontab.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>这样，就可以每天自动更新网站的sitemap.xml文件了。</p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>Google XML Sitemaps</tag>
        <tag>sitemap</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你用图灵机器人做微信公众号自动回复助手</title>
    <url>/tuling_flask/</url>
    <content><![CDATA[<blockquote>
<p>阅读这篇文章，你将会学会以下内容：</p>
</blockquote>
<blockquote>
<ol>
<li>如何用flask搭建微信公众平台服务</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>如何将在微信公众平台调用图灵机器人</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>如何用uwsgi+supervisor+nginx部署flask应用 </li>
</ol>
</blockquote>
<h3 id="实验前提"><a href="#实验前提" class="headerlink" title="实验前提"></a>实验前提</h3><ul>
<li>一个可供外网访问的主机（比如云服务器）</li>
<li>一个微信公众号</li>
<li>一个图灵机器人账号</li>
</ul>
<h3 id="一、创建图灵机器人"><a href="#一、创建图灵机器人" class="headerlink" title="一、创建图灵机器人"></a>一、创建图灵机器人</h3><p>登陆<a href="http://www.tuling123.com/" target="_blank" rel="noopener">图灵机器人</a>后，在个人主面点击<code>创建机器人</code>：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4q6n6f14j31kw0gqac3.jpg" alt=""></p>
<p>填写相关信息：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4q6msn0rj30pw0m2ab0.jpg" alt=""></p>
<p>创建成功后，会自动跳转到<code>机器人设置</code>界面，在这里你可以对机器人进行个性化定制。其实，图灵机器人提供简单的方法，快速接入微信公众号，这太没有挑战性了，对于喜欢搞事情的我们，肯定不能选择这种方法。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4q6mjjfxj31kw0ywwii.jpg" alt=""></p>
<p>我们将鼠标往下滑，会出现<code>api接入</code>，这个apikey就是我们等等用来接入微信公众号的密钥。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4q6lzdazj31kw0uh41x.jpg" alt=""></p>
<p>至此，图灵机器人准备完毕。</p>
<h3 id="二、接入微信公众号"><a href="#二、接入微信公众号" class="headerlink" title="二、接入微信公众号"></a>二、接入微信公众号</h3><p>跟着<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1472017492_58YV5" target="_blank" rel="noopener">微信公众平台开发文档</a>一步一步往下走即可，只不过，我们这里使用<code>Flask</code>代替<code>web.py</code>。为什么使用<code>Flask</code>?</p>
<blockquote>
<p>喜欢。任性。 </p>
</blockquote>
<p>主要步骤：</p>
<h4 id="1-搭建服务"><a href="#1-搭建服务" class="headerlink" title="1. 搭建服务"></a>1. 搭建服务</h4><p>这里以Ubuntu 16.04.2 LTS的云服务器为例进行说明。</p>
<p>准备环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建项目目录</span><br><span class="line">mkdir -p &#x2F;var&#x2F;www&#x2F;weixin</span><br><span class="line"># 进入项目目录</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;weixin</span><br><span class="line"># 安装virtualenv包管理工具</span><br><span class="line">apt install virtualenv</span><br><span class="line"># 创建项目虚拟环境</span><br><span class="line">virtualenv venv</span><br><span class="line"># 激活环境</span><br><span class="line">source venv&#x2F;bin&#x2F;activate</span><br></pre></td></tr></table></figure>

<p>成功激活环境后，会出现<code>（venv）</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4q6leyiyj30sk046t8u.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装Flask包</span><br><span class="line">pip install flask</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p>使用如下代码创建<code>run.py</code>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行<code>python run.py</code>，这样服务就启动起来了。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4q6l9pwjj30w609cq3i.jpg" alt=""></p>
<p>你可以通过浏览器，输入<code>x.x.x.x:5000</code>来访问你的服务。</p>
<blockquote>
<p>这里的<code>x.x.x.x</code>是你云主机的ip地址，比如<code>100.39.101.123</code>，下同。 </p>
</blockquote>
<p>如果成功，就会看到如下界面：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4q6l33xlj30ic066mx2.jpg" alt=""></p>
<p>接下来，进入<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a>，点击<code>基本配置</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4q6kwkntj30zb0oidhi.jpg" alt=""></p>
<p>点击<code>修改配置</code>，填写服务器基本配置：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4qbw9yv2j319h0qqq4u.jpg" alt=""></p>
<p>这时候，你还没有配置服务器信息，还不能提交。</p>
<p>先放着，我们回到云服务器，打开<code>run.py</code>文件，</p>
<p>添加验证所需要的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/wechat", methods=["GET","POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weixin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:     <span class="comment"># 判断请求方式是GET请求</span></span><br><span class="line">        my_signature = request.args.get(<span class="string">'signature'</span>)     <span class="comment"># 获取携带的signature参数</span></span><br><span class="line">        my_timestamp = request.args.get(<span class="string">'timestamp'</span>)     <span class="comment"># 获取携带的timestamp参数</span></span><br><span class="line">        my_nonce = request.args.get(<span class="string">'nonce'</span>)        <span class="comment"># 获取携带的nonce参数</span></span><br><span class="line">        my_echostr = request.args.get(<span class="string">'echostr'</span>)         <span class="comment"># 获取携带的echostr参数</span></span><br><span class="line"></span><br><span class="line">        token = <span class="string">'Your token'</span>     <span class="comment"># 一定要跟刚刚填写的token一致</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行字典排序</span></span><br><span class="line">        data = [token,my_timestamp ,my_nonce ]</span><br><span class="line">        data.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拼接成字符串</span></span><br><span class="line">        temp = <span class="string">''</span>.join(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行sha1加密</span></span><br><span class="line">        mysignature = hashlib.sha1(temp).hexdigest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">        <span class="keyword">if</span> my_signature == mysignature:</span><br><span class="line">            <span class="keyword">return</span> my_echostr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4qci79x1j313q100who.jpg" alt=""></p>
<p>保存，再运行<code>python run.py</code></p>
<p>回到微信公众平台，点击<code>提交</code>，<code>确定</code>，收到<code>提交成功</code>的提示，表明配置成功。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft4qcy0vrmj30ve0nnq3m.jpg" alt=""></p>
<p>回到云服务器，可以看到微信公众平台往我们的服务器发了一个GET请求，并且我们成功地返回了验证信息。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4qd5jqhmj31kw08tq46.jpg" alt=""></p>
<p>再回到公众平台，点击<code>启用</code>，可以看到<code>服务器配置（已启用）</code>的字样。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4qdetvxbj30zo0sfabu.jpg" alt=""></p>
<p>至此，我们已经成功将我们的服务与微信公众平台连接上了。</p>
<h4 id="2-接入图灵机器人"><a href="#2-接入图灵机器人" class="headerlink" title="2. 接入图灵机器人"></a>2. 接入图灵机器人</h4><p>打开<code>run.py</code>文件，添加代码引入图灵机器人：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/wechat", methods=["GET","POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weixin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:     <span class="comment"># 判断请求方式是GET请求</span></span><br><span class="line">        my_signature = request.args.get(<span class="string">'signature'</span>)     <span class="comment"># 获取携带的signature参数</span></span><br><span class="line">        my_timestamp = request.args.get(<span class="string">'timestamp'</span>)     <span class="comment"># 获取携带的timestamp参数</span></span><br><span class="line">        my_nonce = request.args.get(<span class="string">'nonce'</span>)        <span class="comment"># 获取携带的nonce参数</span></span><br><span class="line">        my_echostr = request.args.get(<span class="string">'echostr'</span>)         <span class="comment"># 获取携带的echostr参数</span></span><br><span class="line"></span><br><span class="line">        token = <span class="string">'Your token'</span>     <span class="comment"># 一定要跟刚刚填写的token一致</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行字典排序</span></span><br><span class="line">        data = [token,my_timestamp ,my_nonce ]</span><br><span class="line">        data.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拼接成字符串</span></span><br><span class="line">        temp = <span class="string">''</span>.join(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行sha1加密</span></span><br><span class="line">        mysignature = hashlib.sha1(temp).hexdigest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">        <span class="keyword">if</span> my_signature == mysignature:</span><br><span class="line">            <span class="keyword">return</span> my_echostr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 解析xml</span></span><br><span class="line">        xml = ET.fromstring(request.data)</span><br><span class="line">        toUser = xml.find(<span class="string">'ToUserName'</span>).text</span><br><span class="line">        fromUser = xml.find(<span class="string">'FromUserName'</span>).text</span><br><span class="line">        msgType = xml.find(<span class="string">"MsgType"</span>).text</span><br><span class="line">        createTime = xml.find(<span class="string">"CreateTime"</span>)</span><br><span class="line">        <span class="comment"># 判断类型并回复</span></span><br><span class="line">        <span class="keyword">if</span> msgType == <span class="string">"text"</span>:</span><br><span class="line">            content = xml.find(<span class="string">'Content'</span>).text</span><br><span class="line">            <span class="keyword">return</span> reply_text(fromUser, toUser, reply(fromUser, content))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> reply_text(fromUser, toUser, <span class="string">"我只懂文字"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reply_text</span><span class="params">(to_user, from_user, content)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    以文本类型的方式回复请求</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"""</span></span><br><span class="line"><span class="string">    &amp;lt;xml&amp;gt;</span></span><br><span class="line"><span class="string">        &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[&#123;&#125;]]&amp;gt;&amp;lt;/ToUserName&amp;gt;</span></span><br><span class="line"><span class="string">        &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[&#123;&#125;]]&amp;gt;&amp;lt;/FromUserName&amp;gt;</span></span><br><span class="line"><span class="string">        &amp;lt;CreateTime&amp;gt;&#123;&#125;&amp;lt;/CreateTime&amp;gt;</span></span><br><span class="line"><span class="string">        &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA]&amp;gt;&amp;lt;/MsgType&amp;gt;</span></span><br><span class="line"><span class="string">        &amp;lt;Content&amp;gt;&amp;lt;![CDATA[&#123;&#125;]]&amp;gt;&amp;lt;/Content&amp;gt;</span></span><br><span class="line"><span class="string">    &amp;lt;/xml&amp;gt;</span></span><br><span class="line"><span class="string">    """</span>.format(to_user, from_user, int(time.time() * <span class="number">1000</span>), content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reply</span><span class="params">(openid, msg)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    使用图灵机器人</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    data = &#123;<span class="string">"key"</span>: <span class="string">"Your tuling apikey"</span>, <span class="string">"info"</span>: msg, <span class="string">"userid"</span>: openid&#125;<span class="comment">#  使用自己的key</span></span><br><span class="line">    r = requests.post(<span class="string">'http://openapi.tuling123.com/openapi/api'</span>, data)</span><br><span class="line">    text = json.loads(r.text)</span><br><span class="line">    <span class="keyword">return</span> text[<span class="string">'text'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4qe78ejkj313618sgpg.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4qefhrz0j317a17wwi9.jpg" alt=""></p>
<p>保存后，运行<code>python run.py</code></p>
<p>这时候，你就可以在你的手机微信公众号窗口调戏图灵机器人了：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft4qelnhofj30hs0vkq3i.jpg" alt=""></p>
<p>到这里，你以为结束了吗？还早着呢。</p>
<h3 id="三、部署flask服务"><a href="#三、部署flask服务" class="headerlink" title="三、部署flask服务"></a>三、部署flask服务</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4qsb6w3mj31kw08sgmw.jpg" alt=""></p>
<p>正如你所看到了，当你运行<code>python run.py</code>，服务就运行起来了，但是当你按下<code>ctrl+c</code>或者断开与云服务器的连接，服务就自动掉线了，这时候，你再呼唤图灵机器人，它就无应答了。因此，直接运行<code>python run.py</code>这种方法只适合本地开发调试，线上用这种方法不稳定，我们需要使用<code>uwsgi</code>。</p>
<p>安装<code>uwsgi</code>，<code>supervisor</code>和<code>uwsgi</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install nginx</span><br><span class="line">apt-get install supervisor</span><br><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure>

<p>安装完成后，我们来测试一下<code>uwsgi</code>。我们先将<code>run.py</code>中的<code>port</code>去掉，保留<code>host</code>:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft4rb3a9doj30fw05o3yf.jpg" alt=""></p>
<p>保存。</p>
<p>python2运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --socket 0.0.0.0:5000 --protocol&#x3D;http -w run:app</span><br></pre></td></tr></table></figure>

<p>python3运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --socket 0.0.0.0:5000 -w run:app</span><br></pre></td></tr></table></figure>

<p>然后再在浏览器上输入<code>http://x.x.x.x:5000</code>，看到正确输出<code>Hello World!</code>，就表示uwsgi安装正确，我们就可以使用uwsgi来启动flask服务了。同时，我们可以看到服务器上输出如下信息：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4r60j0vtj31kw0t1dlb.jpg" alt=""></p>
<p>但是这种方法还是每次需要从命令行启动，太麻烦了。下面我们来做一些配置。在<code>/var/www/weixin/</code>目录下创建配置文件<code>weixin_uwsgi.ini</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">module = run:app</span><br><span class="line">master = true</span><br><span class="line">processes = 4</span><br><span class="line">chdir = /var/www/weixin</span><br><span class="line">socket = /var/www/weixin/weixin_uwsgi.sock</span><br><span class="line">logto = /var/www/weixin/%n.log</span><br><span class="line">chmod-socket = 777</span><br><span class="line">vacuum = true</span><br><span class="line">http = 0.0.0.0:5000</span><br></pre></td></tr></table></figure>

<p>配置完成后运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --ini weixin_uwsgi.ini</span><br></pre></td></tr></table></figure>

<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft4rnilve9j30z404wjrj.jpg" alt=""></p>
<p>就会在项目目录下生成<code>weixin_uwsgi.sock</code>文件，这个文件一般大小为0，它是用来和<code>Nginx</code>通信的。</p>
<p>这时候，我们不能<code>ctrl+c</code>杀掉这个进程，重新开一个连接窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入项目目录</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;weixin</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source venv&#x2F;bin&#x2F;activate</span><br><span class="line"># 查看当前目录下的文件</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4rnoucbdj30vm0fojsv.jpg" alt=""></p>
<p>接下来，我们开始配置<code>Nginx</code>。</p>
<p>删除nginx的默认配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default</span><br></pre></td></tr></table></figure>

<p>然后在我们的项目目录下创建nginx配置文件<code>vim /var/www/weixin/weixin_nginx.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name x.x.x.x; #公网地址</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        include      uwsgi_params;</span><br><span class="line">        uwsgi_pass unix:&#x2F;var&#x2F;www&#x2F;weixin&#x2F;weixin_uwsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4rwl6815j30sy0ag3ys.jpg" alt=""></p>
<p>保存退出。将<code>weixin_nginx.conf</code>软链接到nginx的<code>conf.d</code>目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;var&#x2F;www&#x2F;weixin&#x2F;weixin_nginx.conf  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br></pre></td></tr></table></figure>

<p>重启nginx服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx restart</span><br></pre></td></tr></table></figure>

<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4ryhbuivj30yk05adg9.jpg" alt=""></p>
<p>看到ok就表示nginx正常启动。这时不出意外，你在浏览器中输入<code>http://x.x.x.x</code>，就可以看到<code>Hello World!</code>。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft4s6z8lr4j30j30763yt.jpg" alt=""></p>
<p>这样我们就不用再加5000的端口号，直接用ip地址和默认的80端口就可以访问了。</p>
<h5 id="使用supervisor引导uwsgi"><a href="#使用supervisor引导uwsgi" class="headerlink" title="使用supervisor引导uwsgi"></a>使用supervisor引导uwsgi</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft4rnilve9j30z404wjrj.jpg" alt=""></p>
<p>这时候我们再回到前一个运行<code>uwsgi</code>的窗口，<code>uwsgi</code>保持运行的状态，我们不能断开它，也不能做其他任何事情，一旦服务器断开连接，，<code>uwsgi</code>服务就会关闭，<code>weixin_uwsgi.sock</code>文件就会消失，这时再访问网站，nginx就会报错：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft4sdilk8bj30h70460sk.jpg" alt=""></p>
<p>所以<code>supervisor</code>就派上用场了。我们在项目目录下创建supervisor配置文件<code>vim /var/www/weixin/weixin_supervisor.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:weixin]</span><br><span class="line"># 启动命令入口</span><br><span class="line">command&#x3D;&#x2F;var&#x2F;www&#x2F;weixin&#x2F;venv&#x2F;bin&#x2F;uwsgi &#x2F;var&#x2F;www&#x2F;weixin&#x2F;weixin_uwsgi.ini</span><br><span class="line"># 命令程序所在目录</span><br><span class="line">directory&#x3D;&#x2F;var&#x2F;www&#x2F;weixin</span><br><span class="line">#运行命令的用户名</span><br><span class="line">user&#x3D;root</span><br><span class="line">autostart&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">#日志地址</span><br><span class="line">stdout_logfile&#x3D;&#x2F;var&#x2F;www&#x2F;weixin&#x2F;weixin_supervisor.log</span><br></pre></td></tr></table></figure>

<p>保存退出后，<code>ln -s /var/www/weixin/weixin_supervisor.conf /etc/supervisor/conf.d/weixin_supervisor.conf</code> 软链接到supervisor的配置文件夹，然后启动supervisor服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;supervisor restart</span><br></pre></td></tr></table></figure>

<p>至此，flask就可以稳定运行了。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>nginx</tag>
        <tag>supervisor</tag>
        <tag>图灵</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器上手教程</title>
    <url>/cloud/</url>
    <content><![CDATA[<p>这里推荐大家使用学生优惠权限购买阿里云或者腾讯云服务器或者海外的digitalocean</p>
<p><a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">腾讯云</a>(10元/月)</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsr4cncqj1j31kw0piwh2.jpg" alt=""></p>
<p><a href="https://promotion.aliyun.com/ntms/campus2017.html" target="_blank" rel="noopener">阿里云</a>（9.9元/月）</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fsr4lrd28fj31kw0rlmzp.jpg" alt=""></p>
<p><a href="https://m.do.co/c/7bafaa844e3d" target="_blank" rel="noopener">digitalocean</a></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fsr4m658odj31kw0wqtdn.jpg" alt=""></p>
<blockquote>
<p>云服务器能干嘛？ </p>
</blockquote>
<p>云服务器，相当于一台24小时不关机，还有公网IP（从任何地方都可以访问，只要有网络）的电脑！</p>
<ul>
<li>搭建个人网站、web项目等</li>
<li>放一些需要24小时工作的脚本，比如爬虫</li>
<li>搭科学上网的梯子（海外的服务器可以）</li>
<li>学习Linux等</li>
</ul>
<h3 id="推荐购买digitalocean"><a href="#推荐购买digitalocean" class="headerlink" title="推荐购买digitalocean"></a>推荐购买digitalocean</h3><p>理由一：digitalocean是海外的服务器，可以用来搭梯子供科学上网</p>
<p>理由二：用Github的学生包可以免费领取digitalocean服务器50$的优惠券，这够你免费用一年以上了</p>
<h3 id="如何申请购买digitalocean云服务器"><a href="#如何申请购买digitalocean云服务器" class="headerlink" title="如何申请购买digitalocean云服务器"></a>如何申请购买digitalocean云服务器</h3><h6 id="1-使用-GitHub-学生包注册获取优惠"><a href="#1-使用-GitHub-学生包注册获取优惠" class="headerlink" title="1. 使用 GitHub 学生包注册获取优惠"></a>1. 使用 GitHub 学生包注册获取优惠</h6><p>到<a href="https://education.github.com/pack/join" target="_blank" rel="noopener">https://education.github.com/pack/join</a> 这个页面进行身份验证，通过之后，找到 digitalocean 的优惠选项，获取50刀的优惠代码。</p>
<h6 id="2-注册-DigitalOcean"><a href="#2-注册-DigitalOcean" class="headerlink" title="2. 注册 DigitalOcean"></a>2. 注册 DigitalOcean</h6><p>使用这个推荐<a href="https://m.do.co/c/7bafaa844e3d" target="_blank" rel="noopener">链接</a>注册，你将可以获得10刀的优惠券。注册过程很简单，唯一麻烦的地方就是需要注册一个 PayPal 的账号并且绑定。绑定之后，==digitalocean 会从PayPal中扣除 $5 的初始金额==，用于确认支付能力。</p>
<p>所以全程你只需要花费5刀，即可获得50+10+5=65刀，按照一个月5刀的服务器计算，你将可以使用13个月。</p>
<blockquote>
<p>当然，你也可以购买腾讯云或者阿里云，它们是一个月10元左右，配置比DigitalOcean高，但是它们是放在国内的，所以你不能利用它们来搭梯子科学上网。 </p>
</blockquote>
<h3 id="买完服务器，怎么登陆"><a href="#买完服务器，怎么登陆" class="headerlink" title="买完服务器，怎么登陆"></a>买完服务器，怎么登陆</h3><p>成功购买之后，你将获得服务器的ip、用户名和密码</p>
<p>如果你是mac，直接在终端输入 ssh 用户名@ip，回车后输入正确的密码即可登陆;</p>
<p>如果你是windows，需要下载SecureCRT程序，通过它来连接服务器</p>
<blockquote>
<p>如果你找不到服务器的ip、用户名和密码或者不知道如何登陆，可以找同学或者学长协助 </p>
</blockquote>
<p>至此，你就拥有一台属于自己的云服务器，可以在上面为所欲为了～～～</p>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>digitalocean</tag>
        <tag>学生优惠</tag>
        <tag>腾讯云</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS + Sublime Text + Latex 环境配置</title>
    <url>/macos-sublime-text-latex/</url>
    <content><![CDATA[<blockquote>
<p>Latex（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/），是一种基于TEX的排版系统，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、化学类文档。——维基百科 </p>
</blockquote>
<p>所以很多高校的老师都要求学生用Latex来写论文。那么问题来了，latex要在哪里写？有像word一样的编辑器吗？答案是肯定的。市面上的latex编辑器不下20种，各种系统都有，常见的有：LyX、TeXworks、TexStudio、WinEdt、Emacs、Sublime Text、Atom、Visual Studio Code等。</p>
<p><a href="https://www.zhihu.com/question/19954023" target="_blank" rel="noopener">有哪些好的latex编辑器？——知乎</a></p>
<p>本文将介绍如何在mac系统下，用sublime配置latex环境。</p>
<h3 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h3><p><a href="http://www.tug.org/mactex/" target="_blank" rel="noopener">MacTex</a> Latex运行的必备环境</p>
<p><a href="http://xclient.info/s/sublime-text.html?_=4847db8d4fcfc9682f3ac7932c81436e" target="_blank" rel="noopener">Sublime Text</a> 编辑器，写代码的应该都很熟悉（这个地址是破*解&amp;版的福利哦）</p>
<p><a href="https://sourceforge.net/projects/skim-app/files/Skim/Skim-1.4.26/Skim-1.4.26.dmg/download" target="_blank" rel="noopener">Skim</a> PDF阅读器，有它你才能预览你的文档</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li><p>首先下载MacTex安装，傻瓜式安装。MacTex文件比较大，有2G+，介意的话可以选择MacTex_Basic包，只有是100M以内，但是如果安装MacTex_Basic，后期可能会遇到各种缺包的问题。</p>
</li>
<li><p>第二步安装Sublime Text 3。安装好后，安装插件LaTexTool。具体步骤如下：<br>2.1 安装 Package Control</p>
<p>打开 Sublime Text 3 选择 View 中的 Show Console 。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnqpqyw5ybj30nq0bawf0.jpg" alt=""></p>
<p>这时sublime text下面会显示一个输入窗口，复制下面这段代码到窗口里面并且回车执行，然后重启 Sublime Text 3 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h &#x3D; &#39;df21e130d211cfc94d9b0905775a7c0f&#39; + &#39;1e3d39e33b79698005270310898eea76&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by &#x3D; urllib.request.urlopen( &#39;http:&#x2F;&#x2F;packagecontrol.io&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !&#x3D; h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</span><br></pre></td></tr></table></figure>

<p>2.2 安装 LaTeXTools插件</p>
<p>按下 <code>shift + ⌘ + P</code>，输入 <code>Install Package</code> ，回车。<img src="https://ws3.sinaimg.cn/large/006tNc79ly1fnqpuo2bw8j30wm0o274y.jpg" alt=""></p>
<p>输入<code>LaTeXTools</code> ，回车安装 LaTeXTools 插件。</p>
</li>
<li><p>安装Skim</p>
<p>安装好后运行Skim，进入<code>Skim——选项</code>，点击<code>同步</code>进行设置</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnqpxvworqj30ns0i8t96.jpg" alt=""></p>
<p>勾选<code>检查文件变化</code>，在<code>PDF-Tex同步支持</code>那里选择<code>sublime Text</code>，这样当你编译tex后就会自动打开pdf预览了。</p>
</li>
</ol>
<p>完成上面所有步骤，latex基本环境就搭建好了。下面可以测试一下。</p>
<p>创建一个test.tex文档，复制以下内容粘贴到文档中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;fontspec, xunicode, xltxtra&#125;</span><br><span class="line">\setmainfont&#123;Hiragino Sans GB&#125;</span><br><span class="line">\title&#123;Title&#125;</span><br><span class="line">\author&#123;&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle&#123;&#125;</span><br><span class="line">\section&#123;Introduction&#125;</span><br><span class="line">This is where you will write your content. 在这里写上内容。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>保存以后，按下 <code>⌘ + B</code>进行编译 ，如果以上操作无误，下面会提示<code>Build completed</code>，然后 Skim 弹出 PDF 预览。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fnqq51e43gj30v40pm3z9.jpg" alt=""></p>
<h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><p>完成上面的步骤，基本上可以正常编写文档了，但是如果你写的是中文文档，那事情可就还没结束，还完成以下的配置才能开心地编写中文文档。打开终端，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tlmgr update --self</span><br><span class="line">sudo tlmgr install latexmk</span><br></pre></td></tr></table></figure>

<p>在sublime Text里打开LaTeXTools.sublime-settings（也就是LaTeXTools的用户设置，如果你是从旧版本升级上来或者担心这个配置文件出现问题，可以依次点击Preferences——Package Settings——LaTeXTools——Reconfigure LaTeXTools and migrate settings重建配置文件），在builder-settings下面新增两项配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;program&quot; : &quot;xelatex&quot;,</span><br><span class="line">&quot;command&quot; : [&quot;latexmk&quot;, &quot;-cd&quot;, &quot;-e&quot;, &quot;$pdflatex &#x3D; &#39;xelatex -interaction&#x3D;nonstopmode -synctex&#x3D;1 %S %O&#39;&quot;, &quot;-f&quot;, &quot;-pdf&quot;],</span><br></pre></td></tr></table></figure>

<p>另外注意之前应该有&#8221;builder&#8221;: &#8220;default&#8221;（或直接设置为空或”traditional”）。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnqqeen2fgj31c6106ad1.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnqqflatnnj31kw0tyn01.jpg" alt=""></p>
<p>保存配置文件后关闭，重新编译一下，即可正常显示中文。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>如果你忘记公式的代码，可以用这个LaTex公式编辑器：<a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">http://www.codecogs.com/latex/eqneditor.php</a></p>
<p>如果你测试的时候遇到如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;&#x2F;Users&#x2F;huwei&#x2F;Desktop&#x2F;test.tex&quot;, line 1</span><br><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>那可能是你sublime Text的默认编译环境被设置为python了，可以点击<code>Tools-&gt;Build System</code>，将其设置为<code>Automatic</code>，这样编辑器就会根据文件的后缀来自动识别文件类型了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.readern.com/sublime-text-latex-chinese-under-mac.html/comment-page-1" target="_blank" rel="noopener">http://www.readern.com/sublime-text-latex-chinese-under-mac.html/comment-page-1</a></p>
]]></content>
      <categories>
        <category>玩转Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>latex</tag>
        <tag>sublime text</tag>
      </tags>
  </entry>
  <entry>
    <title>centos neo4j 安装+远程访问配置</title>
    <url>/centos-neo4j/</url>
    <content><![CDATA[<p>centos版本：CentOS release 6.9 (Final)</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>直接用yum install neo4j不可行，可能是版本库中不存在neo4j，得手动加入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import http:&#x2F;&#x2F;debian.neo4j.org&#x2F;neotechnology.gpg.key</span><br><span class="line">cat &lt;&lt;EOF&gt;  &#x2F;etc&#x2F;yum.repos.d&#x2F;neo4j.repo</span><br><span class="line">[neo4j]</span><br><span class="line">name&#x3D;Neo4j RPM Repository</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;yum.neo4j.org&#x2F;stable</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后用<code>yum install neo4j</code>即可安装。</p>
<p>安装完毕，使用<code>neo4j start</code>启动neo4j。（如果启动不起来，可能是没有安装java环境，还需要先安装java）</p>
<p>neo4j正常启动后，可以到浏览器中输入<code>localhost:7474</code>进入可视化界面。</p>
<h3 id="2-修改密码"><a href="#2-修改密码" class="headerlink" title="2. 修改密码"></a>2. 修改密码</h3><p>进入界面会让你输入密码。初始用户名/密码为：neo4j/neo4j</p>
<p>登陆成功会让你修改密码。</p>
<p>如果你不慎忘记密码，可以通过删除<code>/var/lib/neo4j/data/dbms/auth</code>这个文件来重置密码。文件删除后，重启neo4j，进入可视化界面，变回初始用户名/密码：neo4j/neo4j</p>
<p>至此，neo4j的安装大功告成。</p>
<h3 id="3-远程访问配置"><a href="#3-远程访问配置" class="headerlink" title="3. 远程访问配置"></a>3. 远程访问配置</h3><p>如果你还想开启远程访问，就是让外网通过你的ip:7474来访问你的数据库，可以通过简单的配置实现。</p>
<p>neo4j配置文件</p>
<p><code>vi /etc/neo4j/neo4j.conf</code></p>
<p>将<code>dbms.connectors.default_listen_address=0.0.0.0</code>前面的注释去掉即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># With default configuration Neo4j only accepts local connections.</span><br><span class="line"># To accept non-local connections, uncomment this line:</span><br><span class="line">dbms.connectors.default_listen_address&#x3D;0.0.0.0</span><br></pre></td></tr></table></figure>

<p><code>:wq</code>保存退出后</p>
<p><code>neo4j restart</code> 重启neo4j</p>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode] Minimum Depth of Binary Tree</title>
    <url>/minimum-depth-of-binary-tree/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：111. Minimum Depth of Binary Tree</p>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>翻译</strong>：给定一棵二叉树，求它的最小深度。 最小深度是沿着从根节点到最近的叶节点的最短路径的节点的数量。</p>
<p><strong>思路</strong>：本题与<a href="https://weiweiblog.cn/blog/mdbt">Maximum Depth of Binary Tree</a>类似，依旧用递归的方法来求解。不过，有个地方要注意一下，左子树或者右子树为空时，我们不能直接让其深度等于0，而要转去求非空的右子树或者左子树的深度。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+minDepth(root.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode] Maximum Depth of Binary Tree</title>
    <url>/maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/submissions/detail/136407355/" target="_blank" rel="noopener">https://leetcode.com/submissions/detail/136407355/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：104. Maximum Depth of Binary Tree</p>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>翻译</strong>：给定一棵二叉树，找到它的最大深度。最大深度是沿着从根节点到最远叶节点的最长路径的节点的数量。</p>
<p><strong>思路</strong>：用深度优先搜索DFS递归遍历二叉树，搜索判断左右子树的深度孰大孰小即可，从根节点往下一层树的深度即自增1，遇到NULL时即返回0。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>+Math.max(maxDepth(root.left), maxDepth(root.right)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode] Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/construct-binary-tree-from-inorder-and-postorder-traversal/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/</a></p>
<p><strong>难度</strong>：Medium</p>
<p><strong>题目</strong>：106. Construct Binary Tree from Inorder and Postorder Traversal</p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:</p>
<p>You may assume that duplicates do not exist in the tree.</p>
<p><strong>翻译</strong>：给定树的中序遍历和后序遍历，构造二叉树。 注意：树中不存在重复项。</p>
<p><strong>思路</strong>：本题与<code>105. Construct Binary Tree from Preorder and Inorder Traversal</code>类似。你要先知道</p>
<blockquote>
<p>中序遍历：左子树，根节点，右子树</p>
</blockquote>
<blockquote>
<p>后序遍历：左子树，右子树，根节点 </p>
</blockquote>
<p>以如下这棵树为例：</p>
<pre><code>            1
    --------|-------
    2               3
----|----       ----|----
4       5       6       7</code></pre><blockquote>
<p>前序遍历 1245367</p>
</blockquote>
<blockquote>
<p>中序遍历 4251637</p>
</blockquote>
<blockquote>
<p>后续遍历 4526731 </p>
</blockquote>
<p>我们可以发现，对于后序遍历来说，<strong>最后一个元素</strong>一定是根节点，也就是1。然后我们在中序遍历的结果里面找到1所在的位置，那么它的左半部分就是其左子树，右半部分就是其右子树。</p>
<p>我们将中序遍历左半部分425取出，同时发现后序遍历的结果也在相应的位置上面，只是顺序稍微不一样，也就是452。我们可以发现，后序遍历中的2就是该子树的根节点。</p>
<p>上面说到了左子树，对于右子树，我们取出637，同时发现后序遍历中对应的数据偏移了一格，并且顺序也不一样，为673。而3就是这颗右子树的根节点。</p>
<p>重复上述过程，通过后续遍历找到根节点，然后在中序遍历数据中根据根节点拆分成两个部分，同时将对应的后序遍历的数据也拆分成两个部分，重复递归，就可以得到整个二叉树了。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; inorderMap &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(int i&#x3D;0; i&lt;inorder.length; i++)</span><br><span class="line">            inorderMap.put(inorder[i],i);</span><br><span class="line">        return buildTree(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1, inorderMap);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] inorder, int iLeft, int iRight, int[] postorder, int pLeft, int pRight, Map&lt;Integer, Integer&gt; inorderMap)&#123;</span><br><span class="line">        if(iLeft&gt;iRight || pLeft&gt;pRight)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode cur &#x3D; new TreeNode(postorder[pRight]);</span><br><span class="line">        &#x2F;&#x2F;int i &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;for(i&#x3D;iLeft; i&lt;&#x3D;iRight; i++)</span><br><span class="line">        &#x2F;&#x2F;   if(postorder[pRight]&#x3D;&#x3D;inorder[i])</span><br><span class="line">        &#x2F;&#x2F;        break;</span><br><span class="line">        int i &#x3D; inorderMap.get(postorder[pRight]);</span><br><span class="line">        cur.left &#x3D; buildTree(inorder, iLeft, i-1, postorder, pLeft, pLeft+i-iLeft-1, inorderMap);</span><br><span class="line">        cur.right &#x3D; buildTree(inorder, i+1, iRight, postorder, pLeft+i-iLeft, pRight-1, inorderMap);</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode] Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/construct-binary-tree-from-preorder-and-inorder-traversal/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/</a></p>
<p><strong>难度</strong>：Medium</p>
<p><strong>题目</strong>：105. Construct Binary Tree from Preorder and Inorder Traversal</p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:</p>
<p>You may assume that duplicates do not exist in the tree.</p>
<p><strong>翻译</strong>：给定树的前序和中序遍历，构造二叉树。 注意： 树中不存在重复项。</p>
<p><strong>思路</strong>：首先，你应该知道</p>
<blockquote>
<p>前序遍历：根节点，左子树，右子树；</p>
</blockquote>
<blockquote>
<p>中序遍历：左子树，根节点，右子树； </p>
</blockquote>
<p>所以，我们可以从<code>preorder</code>中找到整棵树的根节点，即为<code>preorder[0]</code>，由于<code>preorder</code>和<code>inorder</code>是对同一棵树的遍历，我们可以知道<code>preorder[0]</code>在<code>inorder</code>中一定也存在，不妨设<code>preorder[0]==inorder[k]</code>。</p>
<p>由于<code>inorder</code>是中序遍历，所以<code>k</code>左边的就是根节点左子树的中序遍历、<code>k</code>右边的就是根节点右子树的中序遍历。</p>
<p>并且，我们已经知道了根节点左子树的节点数（与中序遍历长度相同），不妨设为<code>l</code>，我们可以知道preorder从<code>1</code>到<code>l+1</code>就是根节点左子树的前序遍历，剩下的最后一部分就是根节点右子树的前序遍历。</p>
<p>由此，我们可以计算出左子树、右子树的前序遍历和中序遍历，从而可以用分治的思想，将规模较大的问题分解成为两个较小的问题，然后递归的进行处理，还原左子树和右子树，最后连通根节点一起组成一棵完整的树。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        Map&amp;lt;Integer, Integer&amp;gt; inorderMap = <span class="keyword">new</span> HashMap&amp;lt;Integer, Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;inorder.length; i++)</span><br><span class="line">            inorderMap.put(inorder[i],i);</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>, inorderMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pLeft, <span class="keyword">int</span> pRight, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> iLeft, <span class="keyword">int</span> iRight, Map&amp;lt;Integer,Integer&amp;gt; inorderMap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pLeft&amp;gt;pRight || iLeft&amp;gt;iRight)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(preorder[pLeft]);</span><br><span class="line">        <span class="comment">//int i=0;</span></span><br><span class="line">        <span class="comment">//for(i=iLeft; i&amp;lt;= iRight; i++)</span></span><br><span class="line">        <span class="comment">//    if(preorder[pLeft] == inorder[i])</span></span><br><span class="line">        <span class="comment">//        break;</span></span><br><span class="line">        <span class="keyword">int</span> i = inorderMap.get(preorder[pLeft]);</span><br><span class="line"></span><br><span class="line">        cur.left = buildTree(preorder, pLeft+<span class="number">1</span>, pLeft+i-iLeft, inorder, iLeft, i-<span class="number">1</span>, inorderMap);</span><br><span class="line">        cur.right = buildTree(preorder, pLeft+i-iLeft+<span class="number">1</span>, pRight, inorder, i+<span class="number">1</span>, iRight, inorderMap);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序【Shellsort】</title>
    <url>/shellsort/</url>
    <content><![CDATA[<blockquote>
<p><strong>希尔排序</strong>，也称递减增量排序算法，是插入排序的一种更高效的改进版本。——维基百科 </p>
</blockquote>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p>&#8211; 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</p>
<p>&#8211; 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<h4 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h4><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p><strong>推荐步长： 3*n+1</strong></p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>1．增量序列的选择</p>
<p>Shell排序的执行时间依赖于增量序列。好的增量序列的共同特征：</p>
<p>&#8211; 最后一个增量必须为1；</p>
<p>&#8211; 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。</p>
<p>2．Shell排序的时间性能优于直接插入排序</p>
<p>&#8211; 当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</p>
<p>&#8211; 当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。</p>
<p>&#8211; 在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。</p>
<p>3．稳定性</p>
<p>希尔排序是不稳定的。</p>
<blockquote>
<p><strong>排序算法的稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &amp;lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &amp;gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&amp;lt;N; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&amp;gt;=h &amp;&amp; less(a[j],a[j-h]); j-=h)</span><br><span class="line">                    exch(a,j,j-h);</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&amp;lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Comparable swap = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>centos搭建ftp服务器</title>
    <url>/centos_ftp/</url>
    <content><![CDATA[<p>vsftpd 是一款在Linux发行版中最受推崇的FTP服务器程序，它是一个基于GPL协议的开源程序。vsftpd代表very secure FTP daemon，它安全，稳定，性能优异，小巧轻快，安全易用，是一个非常成熟和可信的解决方案。</p>
<h3 id="1-安装vsftpd"><a href="#1-安装vsftpd" class="headerlink" title="1. 安装vsftpd"></a>1. 安装vsftpd</h3><p><code>yum install vsftpd</code></p>
<h3 id="2-设置开机启动vsftpd-ftp服务"><a href="#2-设置开机启动vsftpd-ftp服务" class="headerlink" title="2. 设置开机启动vsftpd ftp服务"></a>2. 设置开机启动vsftpd ftp服务</h3><p><code>chkconfig vsftpd on</code></p>
<h3 id="3-启动vsftpd服务-默认ftp服务是没有启动的，用下面命令启动"><a href="#3-启动vsftpd服务-默认ftp服务是没有启动的，用下面命令启动" class="headerlink" title="3. 启动vsftpd服务(默认ftp服务是没有启动的，用下面命令启动)"></a>3. 启动vsftpd服务(默认ftp服务是没有启动的，用下面命令启动)</h3><p><code>service vsftpd start</code></p>
<blockquote>
<h4 id="管理vsftpd相关命令："><a href="#管理vsftpd相关命令：" class="headerlink" title="管理vsftpd相关命令："></a>管理vsftpd相关命令：</h4><p>停止vsftpd: service vsftpd stop</p>
</blockquote>
<blockquote>
<p>重启vsftpd: service vsftpd restart </p>
</blockquote>
<p>安装完后，有/etc/vsftpd/vsftpd.conf 文件，用来配置，还有新建了一个ftp用户和ftp的组，指向home目录为/var/ftp,默认是nologin（不能登录系统）</p>
<p>可以用下面命令查看用户</p>
<p>cat /etc/passwd</p>
<h3 id="4-配置vsftpd服务器"><a href="#4-配置vsftpd服务器" class="headerlink" title="4. 配置vsftpd服务器"></a>4. 配置vsftpd服务器</h3><p>默认的配置文件是/etc/vsftpd/vsftpd.conf，你可以用文本编辑器打开。</p>
<p><code>vi /etc/vsftpd/vsftpd.conf</code></p>
<p>把第一行的 anonymous_enable=YES ，改为NO，取消匿名登陆</p>
<p>将底下三行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#chroot_list_enable&#x3D;YES</span><br><span class="line"># (default follows)</span><br><span class="line">#chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd.chroot_list</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chroot_list_enable&#x3D;YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;chroot_list</span><br></pre></td></tr></table></figure>

<p>重启</p>
<p><code>service vsftpd restart</code></p>
<h3 id="5-增加用户newuser，指向目录-home-wwwroot-newuser"><a href="#5-增加用户newuser，指向目录-home-wwwroot-newuser" class="headerlink" title="5. 增加用户newuser，指向目录/home/wwwroot/newuser"></a>5. 增加用户newuser，指向目录/home/wwwroot/newuser</h3><p><code>useradd -d /home/wwwroot/newuser -g ftp -s /sbin/nologin newuser</code></p>
<p>其中，-d后加目标目录， 最后newuser是用户名</p>
<blockquote>
<p>别忘了设置用户密码 </p>
</blockquote>
<p><code>passwd newuser</code></p>
<blockquote>
<p>还要把用户名加到文件chroot_list中: </p>
</blockquote>
<p><code>vi /etc/vsftpd/chroot_list</code></p>
<p>内容为ftp用户名,每个用户占一行,如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">newuser</span><br><span class="line">peter</span><br><span class="line">john</span><br></pre></td></tr></table></figure>

<p>至此，ftp基本设置完毕，你可以在另外的机子上用ftp客户端连接一下，如果连接不上，那有可能是服务器的防火墙权限没开，设置一下防火墙即可。</p>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Longest Continuous Increasing Subsequence 最长连续增长序列</title>
    <url>/longest-continuous-increasing-subsequence/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：674. Longest Continuous Increasing Subsequence</p>
<p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </span><br><span class="line">Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4. </span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,2,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [2], its length is 1. </span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>Length of the array will not exceed 10,000.</li>
</ul>
<p><strong>翻译</strong>：给定一个无序整型数组，找出最长的连续增长的子序列。</p>
<p><strong>思路</strong>：设置一个标志符flag，遍历整个数组，如果后一个值比前一个值大，则res取res和flag中的最大值，否则flag置1。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &amp;lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;nums.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || nums[i]&amp;gt;nums[i-<span class="number">1</span>])</span><br><span class="line">                res = Math.max(res, ++flag);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Max Area of Island 岛屿的最大面积</title>
    <url>/max-area-of-island/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">https://leetcode.com/problems/max-area-of-island/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：695. Max Area of Island</p>
<p>Given a non-empty 2D array grid of 0&#8217;s and 1&#8217;s, an island is a group of 1&#8217;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">Given the above grid, return 0.</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>The length of each dimension in the given grid does not exceed 50.</li>
</ul>
<p><strong>翻译</strong>：给定非空2维矩阵，元素为0或1，1代表陆地，四个方向中若有陆地相连，则代表岛屿，求最大岛屿的面积。</p>
<p><strong>思路</strong>：用递归的方法深度优先搜索计算岛屿面积。遍历整个矩阵求最大面积。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<p>&#8220;`java</p>
<p>class Solution {</p>
<p>public int maxAreaOfIsland(int[][] grid) {</p>
<p>int maxArea = 0;</p>
<p>for(int i=0; i&lt; grid.length; i++){</p>
<p>for(int j=0; j&lt;grid[0].length; j++){</p>
<p>if(grid[i][j] != 0){</p>
<p>maxArea = Math.max(maxArea, areaOfIsland(grid, i, j));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return maxArea;</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">areaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; i&lt;grid.length &amp;&amp; j&lt;grid\[<span class="number">0</span>].length &amp;&amp; grid[i\]\[j\] == <span class="number">1</span>)&#123;</span><br><span class="line">          </span><br><span class="line">grid\[i\]\[j\] = <span class="number">0</span>;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+areaOfIsland(grid, i+<span class="number">1</span>, j) + areaOfIsland(grid, i-<span class="number">1</span>, j)+areaOfIsland(grid, i, j+<span class="number">1</span>)+areaOfIsland(grid, i, j-<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>}&#8220;`</p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Degree of an Array 数组的度</title>
    <url>/degree-of-an-array/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/degree-of-an-array/description/" target="_blank" rel="noopener">https://leetcode.com/problems/degree-of-an-array/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：697. Degree of an Array</p>
<p>Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1, 2, 2, 3, 1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The input array has a degree of 2 because both elements 1 and 2 appear twice.</span><br><span class="line">Of the subarrays that have the same degree:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">The shortest length is 2. So return 2.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,2,3,1,4,2]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>nums.length will be between 1 and 50,000.</li>
<li>nums[i] will be an integer between 0 and 49,999.</li>
</ul>
<p><strong>翻译</strong>：给定一个非空非负的整型数组，定义数组的度为数组中元素出现的最大次数。任务是找出度和数组的度相同的最小子串</p>
<p><strong>思路</strong>：记录下第一次出现和最后一次出现的位置就好了，两者相减就是最短长度。对于有多个出现次数最多元素的情况，只需要找出这些元素的最短子串中最小的就好了。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&amp;lt;Integer, Integer&amp;gt; left = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map&amp;lt;Integer, Integer&amp;gt; right = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map&amp;lt;Integer, Integer&amp;gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &amp;lt; nums.length; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!left.containsKey(nums[i]))</span><br><span class="line">                left.put(nums[i], i);</span><br><span class="line">            right.put(nums[i], i);</span><br><span class="line">            count.put(nums[i], count.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> degree = Collections.max(count.values());</span><br><span class="line">        <span class="keyword">int</span> length = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count.get(nums[i])==degree)&#123;</span><br><span class="line">                length = Math.min(length, right.get(nums[i]) - left.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］1-bit and 2-bit Characters 1位和2位字符</title>
    <url>/1-bit-and-2-bit-characters/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/1-bit-and-2-bit-characters/description/" target="_blank" rel="noopener">https://leetcode.com/problems/1-bit-and-2-bit-characters/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：717. 1-bit and 2-bit We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>1 &lt;= len(bits) &lt;= 1000.</li>
<li>bits[i] is always 0 or 1.</li>
</ul>
<p><strong>翻译</strong>：给定两种字符，一种用1位的0表示，另一种用2位10或者11表示。现在给出一个由很多位字符表示的字符串，判断最后一位是不是1位字符。</p>
<p><strong>思路</strong>：从头到尾遍历，如果该位数字为1，则向后前进两位，否则前进1位，循环的条件是i &lt; n-1，即留出最后一位，所以当循环退出后，当i正好停留在n-1上，说明最后一位是单独分割开的。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bits.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&amp;lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bits[i]==<span class="number">0</span>)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>从A到Z，掌握机器学习基本词汇【A】</title>
    <url>/machine_a_z/</url>
    <content><![CDATA[<p><strong>Accuracy: 准确率</strong></p>
<p>机器学习的常用评价指标。定义如下：</p>
<p>Accuracy = (TruePositives + TrueNegatives) / 总样本数</p>
<blockquote>
<p>经常和准确率一起出现的，还有精确率和召回率。</p>
</blockquote>
<blockquote>
<p>&#8211; 精确率(Precision) ＝ TP / (TP + FP)。它表示：预测为正的样本中有多少是真正的正样本，它是针对我们预测结果而言的。Precision又称为查准率。</p>
</blockquote>
<blockquote>
<p>&#8211; 召回率(Recall) ＝ TP / (TP + FN)。它表示：样本中的正例有多少被预测正确了， 它是针对我们原来的样本而言的。Recall又称为查全率。 </p>
</blockquote>
<p><strong>Activation function: 激活函数</strong></p>
<p>一种函数（例如 ReLU 或 Sigmoid），将前一层所有神经元激活值的加权和输入到一个非线性函数中，然后向下一层传递该函数的输出值（典型的非线性）。</p>
<p>如下图，在神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数 Activation Function。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fm08w18w04j30br07nweg.jpg" alt=""></p>
<p>常见的激活函数有：sigmoid、Tanh、ReLU、softmax等</p>
<p><strong>Adagrad：一种优化算法</strong></p>
<p>Adagrad是一种复杂的优化算法（梯度下降算法），它能够在迭代过程中不断地自我调整学习率，并让模型参数中每个元素都使用不同学习率。</p>
<p><strong>AUC: 曲线下面积</strong></p>
<p>AUC（Area Under Curve）也是一种常见的机器学习评价指标，和ROC（Receiver Operating Characteristic）曲线一起常被用来评价一个二值分类器（binary classifier）的优劣。相比准确率、召回率、F-score这样的评价指标，ROC曲线有这样一个很好的特性：当测试集中正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。</p>
<p>AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。</p>
<blockquote>
<p>如果你觉得还有其他核心基础词汇，欢迎评论补充。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Merge Sorted Array 合并排序数组</title>
    <url>/merge-sorted-array/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/description/</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：88. Merge Sorted Array</p>
<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:</p>
<p>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<p><strong>翻译</strong>：给定两个排序整数数组nums1和nums2，将nums2按顺序合并到nums1（从小到大）。</p>
<p>提示：假设nums1有足够的空间（大小大于或等于m + n）来保存nums2中的其他元素。</p>
<p><strong>思路</strong>：A和B都已经是排好序的数组，我们只需要从后往前比较就可以了。因为A有足够的空间容纳A + B，我们使用游标i指向m + n &#8211; 1，也就是最大数值存放的地方，从后往前遍历A，B，谁大就放到i这里，同时递减i。</p>
<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        for(int i&#x3D;m + n - 1; i&gt;&#x3D;0 ; i--)&#123;</span><br><span class="line">            if(m&gt;0 &amp;&amp; n&gt;0)&#123;</span><br><span class="line">                if(nums1[m-1]&gt;nums2[n-1])&#123;</span><br><span class="line">                    nums1[i] &#x3D; nums1[m-1];</span><br><span class="line">                    m --;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    nums1[i] &#x3D; nums2[n-1];</span><br><span class="line">                    n --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(m&lt;&#x3D;0)&#123;</span><br><span class="line">                nums1[i] &#x3D; nums2[n-1];</span><br><span class="line">                n --;</span><br><span class="line">            &#125;else if(n&lt;&#x3D;0)&#123;</span><br><span class="line">                nums1[i] &#x3D; nums1[m-1];</span><br><span class="line">                m --;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>小白的机器学习实战——向量，矩阵和数组</title>
    <url>/vector_matrix/</url>
    <content><![CDATA[<h3 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 创建矩阵</span><br><span class="line">matrix &#x3D; np.array([[1, 2, 3],</span><br><span class="line">                   [4, 5, 6],</span><br><span class="line">                   [7, 8, 9],</span><br><span class="line">                   [10, 11, 12]])</span><br></pre></td></tr></table></figure>

<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 行向量</span><br><span class="line">vector_row &#x3D; np.array([1, 2, 3])</span><br><span class="line"># 列向量</span><br><span class="line">vector_column &#x3D; np.array([[1],</span><br><span class="line">                          [2],</span><br><span class="line">                          [3]])</span><br></pre></td></tr></table></figure>

<h3 id="计算平均值，方差和标准偏差"><a href="#计算平均值，方差和标准偏差" class="headerlink" title="计算平均值，方差和标准偏差"></a>计算平均值，方差和标准偏差</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算均值</span><br><span class="line">np.mean(matrix)</span><br><span class="line">&gt;&gt;&gt; 6.5</span><br><span class="line"># 计算方差</span><br><span class="line">np.var(matrix)</span><br><span class="line">&gt;&gt;&gt; 11.916666666666666</span><br><span class="line"># 计算标准差</span><br><span class="line">np.std(matrix)</span><br><span class="line">&gt;&gt;&gt; 3.4520525295346629</span><br></pre></td></tr></table></figure>

<h3 id="重塑矩阵"><a href="#重塑矩阵" class="headerlink" title="重塑矩阵"></a>重塑矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第二维可以为-1让程序自己推断，如matrix.reshape(2, -1)</span><br><span class="line">matrix.reshape(2, 6)</span><br><span class="line">&gt;&gt;&gt; array([[ 1,  2,  3,  4,  5,  6],</span><br><span class="line">       [ 7,  8,  9, 10, 11, 12]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="矩阵加减法"><a href="#矩阵加减法" class="headerlink" title="矩阵加减法"></a>矩阵加减法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建矩阵a</span><br><span class="line">matrix_a &#x3D; np.array([[1, 1, 1],</span><br><span class="line">                     [1, 1, 1],</span><br><span class="line">                     [1, 1, 2]])</span><br><span class="line"></span><br><span class="line"># 创建矩阵b</span><br><span class="line">matrix_b &#x3D; np.array([[1, 3, 1],</span><br><span class="line">                     [1, 3, 1],</span><br><span class="line">                     [1, 3, 8]])</span><br><span class="line"></span><br><span class="line"># 矩阵相加</span><br><span class="line">np.add(matrix_a, matrix_b)</span><br><span class="line">array([[ 2,  4,  2],</span><br><span class="line">       [ 2,  4,  2],</span><br><span class="line">       [ 2,  4, 10]])</span><br><span class="line"></span><br><span class="line"># 矩阵相减</span><br><span class="line">np.subtract(matrix_a, matrix_b)</span><br><span class="line">array([[ 0, -2,  0],</span><br><span class="line">       [ 0, -2,  0],</span><br><span class="line">       [ 0, -2, -6]])</span><br></pre></td></tr></table></figure>

<h3 id="对矩阵元素进行操作"><a href="#对矩阵元素进行操作" class="headerlink" title="对矩阵元素进行操作"></a>对矩阵元素进行操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个方法：对每个元素加10</span><br><span class="line">add_100 &#x3D; lambda i: i + 10</span><br><span class="line"></span><br><span class="line"># 在对numpy的数组进行操作时,我们应该尽量避免循环操作,尽可能利用矢量化函数来避免循环。但是,直接将自定义函数应用在numpy数组之上会报错,我们需要将函数进行矢量化转换.</span><br><span class="line">vectorized_add_100 &#x3D; np.vectorize(add_100)</span><br><span class="line"></span><br><span class="line"># 最后将函数应用到矩阵上</span><br><span class="line">vectorized_add_100(matrix)</span><br><span class="line">&gt;&gt;&gt; array([[11, 12, 13],</span><br><span class="line">           [14, 15, 16],</span><br><span class="line">           [17, 18, 19],</span><br><span class="line">           [20, 21, 22]])</span><br></pre></td></tr></table></figure>

<h3 id="创建稀疏矩阵"><a href="#创建稀疏矩阵" class="headerlink" title="创建稀疏矩阵"></a>创建稀疏矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个矩阵，其中零元素远远多于非零元素</span><br><span class="line">matrix &#x3D; np.array([[0, 0],</span><br><span class="line">                   [1, 0],</span><br><span class="line">                   [0, 6]])</span><br><span class="line"># 由于稀疏矩阵中非零元素较少，零元素较多，因此可以采用只存储非零元素的方法来进行压缩存储。</span><br><span class="line"># 另外对于很多元素为零的稀疏矩阵，仅存储非零元素可使矩阵操作效率更高，速度更快。</span><br><span class="line"># python不能自动创建稀疏矩阵，所以要用scipy中特殊的命令来得到稀疏矩阵。</span><br><span class="line">from scipy import sparse</span><br><span class="line">matrix_sparse &#x3D; sparse.csr_matrix(matrix)</span><br></pre></td></tr></table></figure>

<h3 id="描述一个矩阵"><a href="#描述一个矩阵" class="headerlink" title="描述一个矩阵"></a>描述一个矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看行和列</span><br><span class="line">matrix.shape</span><br><span class="line">&gt;&gt;&gt; (4, 3)</span><br><span class="line"># 查看所有元素个数（行*列）</span><br><span class="line">matrix.size</span><br><span class="line">&gt;&gt;&gt; 12</span><br><span class="line"># 查看维数</span><br><span class="line">matrix.ndim</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>

<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最大值</span><br><span class="line">np.max(matrix)</span><br><span class="line">&gt;&gt;&gt; 12</span><br><span class="line"># 最小值</span><br><span class="line">np.min(matrix)</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line"># 按列查找最大元素</span><br><span class="line">np.max(matrix, axis&#x3D;0)</span><br><span class="line">&gt;&gt;&gt; array([10, 11, 12])</span><br><span class="line"># 按行查找最大元素</span><br><span class="line">np.max(matrix, axis&#x3D;1)</span><br><span class="line">&gt;&gt;&gt; array([3, 6, 9，12])</span><br></pre></td></tr></table></figure>

<h3 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a>矩阵求逆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个新矩阵</span><br><span class="line">matrix_n &#x3D; np.array([[1, 2],</span><br><span class="line">                   [3, 4]])</span><br><span class="line"># 计算逆矩阵</span><br><span class="line">np.linalg.inv(matrix_n)</span><br><span class="line">&gt;&gt;&gt; array([[-2. ,  1. ],</span><br><span class="line">       [ 1.5, -0.5]])</span><br></pre></td></tr></table></figure>

<h3 id="展平矩阵"><a href="#展平矩阵" class="headerlink" title="展平矩阵"></a>展平矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix.flatten()</span><br><span class="line">&gt;&gt;&gt; array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br></pre></td></tr></table></figure>

<h3 id="元素选择"><a href="#元素选择" class="headerlink" title="元素选择"></a>元素选择</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对一个向量</span><br><span class="line">vector &#x3D; np.array([1, 2, 3, 4, 5, 6])</span><br><span class="line">vector[1]</span><br><span class="line">&gt;&gt;&gt; 2</span><br><span class="line"># 对于一个矩阵</span><br><span class="line">matrix &#x3D; np.array([[1, 2, 3],</span><br><span class="line">                   [4, 5, 6],</span><br><span class="line">                   [7, 8, 9]])</span><br><span class="line">matrix[1,1]</span><br><span class="line">&gt;&gt;&gt; 5</span><br><span class="line">对于一个张量（高维矩阵）</span><br><span class="line">tensor &#x3D; np.array([</span><br><span class="line">    [[[1, 1], [1, 1]], [[2, 2], [2, 2]]],</span><br><span class="line">    [[[3, 3], [3, 3]], [[4, 4], [4, 4]]]</span><br><span class="line">                  ])</span><br><span class="line">tensor[1,1,1]</span><br><span class="line">&gt;&gt;&gt; array([4, 4])</span><br></pre></td></tr></table></figure>

<h3 id="计算矩阵点乘（对应位置相乘之后再相加）"><a href="#计算矩阵点乘（对应位置相乘之后再相加）" class="headerlink" title="计算矩阵点乘（对应位置相乘之后再相加）"></a>计算矩阵点乘（对应位置相乘之后再相加）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector_a &#x3D; np.array([1,2,3])</span><br><span class="line">vector_b &#x3D; np.array([4,5,6])</span><br><span class="line"># 方法一</span><br><span class="line">np.dot(vector_a, vector_b)</span><br><span class="line">&gt;&gt;&gt; 32</span><br><span class="line"># 方法二</span><br><span class="line">vector_a @ vector_b</span><br><span class="line">&gt;&gt;&gt; 32</span><br></pre></td></tr></table></figure>

<h3 id="计算矩阵的行列式（The-Determinant-Of-A-Matrix）、矩阵的迹（The-Trace-Of-A-Matrix）和矩阵的秩（The-Rank-Of-A-Matrix）"><a href="#计算矩阵的行列式（The-Determinant-Of-A-Matrix）、矩阵的迹（The-Trace-Of-A-Matrix）和矩阵的秩（The-Rank-Of-A-Matrix）" class="headerlink" title="计算矩阵的行列式（The Determinant Of A Matrix）、矩阵的迹（The Trace Of A Matrix）和矩阵的秩（The Rank Of A Matrix）"></a>计算矩阵的行列式（The Determinant Of A Matrix）、矩阵的迹（The Trace Of A Matrix）和矩阵的秩（The Rank Of A Matrix）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix &#x3D; np.array([[1, 2, 3],</span><br><span class="line">                   [4, 5, 6],</span><br><span class="line">                   [7, 8, 9]])</span><br><span class="line"># 行列式：行列式（Determinant）是数学中的一个函数，将一个 n*n的矩阵A映射到一个标量，记作det(A)或|A|</span><br><span class="line">np.linalg.det(matrix)</span><br><span class="line">&gt;&gt;&gt; -9.5161973539299405e-16</span><br><span class="line"></span><br><span class="line"># 迹：在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)。</span><br><span class="line"># 先获得矩阵的对角线</span><br><span class="line">matrix.diagonal()</span><br><span class="line">&gt;&gt;&gt; array([1, 5, 9])</span><br><span class="line"># 对角线求和就是迹</span><br><span class="line">matrix.diagonal().sum()</span><br><span class="line">&gt;&gt;&gt; 15</span><br><span class="line"># 秩：在线性代数中，一个矩阵A的列秩是A的线性独立的纵列的极大数目。</span><br><span class="line">np.linalg.matrix_rank(matrix)</span><br><span class="line">&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>

<h3 id="矢量或矩阵转置"><a href="#矢量或矩阵转置" class="headerlink" title="矢量或矩阵转置"></a>矢量或矩阵转置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个矢量</span><br><span class="line">vector &#x3D; np.array([1, 2, 3, 4, 5, 6])</span><br><span class="line"># 转置</span><br><span class="line">vector.T</span><br><span class="line">&gt;&gt;&gt; array([1, 2, 3, 4, 5, 6])</span><br><span class="line"></span><br><span class="line"># 创建一个矩阵</span><br><span class="line">matrix &#x3D; np.array([[1, 2, 3],</span><br><span class="line">                   [4, 5, 6],</span><br><span class="line">                   [7, 8, 9]])</span><br><span class="line"># 转置</span><br><span class="line">matrix.T</span><br><span class="line">&gt;&gt;&gt; array([[1, 4, 7],</span><br><span class="line">          [2, 5, 8],</span><br><span class="line">          [3, 6, 9]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://chrisalbon.com/" target="_blank" rel="noopener">https://chrisalbon.com/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>matrix</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>可能是最全的数据标准化教程（附python代码）</title>
    <url>/scaler/</url>
    <content><![CDATA[<h3 id="什么是数据标准化（归一化）"><a href="#什么是数据标准化（归一化）" class="headerlink" title="什么是数据标准化（归一化）"></a>什么是数据标准化（归一化）</h3><p>数据标准化（归一化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，当各指标间的水平相差很大时，如果直接用原始指标值进行分析，就会突出数值较高的指标在综合分析中的作用，相对削弱数值水平较低指标的作用。为了消除指标之间的量纲影响，保证结果的可靠性，需要进行数据标准化处理，以解决数据指标之间的可比性。</p>
<h3 id="为什么要数据归一化："><a href="#为什么要数据归一化：" class="headerlink" title="为什么要数据归一化："></a>为什么要数据归一化：</h3><p>1）归一化后加快了梯度下降求最优解的速度；</p>
<p>当存在多个特征时，如果特征数据范围不一致，可能会导致梯度下降的路径摇摆不定，效率低下。</p>
<p>如下图所示，蓝色的圈圈图代表的是两个特征的等高线。其中左图两个特征X1和X2的区间相差非常大，X1区间是[0,2000]，X2区间是[1,5]，其所形成的等高线非常尖。当使用梯度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-2b87fba30d7d8c39.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>而右图对两个原始特征进行了归一化，其对应的等高线显得很圆，最优解的寻优过程明显会变得平缓，更容易正确的收敛到最优解。</p>
<p>因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。</p>
<p>2）归一化有可能提高精度。</p>
<p>一些分类器需要计算样本之间的距离（如欧氏距离），例如KNN。如果一个特征值域范围非常大，那么距离计算就主要取决于这个特征，从而与实际情况相悖（比如这时实际情况是值域范围小的特征更重要）。</p>
<h3 id="常见的数据归一化方法"><a href="#常见的数据归一化方法" class="headerlink" title="常见的数据归一化方法"></a>常见的数据归一化方法</h3><h4 id="1-线性归一化"><a href="#1-线性归一化" class="headerlink" title="1) 线性归一化"></a>1) 线性归一化</h4><p>也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 &#8211; 1]之间。转换函数如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-94e9d5bb24586dbb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>其中max为样本数据的最大值，min为样本数据的最小值。</p>
<p>这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。</p>
<p>#####python代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Normalization(x):</span><br><span class="line">    return [(float(i)-min(x))&#x2F;float(max(x)-min(x)) for i in x]</span><br><span class="line"></span><br><span class="line"># 或者调用sklearn包的方法</span><br><span class="line">from sklearn import preprocessing   </span><br><span class="line">import numpy as np  </span><br><span class="line">X &#x3D; np.array([[ 1., -1.,  2.],  </span><br><span class="line">              [ 2.,  0.,  0.],  </span><br><span class="line">              [ 0.,  1., -1.]])  </span><br><span class="line">min_max_scaler &#x3D; preprocessing.MinMaxScaler()  </span><br><span class="line">X_minMax &#x3D; min_max_scaler.fit_transform(X)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-如果想要将数据映射到-1-1-，则将公式换成："><a href="#1-如果想要将数据映射到-1-1-，则将公式换成：" class="headerlink" title="1*) 如果想要将数据映射到[-1,1]，则将公式换成："></a>1*) 如果想要将数据映射到[-1,1]，则将公式换成：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1670644-8176b7d078797d44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>x_mean表示数据的均值。</p>
<h5 id="python代码："><a href="#python代码：" class="headerlink" title="python代码："></a>python代码：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Normalization2(x):</span><br><span class="line">    return [(float(i)-np.mean(x))&#x2F;(max(x)-min(x)) for i in x]</span><br></pre></td></tr></table></figure>

<h4 id="2-标准差标准化"><a href="#2-标准差标准化" class="headerlink" title="2) 标准差标准化"></a>2) 标准差标准化</h4><p>也称为z-score标准化。这种方法根据原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-2cbdb3df80aa93f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>其中μ为所有样本数据的均值，σ为所有样本数据的标准差。</p>
<blockquote>
<p>在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，Z-score标准化表现更好。 </p>
</blockquote>
<h4 id="python代码：-1"><a href="#python代码：-1" class="headerlink" title="python代码："></a>python代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sklearn import preprocessing   </span><br><span class="line">import numpy as np  </span><br><span class="line">X &#x3D; np.array([[ 1., -1.,  2.],  </span><br><span class="line">              [ 2.,  0.,  0.],  </span><br><span class="line">              [ 0.,  1., -1.]])  </span><br><span class="line"># calculate mean  </span><br><span class="line">X_mean &#x3D; X.mean(axis&#x3D;0)  </span><br><span class="line"># calculate variance   </span><br><span class="line">X_std &#x3D; X.std(axis&#x3D;0)  </span><br><span class="line"># standardize X  </span><br><span class="line">X1 &#x3D; (X-X_mean)&#x2F;X_std  # 自己计算</span><br><span class="line"># use function preprocessing.scale to standardize X  </span><br><span class="line">X_scale &#x3D; preprocessing.scale(X)  # 调用sklearn包的方法</span><br><span class="line"># 最终X1与X_scale等价</span><br></pre></td></tr></table></figure>

<h4 id="3-非线性归一化"><a href="#3-非线性归一化" class="headerlink" title="3) 非线性归一化"></a>3) 非线性归一化</h4><p>经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、指数，正切等。需要根据数据分布的情况，决定非线性函数的曲线，比如log(V, 2)还是log(V, 10)等。</p>
<h5 id="3-1-对数转换"><a href="#3-1-对数转换" class="headerlink" title="3.1 对数转换"></a>3.1 对数转换</h5><p>y=log10(x) /log10(max)</p>
<h5 id="3-2-反余切函数转换"><a href="#3-2-反余切函数转换" class="headerlink" title="3.2 反余切函数转换"></a>3.2 反余切函数转换</h5><p>y=atan(x)*2/PI</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>归一化</tag>
        <tag>标准化</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号爬虫</title>
    <url>/gongzhonggao_spider/</url>
    <content><![CDATA[<h3 id="微信公众号爬虫"><a href="#微信公众号爬虫" class="headerlink" title="微信公众号爬虫"></a>微信公众号爬虫</h3><p>微信团队于2017-06-06发布更新：</p>
<blockquote>
<p>“ 对所有公众号开放，在图文消息正文中插入自己帐号和其他公众号已群发文章链接的能力。”</p>
</blockquote>
<blockquote>
<p>那么，利用这个接口，我们就可以爬取指定公众号的文章链接了 </p>
</blockquote>
<p>文章参考：<a href="http://cuiqingcai.com/4652.html" target="_blank" rel="noopener">静觅</a></p>
<p>准备工具：一个订阅号，安装selenium</p>
<p>爬取步骤：</p>
<ol>
<li>get_cookie.py用selenium登陆，获取cookie，其中你需要勾选“记住”选项，还需要微信扫描二维码，确定顺利登陆</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">post = &#123;&#125;</span><br><span class="line"></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">"user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span>)</span><br><span class="line">driver = webdriver.Chrome(<span class="string">'/Users/weiweiwang/code/financialNews/chromedriver'</span>,chrome_options=chrome_options)</span><br><span class="line">driver.get(<span class="string">'https://mp.weixin.qq.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@name='account']"</span>).clear()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@name='account']"</span>).send_keys(<span class="string">'你的账号'</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@name='password']"</span>).clear()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@name='password']"</span>).send_keys(<span class="string">'你的密码'</span>)</span><br><span class="line"><span class="comment"># 在自动输完密码之后记得点一下记住我</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//a[@class='btn_login']"</span>).click()</span><br><span class="line"><span class="comment"># 拿手机扫二维码！</span></span><br><span class="line">time.sleep(<span class="number">15</span>)</span><br><span class="line">driver.get(<span class="string">'https://mp.weixin.qq.com/'</span>)</span><br><span class="line">cookie_items = driver.get_cookies()</span><br><span class="line"><span class="keyword">for</span> cookie_item <span class="keyword">in</span> cookie_items:</span><br><span class="line">    post[cookie_item[<span class="string">'name'</span>]] = cookie_item[<span class="string">'value'</span>]</span><br><span class="line">cookie_str = json.dumps(post)</span><br><span class="line"><span class="keyword">with</span> io.open(<span class="string">'cookie.txt'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(cookie_str.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<ol start="2">
  <li>
    get_url.py获取你需要的公众号的历史文章链接
  </li>
</ol>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gzlist = [<span class="string">'yq_Butler'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://mp.weixin.qq.com'</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">"HOST"</span>: <span class="string">"mp.weixin.qq.com"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> io.open(<span class="string">'cookie.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cookie = f.read()</span><br><span class="line">cookies = json.loads(cookie)</span><br><span class="line">response = requests.get(url=url, cookies=cookies)</span><br><span class="line">token = re.findall(<span class="string">r'token=(\d+)'</span>, str(response.url))[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> gzlist:</span><br><span class="line">    query_id = &#123;</span><br><span class="line">        <span class="string">'action'</span>: <span class="string">'search_biz'</span>,</span><br><span class="line">        <span class="string">'token'</span> : token,</span><br><span class="line">        <span class="string">'lang'</span>: <span class="string">'zh_CN'</span>,</span><br><span class="line">        <span class="string">'f'</span>: <span class="string">'json'</span>,</span><br><span class="line">        <span class="string">'ajax'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'random'</span>: random.random(),</span><br><span class="line">        <span class="string">'query'</span>: query,</span><br><span class="line">        <span class="string">'begin'</span>: <span class="string">'0'</span>,</span><br><span class="line">        <span class="string">'count'</span>: <span class="string">'5'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    search_url = <span class="string">'https://mp.weixin.qq.com/cgi-bin/searchbiz?'</span></span><br><span class="line">    search_response = requests.get(search_url, cookies=cookies, headers=header, params=query_id)</span><br><span class="line">    lists = search_response.json().get(<span class="string">'list'</span>)[<span class="number">0</span>]</span><br><span class="line">    fakeid = lists.get(<span class="string">'fakeid'</span>)</span><br><span class="line">    query_id_data = &#123;</span><br><span class="line">        <span class="string">'token'</span>: token,</span><br><span class="line">        <span class="string">'lang'</span>: <span class="string">'zh_CN'</span>,</span><br><span class="line">        <span class="string">'f'</span>: <span class="string">'json'</span>,</span><br><span class="line">        <span class="string">'ajax'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'random'</span>: random.random(),</span><br><span class="line">        <span class="string">'action'</span>: <span class="string">'list_ex'</span>,</span><br><span class="line">        <span class="string">'begin'</span>: <span class="string">'0'</span>,</span><br><span class="line">        <span class="string">'count'</span>: <span class="string">'5'</span>,</span><br><span class="line">        <span class="string">'query'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'fakeid'</span>: fakeid,</span><br><span class="line">        <span class="string">'type'</span>: <span class="string">'9'</span></span><br><span class="line">    &#125;</span><br><span class="line">    appmsg_url = <span class="string">'https://mp.weixin.qq.com/cgi-bin/appmsg?'</span></span><br><span class="line">    appmsg_response = requests.get(appmsg_url, cookies=cookies, headers=header, params=query_id_data)</span><br><span class="line">    max_num = appmsg_response.json().get(<span class="string">'app_msg_cnt'</span>)</span><br><span class="line">    num = int(int(max_num) / <span class="number">5</span>)</span><br><span class="line">    begin = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num + <span class="number">1</span> &amp;gt; <span class="number">0</span> :</span><br><span class="line">        query_id_data = &#123;</span><br><span class="line">            <span class="string">'token'</span>: token,</span><br><span class="line">            <span class="string">'lang'</span>: <span class="string">'zh_CN'</span>,</span><br><span class="line">            <span class="string">'f'</span>: <span class="string">'json'</span>,</span><br><span class="line">            <span class="string">'ajax'</span>: <span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'random'</span>: random.random(),</span><br><span class="line">            <span class="string">'action'</span>: <span class="string">'list_ex'</span>,</span><br><span class="line">            <span class="string">'begin'</span>: <span class="string">'&#123;&#125;'</span>.format(str(begin)),</span><br><span class="line">            <span class="string">'count'</span>: <span class="string">'5'</span>,</span><br><span class="line">            <span class="string">'query'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'fakeid'</span>: fakeid,</span><br><span class="line">            <span class="string">'type'</span>: <span class="string">'9'</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">'翻页###################'</span>,begin)</span><br><span class="line">        query_fakeid_response = requests.get(appmsg_url, cookies=cookies, headers=header, params=query_id_data)</span><br><span class="line">        fakeid_list = query_fakeid_response.json().get(<span class="string">'app_msg_list'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> fakeid_list:</span><br><span class="line">            print(item.get(<span class="string">'link'</span>))</span><br><span class="line">        num -= <span class="number">1</span></span><br><span class="line">        begin = int(begin)</span><br><span class="line">        begin+=<span class="number">5</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有代码见 <a href="https://github.com/wwwxmu/weixin" target="_blank" rel="noopener">github</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>公众号</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年，我们追过的周杰伦</title>
    <url>/chou/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1670644-b919f03176afbb7c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>很早之前写了个网易云音乐的爬虫，准备把网易云音乐的所有歌曲信息和评论信息抓下来，但是爬虫开始工作不到一天，服务器就被网易云音乐给ban了&gt;_&lt;&#8230;然后爬虫就这么被搁置了。</p>
<p>这段时间趁国庆中秋超长假，赶紧把爬虫恢复起来（之前的花的时间不能白废啊），但是这次打死也不敢再数十个线程一起开，所有的信息想要……这一次，我们一个歌手一个歌手爬！那就从周董开始吧～</p>
<p>呐，368首歌曲，4987条热评，咱们用数字来聊一聊周杰伦，聊聊那些个青春。</p>
<h3 id="1-年份与歌曲发行数"><a href="#1-年份与歌曲发行数" class="headerlink" title="1 年份与歌曲发行数"></a>1 年份与歌曲发行数</h3><p>从2000出道发行首张个人专辑《Jay》到2016年的《周杰伦的床边故事》，周杰伦从一个不羁少年变成了胡子奶爸，十六年间，周杰伦发行了31张专辑368首歌曲（包括演唱会），让我们来看看从2000到2016年，每年周董发行歌曲数量的变化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-0f755d535b9ebd21.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="2-情感分析"><a href="#2-情感分析" class="headerlink" title="2 情感分析"></a>2 情感分析</h3><p>对周杰伦的每首歌的歌词进行情感分析，得到150+首歌情感倾向积极乐观，140+首歌情感偏消极忧伤，总体来看，“喜忧参半”，比较平均。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-086c5782717b19dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-情绪词"><a href="#3-情绪词" class="headerlink" title="3 情绪词"></a>3 情绪词</h3><p>“微笑”和“眼泪”并存，再一次证实上面的结论。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-a70a05874f9619cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="4-歌词画像"><a href="#4-歌词画像" class="headerlink" title="4 歌词画像"></a>4 歌词画像</h3><p>我把周杰伦所有的歌词串起来，去除停用词和标点符点号，用词云工具生成了周杰伦的歌词画像，字号越大，说明这个词出现的频率越多。“离开”，“回忆”，“安静”，“阳光”，“幸福”，“爱”……单这些关键词随意拼凑，都可以勾勒出一幅唯美的画面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-ec42fd703ef26008.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="5-语气词"><a href="#5-语气词" class="headerlink" title="5 语气词"></a>5 语气词</h3><p>“快使用双截棍，哼哼哈兮”，周杰伦歌词中的语气词随处可见，下图是出现频率最高的语气词，“oh”是周杰伦的最爱。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-13e7a76407720554.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="6-至亲"><a href="#6-至亲" class="headerlink" title="6 至亲"></a>6 至亲</h3><p>“听妈妈的话，别让她受伤”，在周杰伦最孤独无助的时候，是母亲叶惠美用温暖的臂膀支撑着他。那么，还有哪些至亲，在周杰伦的心里占据着重要的位置呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-b98ddf094ddf7855.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="7-季节"><a href="#7-季节" class="headerlink" title="7 季节"></a>7 季节</h3><p>“你说这一句，很有夏天的感觉”，周杰伦是喜欢夏天的，但你知道他的歌词中出现最多的其实是秋天吗？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-b740aaca3bac79e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="8-人称代词"><a href="#8-人称代词" class="headerlink" title="8 人称代词"></a>8 人称代词</h3><p>“我想带你回我的外婆家”，周杰伦的歌大多都是面对面倾诉，或者一个人自说自话的，所以可以看出“我”和“你”出现的频繁远高于其他词。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-4172841e19a3f07b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="9-时间点"><a href="#9-时间点" class="headerlink" title="9 时间点"></a>9 时间点</h3><p>相对于“结局”，周杰伦还是比较喜欢“开始”；他怀念“过去”胜过“现在”和“未来”，对“永远”的渴求一直都在。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-7c02a62a4371b288.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="10-地点"><a href="#10-地点" class="headerlink" title="10 地点"></a>10 地点</h3><p>“中国风”是周杰伦歌曲的一大特色，从歌词中出现的地点也可以看出，周杰伦对“祖国”，对“北京”还是情有独钟的，另外，“中国功夫”的发源地——河南也是很抢眼。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-d9f909702dd9fe54.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>歌词说罢，还有精彩的评论不容错过。 </p>
</blockquote>
<h3 id="11-评论数"><a href="#11-评论数" class="headerlink" title="11 评论数"></a>11 评论数</h3><p>单《晴天》一首歌的评论数就达175万+，由于评论数实在太多，而且很多是垃圾评论，就没有把所有的评论爬下来，只爬取热评。先来看看评论数前十的歌曲，《晴天》过百万遥遥领先，《告白气球》、《七里香》、《以父之名》也都过十万。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1670644-3c1b1748e0e12438.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="12-最热评论"><a href="#12-最热评论" class="headerlink" title="12 最热评论"></a>12 最热评论</h3><p>下面是点赞数前十的评论，看完满满的回忆。</p>
<blockquote>
<p>高一听的，那时候遇到了孩儿他妈，然后就这么幸福下来了。—— 蛋蛋是圆D</p>
<p>刚刚我把这首歌分享给我喜欢的女生向她告白成功了！！！——败北滴少年</p>
<p>老子要听一辈子周杰伦！！！—— 原名被人占了真神奇啊</p>
<p>现在想来 我们这波第一批老去的90后还是挺幸运的 在我们最好的年龄遇到了最好的华语乐坛（周杰伦巅峰 林俊杰 SHE 潘玮柏 蔡依林…）遇到了巅峰的星爷 遇到了最好的西科东艾北卡南麦 动画城陪我们成长 周杰伦陪我们成熟 我们看着星爷老去 见证科比退役 或许我们不是最好的一代 但一定是最精彩的一代 —— 全球单身狗反秀恩爱联盟荣誉会长</p>
<p>周杰伦 你要对那么多人的青春负责 —— 长在地上的姑娘</p>
<p>开口就听哭了，仿佛回到了十几年前简单爱的夏天，用听英语的复读机播着他的歌，把歌词抄在日记本的最后一页，边抄边想着喜欢的女生，这种初恋般的幸福感只有周杰伦能给。如今我们很难再见面，但我们都还会听周杰伦的新歌。周杰伦是星晴，是园游会，是手写的从前，是告白气球。“拥有你就拥有全世界。” —— 夏至鸢尾</p>
<p>2004年是神奇的一年，那年有周杰伦的七里香，飞儿乐团的我们的爱，张韶涵的寓言，蔡依林的爱情三十六计，林俊杰的江南，梁静茹的宁夏，五月天的倔强，孙燕姿的我也很想他，王菲的旋木，SHE的波斯猫，王心凌的爱你，陈绮贞的旅行的意义，王力宏的心中的日月……都是青春的记忆…… —— 你是不沉的胖子</p>
<p>初中听周杰伦被同学嘲笑：唱的什么鬼…长那么丑…词都唱不清…他们哪知道若干年后会听着他的歌流泪一整晚，原来我们输给了时光，败给了唇红齿白的自己? —— 緑茶表</p>
<p>朋友们 今天是过年啊杰迷朋友们！！！！—— AllaboutJay</p>
<p>还是穷屌丝的时候约会只能去《园游会》捞鱼?，有钱了立马跑到塞纳河畔喝咖啡☕ —— 孑小水原孑然一身 </p>
</blockquote>
<p>如果你想要这些数据，请回复你的邮箱地址，小编看到后会第一时间发出。</p>
<p>如果你想了解其他歌手，也请告诉我们。</p>
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>周杰伦</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>python中如何import不同层级的模块</title>
    <url>/python_import/</url>
    <content><![CDATA[<p>python引入模块的几种情况</p>
<h3 id="同一目录"><a href="#同一目录" class="headerlink" title="同一目录"></a>同一目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- src</span><br><span class="line">    |-- main.py</span><br><span class="line">    |-- model.py</span><br></pre></td></tr></table></figure>

<p><code>main.py</code>为主文件，<code>model.py</code>是我们要引入的文件，则直接<code>import model</code>或<code>from model import *</code>即可。</p>
<h3 id="要引入的模块位于与主程序同级的目录下"><a href="#要引入的模块位于与主程序同级的目录下" class="headerlink" title="要引入的模块位于与主程序同级的目录下"></a>要引入的模块位于与主程序同级的目录下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- src</span><br><span class="line">    |-- model1.py</span><br><span class="line">    |-- lib</span><br><span class="line">    |   -- (__init__.py --&amp;gt;新建空文件)</span><br><span class="line">    |   -- model2.py</span><br><span class="line">    |-- main.py</span><br></pre></td></tr></table></figure>

<p>要在程序 <code>main.py</code> 中导入模块 <code>model2.py</code>, 需要在<code>lib</code>文件夹中建立空文件 <code>__init__.py</code> 文件(也可以在该文件中自定义输出模块接口); 然后使用 <code>from lib.model2 import *</code> 或<code>import lib.model2</code></p>
<h3 id="要引入的模块位于主程序上层目录的其他目录-平级-下"><a href="#要引入的模块位于主程序上层目录的其他目录-平级-下" class="headerlink" title="要引入的模块位于主程序上层目录的其他目录(平级)下"></a>要引入的模块位于主程序上层目录的其他目录(平级)下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- src</span><br><span class="line">    |-- model1.py</span><br><span class="line">    |-- lib</span><br><span class="line">    |   -- (__init__.py --&amp;gt;新建空文件)</span><br><span class="line">    |   -- model2.py</span><br><span class="line">    |-- sub</span><br><span class="line">    |   -- main.py</span><br></pre></td></tr></table></figure>

<p>这里想要实现<code>main.py</code>调用<code>model1.py</code>和<code>model2.py</code> ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件<code>__init__.py</code> ，就可以像第二步调用子目录下的模块一样，通过<code>import  lib.model2</code>进行调用了。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">".."</span>)</span><br><span class="line"><span class="keyword">import</span> model1</span><br><span class="line"><span class="keyword">import</span> lib.model2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，如何你不想新建<code>__init.py__</code>文件，则可以尝试如下的方法 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(os.path.abspath(<span class="string">'..'</span>)+<span class="string">'/lib'</span>)</span><br><span class="line"><span class="keyword">from</span> model2 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h4 id="参考：python-在不同层级目录import-模块的方法"><a href="#参考：python-在不同层级目录import-模块的方法" class="headerlink" title="参考：python 在不同层级目录import 模块的方法"></a>参考：<a href="http://blog.csdn.net/waleking/article/details/7600416" target="_blank" rel="noopener">python 在不同层级目录import 模块的方法</a></h4>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>import</tag>
      </tags>
  </entry>
  <entry>
    <title>【2017-09-05】博客大事记</title>
    <url>/Memorabilia/</url>
    <content><![CDATA[<p>“厦庇五洲客，门纳万顷涛”，托“金砖”的福放假几天，终于有时间整整博客。</p>
<p>之前博客放在1块钱腾讯云学生机（1核 1GB 1Mbps），内存太小了，compser的时候会报错，现在换到了阿里云10块钱的学生机（1核 2GB 1Mbps）。</p>
<h3 id="1-从腾讯云迁移到阿里云，同时更新到xblog-v-3-0-版本"><a href="#1-从腾讯云迁移到阿里云，同时更新到xblog-v-3-0-版本" class="headerlink" title="1. 从腾讯云迁移到阿里云，同时更新到xblog v 3.0 版本"></a>1. 从腾讯云迁移到阿里云，同时更新到xblog v 3.0 版本</h3><blockquote>
<p>阿里云系统：ubuntu 16.04 </p>
</blockquote>
<ul>
<li>安装PHP 7.1环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-software-properties</span><br><span class="line">apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej&#x2F;php</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y php7.1</span><br><span class="line">apt-get install -y php7.1-fpm</span><br><span class="line">sudo apt-get install php7.1-mysql php7.1-gd php7.1-curl php7.1-json php7.1-cgi</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下载最新版的xblog</p>
<p><code>git clone https://github.com/lufficc/Xblog.git</code></p>
<p>迁移数据库，添加.env文件（具体参考：<a href="http://mind.lufficc.com/Xblog/docs/" target="_blank" rel="noopener">http://mind.lufficc.com/Xblog/docs/</a>）</p>
</li>
<li><p>添加storage权限，清缓存</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 storage&#x2F;</span><br><span class="line">php artisan cache:clear</span><br><span class="line">composer dump-autoload</span><br></pre></td></tr></table></figure>

<ul>
<li>安装nginx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置nginx</p>
<p>在<code>/etc/nginx/sites-available</code>文件夹下添加<code>default</code>文件，内容如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only&#x3D;on;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;Xblog&#x2F;public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">    server_name weiweiblog.cn;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">                # Uncomment to enable naxsi on this location</span><br><span class="line">                # include &#x2F;etc&#x2F;nginx&#x2F;naxsi.rules</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">                try_files $uri &#x2F;index.php &#x3D;404;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;</span><br><span class="line">                fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.1-fpm.sock;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后重启ngnix</p>
<p><code>/etc/init.d/nginx restart</code></p>
<p>如此即可通过ip访问到网站</p>
</li>
<li><p>接下来把域名解析到该ip</p>
<p><img src="http://o9k8cdbt4.bkt.clouddn.com/image/XXtDhOsfRUSvyixEU3Pn2kMPAmyKb5nAqvcPfvfY.png" alt="file"></p>
</li>
<li><p>至此，即可通过<a href="https://weiweiblog.cn">weiweiblog.cn</a>访问到博客。</p>
</li>
</ul>
<h3 id="２-添加不蒜子的浏览量显示插件"><a href="#２-添加不蒜子的浏览量显示插件" class="headerlink" title="２.添加不蒜子的浏览量显示插件"></a>２.添加不蒜子的浏览量显示插件</h3><p>xblog用着挺舒服的，有个遗憾就是无法看到网站到目前为止的所有用户访问量，于是就自己来添加一个。</p>
<p>懒得自己写，刚好发现<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>提供了这个功能，两行代码即可搞定。</p>
<ol>
<li><p>在<code>xblog/resourse/view/layout/app.blade.php</code>的<code>&lt;head&gt;</code>中引入js文件<code>&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>在<code>xblog/resourse/view/layout/footer.blade.php</code>里面添加<code>&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</code>即可显示。</p>
</li>
</ol>
<h3 id="3-启动https安全访问"><a href="#3-启动https安全访问" class="headerlink" title="3. 启动https安全访问"></a>3. 启动https安全访问</h3><p>如今https已经成为主流，没有https的网站给人感觉就是钓鱼网站。跟一波潮流，咱也把https搞起来。</p>
<p>调研一翻发现阿里云刚好提供了一年的云盾证书服务，不用白不用</p>
<p><img src="http://o9k8cdbt4.bkt.clouddn.com/image/dTG7sC7Fdei2H86hTkdofsDOCcnVjQmeMzi47MXY.png" alt="file"></p>
<p>申请教程：<a href="https://www.xiaoz.me/archives/7442" target="_blank" rel="noopener">免费申请阿里云DV SSL证书</a></p>
<p>很快就申请到了证书，下载证书上传到服务器的<code>/etc/nginx/cert</code>目录下，配置<code>/etc/nginx/sites-available/default</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 http2;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;214215565380063.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;cert&#x2F;214215565380063.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;Xblog&#x2F;public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">    server_name weiweiblog.cn;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">                # Uncomment to enable naxsi on this location</span><br><span class="line">                # include &#x2F;etc&#x2F;nginx&#x2F;naxsi.rules</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">                try_files $uri &#x2F;index.php &#x3D;404;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;</span><br><span class="line">                fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.1-fpm.sock;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param HTTPS on; #attention!#</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only&#x3D;on;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;Xblog&#x2F;public;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line">    server_name weiweiblog.cn;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;</span><br><span class="line">                # Uncomment to enable naxsi on this location</span><br><span class="line">                # include &#x2F;etc&#x2F;nginx&#x2F;naxsi.rules</span><br><span class="line">        &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">                try_files $uri &#x2F;index.php &#x3D;404;</span><br><span class="line">                fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;</span><br><span class="line">                fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.1-fpm.sock;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">    rewrite ^&#x2F;(.*) https:&#x2F;&#x2F;$server_name$1 permanent;    #跳转到Https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx：<code>/etc/init.d/nginx restart</code>即可~</p>
<p>今后咱也是有安全的小绿锁的人了！</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ft1qgca3koj30j204maa1.jpg" alt=""></p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>之前配置完后，https并不能正常访问，原来是阿里云的安全策略没有开启443端口，服务器防火墙也要开启443端口。</p>
<p>参考：<a href="https://gtour.info/how-to-configure-iptables-firewall-in-ubuntu-16-04/" target="_blank" rel="noopener">如何在 Ubuntu 16.04 配置 iptables 防火牆</a></p>
]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>把Safari当chrome用（插件篇）</title>
    <url>/safari_chrome/</url>
    <content><![CDATA[<h3 id="1-Markdown-Here"><a href="#1-Markdown-Here" class="headerlink" title="1. Markdown Here"></a>1. Markdown Here</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fj4zknkyx6j30pc0ar0sp.jpg" alt=""></p>
<blockquote>
<p>Write email in Markdown, and then make it pretty. </p>
</blockquote>
<p><strong>主页：</strong><a href="http://markdown-here.com" target="_blank" rel="noopener">http://markdown-here.com</a></p>
<p><strong>点评：</strong>在网页的编辑器中用markdown的语法输入内容，然后右击选择<code>Markdown Toggle</code>或者按下markdown here插件的图标或者按下快捷键<code>CTRL+ALT+M</code>即可完成渲染，让你轻松搞定内容排版。</p>
<p>更多设置，请参考：<a href="http://www.veganshe.com/tech/use-markdown-here-to-layout/" target="_blank" rel="noopener">利用 Markdown Here 实现高效排版</a></p>
<h3 id="2-AutoPagerize"><a href="#2-AutoPagerize" class="headerlink" title="2. AutoPagerize"></a>2. AutoPagerize</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fj50gnj05ej318i0fcmyx.jpg" alt=""></p>
<blockquote>
<p>A browser Extension for auto loading paginated web pages. AutoPagerize use in many web site, and provide efficiently web browsing. </p>
</blockquote>
<p><strong>主页：</strong><a href="http://autopagerize.net" target="_blank" rel="noopener">http://autopagerize.net</a></p>
<p><strong>点评：</strong>相信很多人曾经都有这么一个体会：当每次浏览网页、贴吧或者一些论坛时，PC端的页面中底部总会有这么几个字：“下一页”，只有当我们点击下一页后才能浏览第二页的信息，点击第三页才能浏览第三页的信息。这样不但浪费大量时间，还很麻烦！<code>AutoPagerize</code>就是为了解决这个痛点而生的！它是一款自动翻页插件，当你的浏览到页面底部时，它便会帮你自动加载下一页的内容无缝拼接到当前页底部，省去你点击下一页的麻烦。</p>
<h3 id="3-Scroll-To-Top-Button"><a href="#3-Scroll-To-Top-Button" class="headerlink" title="3. Scroll To Top Button"></a>3. Scroll To Top Button</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fj50vxvveej30rs0lygmg.jpg" alt=""></p>
<blockquote>
<p>Safari Extension which adds a button that scrolls to the top of the page. Inspired by the one on the Tumblr Dashboard. </p>
</blockquote>
<p><strong>主页：</strong><a href="http://www.scrolltotopbutton.com" target="_blank" rel="noopener">http://www.scrolltotopbutton.com</a></p>
<p><strong>点评：</strong>Scroll To Top Button顾名思义就是在页面中增加一个to top的按钮，点一下即可飞回页面顶部，该插件配合<code>AutoPagerize</code>真是天作之合啊！</p>
<h3 id="4-Polyglot"><a href="#4-Polyglot" class="headerlink" title="4. Polyglot"></a>4. Polyglot</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fj50zwtqepj30oo08v3yg.jpg" alt=""></p>
<blockquote>
<p>The missing Safari extension that translates selected text into your native language. </p>
</blockquote>
<p><strong>主页：</strong><a href="https://github.com/uetchy/Polyglot" target="_blank" rel="noopener">https://github.com/uetchy/Polyglot</a></p>
<p><strong>点评：</strong>一直在寻找谷歌浏览器中选词翻译的工具（不是整页翻译），终于让我找到了Polyglot。它调用的是谷歌翻译的接口，速度也还可以，翻译的界面也挺美观，唯一的缺点是不能选中文本自动翻译，还要点击一下插件按钮或者按快捷键，不过聊胜于无，先用着，期待发现更好用的翻译插件吧。</p>
<blockquote>
<p>该插件存在bug，有些按钮设置成快捷键还不能用，开发者自己说了“Some key combinations are preblematic. Try another one”。我设置成<code>Control+1</code>亲测可用 </p>
</blockquote>
<h3 id="5-TabList"><a href="#5-TabList" class="headerlink" title="5. TabList"></a>5. TabList</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fj51avfiwjj30w20n175g.jpg" alt=""></p>
<blockquote>
<p>This Browser Extension creates a list of links to all open tabs, in all open windows.</p>
</blockquote>
<blockquote>
<p>The list is cleanly organized, and you have the ability to save lists for later. </p>
</blockquote>
<p><strong>主页：</strong><a href="https://tablister.com" target="_blank" rel="noopener">https://tablister.com</a></p>
<p><strong>点评：</strong>Chrome的深度用者应该对OneTab不陌生吧。我们经常会一次打开好多tab，很多是会用到的，又不舍得关，内存又耗着，这个时候点击下OneTab，你当前所有打开的页面都会被关闭，整合呈现成为一个列表，显示在一个新打开的 OneTab 标签页中。<code>TabList</code>就是Safari版的OneTab，它可以一键关闭所有开者的页面，并把它们的链接都保存下来放在新生成的列表页面中，方便随时打开。麻麻再也不用担心我开太多页面会把浏览器爆掉了～～～e</p>
<h3 id="6-围脖是个好图床"><a href="#6-围脖是个好图床" class="headerlink" title="6. 围脖是个好图床"></a>6. 围脖是个好图床</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fj522keic9j30uq0iq751.jpg" alt=""></p>
<p><strong>主页：</strong><a href="http://weibotuchuang.sinaapp.com" target="_blank" rel="noopener">http://weibotuchuang.sinaapp.com</a></p>
<p><strong>说明：</strong>图床：网络相册，或叫在线相册，为运行、储存以及翻阅、分享于互联网的相册。<code>围脖是个好图床</code>就是利用新浪微博来保存图片，使用简单。</p>
<blockquote>
<p>注意任何第三方的免费图片储存服务都无法保证长期可用，也无法保证一直可用外链，把数据掌握在自己手里才靠谱。 </p>
</blockquote>
<h3 id="7-NoMoreiTunes"><a href="#7-NoMoreiTunes" class="headerlink" title="7. NoMoreiTunes"></a>7. NoMoreiTunes</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fj52fn5j23j31980bemxk.jpg" alt=""></p>
<blockquote>
<p>Preventing iTunes Preview and App Store pages in Safari from launching iTunes since 2010. </p>
</blockquote>
<p><strong>主页：</strong><a href="http://nomoreitunes.einserver.de" target="_blank" rel="noopener">http://nomoreitunes.einserver.de</a></p>
<p><strong>说明：</strong>打开App Store应用链接只打开网页不打开 iTunes</p>
<h3 id="8-mama2"><a href="#8-mama2" class="headerlink" title="8. mama2"></a>8. mama2</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fj52j5si01j311e0i4t9a.jpg" alt=""></p>
<p><strong>主页：</strong><a href="http://zythum.github.io/mama2/" target="_blank" rel="noopener">http://zythum.github.io/mama2/</a></p>
<p><strong>说明：</strong>【妈妈再也不用担心我的 MacBook 发热了计划2】妈妈计划用于解决在看视频网站时 MacBook 发热严重的问题。使用 video 来替换原来的 flash 播放器。</p>
<p>目前网站支持列表:</p>
<ul>
<li>哔哩哔哩弹幕视频网</li>
<li>优酷-中国领先视频网站</li>
<li>土豆-每个人都是生活的导演</li>
<li>爱奇艺-中国领先的视频门户</li>
<li>搜狐视频</li>
<li>芒果tv</li>
<li>熊猫tv</li>
<li>音悦台</li>
<li>百度网盘</li>
<li>秒拍视频</li>
</ul>
<h3 id="9-Octotree"><a href="#9-Octotree" class="headerlink" title="9. Octotree"></a>9. Octotree</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fj52q7l4azj31e00u0adb.jpg" alt=""></p>
<blockquote>
<p>Browser extension (Chrome, Firefox, Opera and Safari) to show a code tree on GitHub. Awesome for exploring project source without having to pull every single repository to your machine. </p>
</blockquote>
<p><strong>主页：</strong><a href="https://github.com/buunguyen/octotree" target="_blank" rel="noopener">https://github.com/buunguyen/octotree</a></p>
<p><strong>说明：</strong>一定是程序猿的最爱了，它能够树形的方式显示 GitHub 项目的目录结构，让你在浏览Github代码的时候，体验到IDE式的快感。</p>
<h3 id="10-Vimari"><a href="#10-Vimari" class="headerlink" title="10. Vimari"></a>10. Vimari</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fj52yv8yroj31kw0smwi9.jpg" alt=""></p>
<blockquote>
<p>Vimari is a Safari extension that provides keyboard based navigation. The code is heavily based on &#8216;vimium&#8217;, a chrome extension that provides much more extensive features. </p>
</blockquote>
<p><strong>主页：</strong><a href="https://github.com/guyht/vimari" target="_blank" rel="noopener">https://github.com/guyht/vimari</a></p>
<p><strong>说明：</strong>safari快捷键神器，让你可以像使用vim一样用快捷键操作Safari，体验飞一般的快感。</p>
<blockquote>
<p>附上Vimium的快捷键，有一些是vimari没有的，还有一些不一样的，可以自己设置，怎么舒服怎么来。</p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fj53c5q34qj30v40mmjta.jpg" alt=""> </p>
<h3 id="11-Evernote-Web-Clipper"><a href="#11-Evernote-Web-Clipper" class="headerlink" title="11. Evernote Web Clipper"></a>11. Evernote Web Clipper</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fj53ff2mvaj31kw0mhgnx.jpg" alt=""></p>
<blockquote>
<p>像剪报纸一样，「剪藏」你最爱的网页 </p>
</blockquote>
<p><strong>主页：</strong><a href="https://evernote.com/intl/zh-cn/products/webclipper/" target="_blank" rel="noopener">https://evernote.com/intl/zh-cn/products/webclipper/</a></p>
<p><strong>说明：</strong>一键保存网页，轻松圈出重点，自动识别网页正文，智能去广告，轻松收藏给予你灵感的一切网页。</p>
<blockquote>
<h5 id="以上排名不分先后，如果你还有更神奇的Safari插件，请留言分享！"><a href="#以上排名不分先后，如果你还有更神奇的Safari插件，请留言分享！" class="headerlink" title="以上排名不分先后，如果你还有更神奇的Safari插件，请留言分享！"></a>以上排名不分先后，如果你还有更神奇的Safari插件，请留言分享！</h5></blockquote>
]]></content>
      <categories>
        <category>玩转Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Safari</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中的定时任务利器：launchctl</title>
    <url>/mac_launchctl/</url>
    <content><![CDATA[<blockquote>
<p>launchctl是一个统一的服务管理框架，可以启动、停止和管理守护进程、应用程序、进程和脚本等。</p>
</blockquote>
<blockquote>
<p>launchctl是通过配置文件来指定执行周期和任务的。 </p>
</blockquote>
<p>当然mac也可以像linux系统一样，使用crontab命令来添加定时任务，这里就不赘述，具体可参见：<a href="http://codingpub.github.io/2016/10/27/OS-X-添加定时任务/" target="_blank" rel="noopener">OS X 添加定时任务</a></p>
<p>下面将手把手教你在mac上创建定时任务。（任务目标：每天晚上十点定时执行/Users/demo/helloworld.py的python程序）</p>
<h3 id="1-创建run-sh脚本"><a href="#1-创建run-sh脚本" class="headerlink" title="1. 创建run.sh脚本"></a>1. 创建run.sh脚本</h3><p>进入 <code>helloworld.py</code>程序所在目录</p>
<p><code>cd /User/demo</code></p>
<p>创建run.sh脚本</p>
<p><code>vi run.sh</code></p>
<p>添加执行<code>helloworld.py</code>的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"># 记录一下开始时间</span><br><span class="line">echo &#96;date&#96; &gt;&gt; &#x2F;Users&#x2F;demo&#x2F;log &amp;&amp;</span><br><span class="line"># 进入helloworld.py程序所在目录</span><br><span class="line">cd &#x2F;Users&#x2F;demo &amp;&amp;</span><br><span class="line"># 执行python脚本（注意前面要指定python运行环境&#x2F;usr&#x2F;bin&#x2F;python，根据自己的情况改变）</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;python helloworld.py</span><br><span class="line"># 运行完成</span><br><span class="line">echo &#39;finish&#39; &gt;&gt; &#x2F;Users&#x2F;demo&#x2F;log</span><br></pre></td></tr></table></figure>

<p><code>：wq</code>保存退出</p>
<p>注意，脚本要改成可执行的权限</p>
<p><code>chmod 777 run.sh</code></p>
<h3 id="2-编写plist文件"><a href="#2-编写plist文件" class="headerlink" title="2. 编写plist文件"></a>2. 编写plist文件</h3><p>launchctl 将根据plist文件的信息来启动任务。</p>
<p>plist脚本一般存放在以下目录：</p>
<ul>
<li><code>/Library/LaunchDaemons</code> &#8211;&gt;只要系统启动了，哪怕用户不登陆系统也会被执行</p> </li>
<li><code>/Library/LaunchAgents</code> &#8211;&gt;当用户登陆系统后才会被执行</li>
</ul>
<p>更多的plist存放目录：</p>
<blockquote>
<p>~/Library/LaunchAgents 由用户自己定义的任务项</p>
</blockquote>
<blockquote>
<p>/Library/LaunchAgents 由管理员为用户定义的任务项</p>
</blockquote>
<blockquote>
<p>/Library/LaunchDaemons 由管理员定义的守护进程任务项</p>
</blockquote>
<blockquote>
<p>/System/Library/LaunchAgents 由Mac OS X为用户定义的任务项</p>
</blockquote>
<blockquote>
<p>/System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项 </p>
</blockquote>
<p>进入<code>~/Library/LaunchAgents</code>，创建一个plist文件<code>com.demo.plist</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">  &lt;!-- Label唯一的标识 --&gt;</span><br><span class="line">  &lt;key&gt;Label&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;string&gt;com.demo.plist&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;!-- 指定要运行的脚本 --&gt;</span><br><span class="line">  &lt;key&gt;ProgramArguments&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;array&gt;</span><br><span class="line">    &lt;string&gt;&#x2F;Users&#x2F;demo&#x2F;run.sh&lt;&#x2F;string&gt;</span><br><span class="line">  &lt;&#x2F;array&gt;</span><br><span class="line">  &lt;!-- 指定要运行的时间 --&gt;</span><br><span class="line">  &lt;key&gt;StartCalendarInterval&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;Minute&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;integer&gt;00&lt;&#x2F;integer&gt;</span><br><span class="line">        &lt;key&gt;Hour&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;integer&gt;22&lt;&#x2F;integer&gt;</span><br><span class="line">  &lt;&#x2F;dict&gt;</span><br><span class="line">&lt;!-- 标准输出文件 --&gt;</span><br><span class="line">&lt;key&gt;StandardOutPath&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;&#x2F;Users&#x2F;demo&#x2F;run.log&lt;&#x2F;string&gt;</span><br><span class="line">&lt;!-- 标准错误输出文件，错误日志 --&gt;</span><br><span class="line">&lt;key&gt;StandardErrorPath&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;&#x2F;Users&#x2F;demo&#x2F;run.err&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-加载命令"><a href="#3-加载命令" class="headerlink" title="3. 加载命令"></a>3. 加载命令</h3><p><code>launchctl load -w com.demo.plist</code></p>
<p>这样任务就加载成功了。</p>
<p>更多的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 加载任务, -w选项会将plist文件中无效的key覆盖掉，建议加上</span><br><span class="line">$ launchctl load -w com.demo.plist</span><br><span class="line"></span><br><span class="line"># 删除任务</span><br><span class="line">$ launchctl unload -w com.demo.plist</span><br><span class="line"></span><br><span class="line"># 查看任务列表, 使用 grep &#39;任务部分名字&#39; 过滤</span><br><span class="line">$ launchctl list | grep &#39;com.demo&#39;</span><br><span class="line"></span><br><span class="line"># 开始任务</span><br><span class="line">$ launchctl start  com.demo.plist</span><br><span class="line"></span><br><span class="line"># 结束任务</span><br><span class="line">$ launchctl stop   com.demo.plist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果任务呗修改了，那么必须先unload，然后重新load</p>
</blockquote>
<blockquote>
<p>start可以测试任务，这个是立即执行，不管时间到了没有</p>
</blockquote>
<blockquote>
<p>执行start和unload前，任务必须先load过，否则报错</p>
</blockquote>
<blockquote>
<p>stop可以停止任务 </p>
</blockquote>
<h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><h5 id="plist支持两种方式配置执行时间："><a href="#plist支持两种方式配置执行时间：" class="headerlink" title="plist支持两种方式配置执行时间："></a>plist支持两种方式配置执行时间：</h5><ul>
<li>StartInterval: 指定脚本每间隔多长时间（单位：秒）执行一次；</li>
<li>StartCalendarInterval: 可以指定脚本在多少分钟、小时、天、星期几、月时间上执行，类似如crontab的中的设置，包含下面的 key:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Minute &lt;integer&gt;</span><br><span class="line">The minute on which this job will be run.</span><br><span class="line">Hour &lt;integer&gt;</span><br><span class="line">The hour on which this job will be run.</span><br><span class="line">Day &lt;integer&gt;</span><br><span class="line">The day on which this job will be run.</span><br><span class="line">Weekday &lt;integer&gt;</span><br><span class="line">The weekday on which this job will be run (0 and 7 are Sunday).</span><br><span class="line">Month &lt;integer&gt;</span><br><span class="line">The month on which this job will be run.</span><br></pre></td></tr></table></figure>

<h5 id="plist部分参数说明："><a href="#plist部分参数说明：" class="headerlink" title="plist部分参数说明："></a>plist部分参数说明：</h5><ol>
<li><p>Label：对应的需要保证全局唯一性；</p>
</li>
<li><p>Program：要运行的程序；</p>
</li>
<li><p>ProgramArguments：命令语句</p>
</li>
<li><p>StartCalendarInterval：运行的时间，单个时间点使用dict，多个时间点使用 array <dict></p>
</li>
<li><p>StartInterval：时间间隔，与StartCalendarInterval使用其一，单位为秒</p>
</li>
<li><p>StandardInPath、StandardOutPath、StandardErrorPath：标准的输入输出错误文件，这里建议不要使用 .log 作为后缀，会打不开里面的信息。</p>
</li>
<li><p>定时启动任务时，如果涉及到网络，但是电脑处于睡眠状态，是执行不了的，这个时候，可以定时的启动屏幕就好了。</p>
<blockquote>
<p>更多的参数参见:<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html" target="_blank" rel="noopener">mac官方文档</a></p>
</blockquote>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://blog.csdn.net/u012390519/article/details/74542042" target="_blank" rel="noopener">Mac执行定时任务之Launchctl</a></p>
]]></content>
      <categories>
        <category>玩转Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>mac OS 安装XGBoost</title>
    <url>/macos_xgboost/</url>
    <content><![CDATA[<p><strong>XGBoost</strong>是一种基于决策树（CART）的分布式的高效的梯度提升算法，它可被应用到分类、回归、排序等任务中，与一般的GBDT算法相比，XGBoost主要有以下几个优点：</p>
<ul>
<li>对叶节点的权重进行了惩罚，相当于添加了正则项，防止过拟合</li>
<li>XGBoost的目标函数优化利用了损失函数关于待求函数的二阶导数，而GBDT只利用了一阶信息</li>
<li>XGBoost支持列采样，类似于随机森林，构建每棵树时对属性进行采样，训练速度快，效果好</li>
<li>类似于学习率，学习到一棵树后，对其权重进行缩减，从而降低该棵树的作用，提升可学习空间</li>
<li>构建树的算法包括精确的算法和近似的算法，近似的算法对每维特征加权分位进行分桶，具体的算法利用到了损失函数关于待求树的二阶导数。</li>
<li>添加了对于稀疏数据的支持，当数据的某个特征缺失时，将该数据划分到默认的子节点，本文提出了一个算法来求解这个默认方向。</li>
<li>可并行的近似直方图算法，分裂节点时，数据在block中按列存放，而且已经经过了预排序，因此可以并行计算，即同时对各个属性遍历最优分裂点</li>
</ul>
<p>那么如何在mac下安装xgboost呢</p>
<h5 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h5><blockquote>
<p>macOS Sierra 版本 10.12.3 </p>
</blockquote>
<p>有两种方法：</p>
<h3 id="1-pip安装"><a href="#1-pip安装" class="headerlink" title="1. pip安装"></a>1. pip安装</h3><ul>
<li>第一步：安装HomeBrew</li>
</ul>
<p>HomeBrew是mac系统的包管理软件，类似于ubuntu的<code>apt-get</code>或者centos的<code>yum</code>，安装方法如下，在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：安装livm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install llvm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>llvm是Mac下的一个编译器,可以用来编译C和C++程序.最新的llvm已经包含了OpenMP.</p>
</blockquote>
<blockquote>
<p>注意, Mac下的XCode带有clang编译器, 但是是不支持OpenMP的,所以不能用来编译XGBoost. </p>
</blockquote>
<ul>
<li>第三步：安装clang-omp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install clang-omp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有人提到clang-omp已经从HomeBrew移除了, 如果找不到clang-omp可以尝试<code>brew install --with-clang llvm</code> </p>
</blockquote>
<ul>
<li>第四步, 用pip安装XGBoost</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xgboost</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
<h3 id="2-从Github库下载最新版XGBoost安装"><a href="#2-从Github库下载最新版XGBoost安装" class="headerlink" title="2. 从Github库下载最新版XGBoost安装"></a>2. 从Github库下载最新版XGBoost安装</h3><ul>
<li>第一步：克隆最新的XGBoost到本地</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;dmlc&#x2F;xgboost</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：安装gcc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install gcc5 --without-multilib</span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：修改XGBoost的config文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd xgboost</span><br><span class="line">cp make&#x2F;config.mk .&#x2F;config.mk</span><br></pre></td></tr></table></figure>

<p>很多攻略都是直接将以下这两行</p>
<p>&#8220;`</p>
<p># export CC = gcc</p>
<p># export CXX = g++</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">改为：         </span><br></pre></td></tr></table></figure>

<p>export CC = gcc-5</p>
<p>export CXX = g++-5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">但是我直接这样做却一直报错，无法编译通过。搞了半天才发现系统找不到gcc,原来是macOS已经不自带gcc环境了，通过Homebrew安装系统也识别不到。</span><br><span class="line">正常情况下是可以通过port来查看系统里安装的gcc的：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装gcc_select</p>
<p>/opt/local/bin/port install gcc_select</p>
<p>查看gcc列表</p>
<p>port select &#8211;list gcc</p>
<p>还可以选择gcc的版本</p>
<p>sudo port select &#8211;set gcc mp-gcc5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">但是很不幸，我执行&#96;port select --list gcc&#96;得到的结果是</span><br><span class="line">&gt; Available versions for gcc:</span><br><span class="line">    none (active)</span><br><span class="line"></span><br><span class="line">但是明明Homebrew安装成功了啊，于是到Homebrew的安装目录下瞧一瞧：&#96;cd &#x2F;usr&#x2F;local&#x2F;bin&#96;，发现里面静静躺着&#96;gcc5&#96;,&#96;gcc7&#96;，系统就是无法识别这里的gcc。。。搜了半天没找到解决方案，最后，机智的我直接把&#96;config.mk&#96;修改成：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>export CC = /usr/local/bin/gcc-5</p>
<p>export CXX = /usr/local/bin/g++-5</p>
<p>export MPICXX = /usr/local/bin/mpicxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就是带上具体的路径，然后保存</span><br><span class="line"></span><br><span class="line">- 第四步：开始编译</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make clean_all &amp;&amp; make -j4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br &#x2F;&gt;- 第五步：安装python包</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cd python-package</p>
<p>python setup.py install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">至些XGBoost终于安装成功！</span><br><span class="line">在python环境中测试一下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import xgboost</p>
<p>xgboost.<strong>version</strong></p>
<p>&#8220;`</p>
<blockquote>
<p>输出&#8217;0.6&#8242; </p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/23996104" target="_blank" rel="noopener">Mac OSX 下安装XGBoost</a></p>
]]></content>
      <categories>
        <category>玩转Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Xgboost</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转jupyter</title>
    <url>/jupyter/</url>
    <content><![CDATA[<p>Jupyter Notebook是一个开源的Web应用程序，可以让您创建和实时共享代码、方程式、可视化和说明文本等文档。主要用于：数据清理与转换，数值模拟，统计建模，机器学习等。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><blockquote>
<p>准备环境：Python</p>
</blockquote>
<blockquote>
<p>尽管Jupyter上可以跑很多的代码，但安装它必须依赖Python(2.7或者3.3及以上) </p>
</blockquote>
<p>两种安装方法：</p>
<ol>
<li><p>安装Anaconda and conda</p>
</li>
<li><p>pip安装</p>
</li>
</ol>
<h4 id="1-1-用Anaconda和conda安装"><a href="#1-1-用Anaconda和conda安装" class="headerlink" title="1.1 用Anaconda和conda安装"></a>1.1 用Anaconda和conda安装</h4><p>对于新手，推荐安装Anaconda。Anaconda非常方便，它高度集成了Python, Jupyter notebook和其他常用于计算数据科学的包，简单易用。</p>
<p>安装步骤：</p>
<ul>
<li>下载Anaconda（推荐Python 3.5版本）</li>
<li>安装Anaconda</li>
<li>恭喜你安装Jupyter Notebook成功。</li>
<li>输入<code>jupyter notebook</code>即可运行</li>
</ul>
<h4 id="1-2-pip安装"><a href="#1-2-pip安装" class="headerlink" title="1.2 pip安装"></a>1.2 pip安装</h4><p>对于一个用经验的python高手，你可能更希望通过python的包管理器——pip来安装Jupyter,而非Anaconda。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(如果是python 3 版本，则使用pip3代替pip) </p>
</blockquote>
<h3 id="2-开启远程访问"><a href="#2-开启远程访问" class="headerlink" title="2. 开启远程访问"></a>2. 开启远程访问</h3><p>安装好jupyter以后直接输入jupyter notebook便可以在浏览器中使用。但是它默认只能在本地访问，如果想把它安装在服务器上，然后在本地远程访问，则需要进行如下配置：</p>
<h4 id="2-1-生成配置文件"><a href="#2-1-生成配置文件" class="headerlink" title="2.1 生成配置文件"></a>2.1 生成配置文件</h4><p>在你的服务器上，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<h4 id="2-2-生成密码"><a href="#2-2-生成密码" class="headerlink" title="2.2 生成密码"></a>2.2 生成密码</h4><p>打开python，创建一个密文的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from notebook.auth import passwd</span><br><span class="line">&gt;&gt;&gt; passwd()</span><br><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line">&#39;sha1:ce23d945972f:34769685a7ccd3d08c84a18c63968a41f1140274&#39;</span><br></pre></td></tr></table></figure>

<p>复制sha1的密码串</p>
<h4 id="2-3-修改默认配置文件"><a href="#2-3-修改默认配置文件" class="headerlink" title="2.3 修改默认配置文件"></a>2.3 修改默认配置文件</h4><p><code>$vim ~/.jupyter/jupyter_notebook_config.py</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip&#x3D;&#39;*&#39;</span><br><span class="line">c.NotebookApp.password &#x3D; u&#39;sha1:ce...刚才复制的那个密码串&#39;</span><br><span class="line">c.NotebookApp.open_browser &#x3D; False</span><br><span class="line">c.NotebookApp.port &#x3D;8888 #随便指定一个端口</span><br></pre></td></tr></table></figure>

<h4 id="2-4-启动jupyter-notebook"><a href="#2-4-启动jupyter-notebook" class="headerlink" title="2.4 启动jupyter notebook"></a>2.4 启动jupyter notebook</h4><p><code>jupyter notebook</code></p>
<h4 id="2-5-远程访问"><a href="#2-5-远程访问" class="headerlink" title="2.5 远程访问"></a>2.5 远程访问</h4><p>此时你应该可以在本地浏览器访问你服务器上的jupyter了。</p>
<p><code>http://address_of_remote:8888</code>（addredd_of_remote即你服务器的ip,可以是局域网的ip如：192.168.1.63，也可以是公网ip，如：112.32.5.12）</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 安装java1.7和tomcat7并部署应用</title>
    <url>/centos7_java_tomcat/</url>
    <content><![CDATA[<h3 id="安装-Java1-7"><a href="#安装-Java1-7" class="headerlink" title="安装 Java1. 7"></a>安装 Java1. 7</h3><h5 id="登录服务器查看JDK软件包的列表"><a href="#登录服务器查看JDK软件包的列表" class="headerlink" title="登录服务器查看JDK软件包的列表"></a>登录服务器查看JDK软件包的列表</h5><p><code>yum search java | grep -i --color JDK</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldapjdk-javadoc.noarch : Javadoc for ldapjdk </span><br><span class="line">icedtea-web.x86_64 : Additional Java components for OpenJDK - Java browser </span><br><span class="line">java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment </span><br><span class="line">java-1.6.0-openjdk-demo.x86_64 : OpenJDK Demos java-1.6.0-openjdk-devel.x86_64 : OpenJDK Development Environment </span><br><span class="line">java-1.6.0-openjdk-javadoc.x86_64 : OpenJDK API Documentation </span><br><span class="line">java-1.6.0-openjdk-src.x86_64 : OpenJDK Source Bundle </span><br><span class="line">java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment </span><br><span class="line">java-1.7.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector </span><br><span class="line">java-1.7.0-openjdk-demo.x86_64 : OpenJDK Demos </span><br><span class="line">java-1.7.0-openjdk-devel.x86_64 : OpenJDK Development Environment </span><br><span class="line">java-1.7.0-openjdk-headless.x86_64 : The OpenJDK runtime environment without </span><br><span class="line">java-1.7.0-openjdk-javadoc.noarch : OpenJDK API Documentation </span><br><span class="line">java-1.7.0-openjdk-src.x86_64 : OpenJDK Source Bundle </span><br><span class="line">java-1.8.0-openjdk.i686 : OpenJDK Runtime Environment </span><br><span class="line">java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment </span><br><span class="line">java-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector </span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK accessibility connector </span><br><span class="line">java-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment with full debug on </span><br><span class="line">java-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment with full debug on </span><br><span class="line">java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos </span><br><span class="line">java-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos with full debug on </span><br><span class="line">java-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment </span><br><span class="line">java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment </span><br><span class="line">java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment with full </span><br><span class="line">java-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment with </span><br><span class="line">java-1.8.0-openjdk-headless.i686 : OpenJDK Runtime Environment </span><br><span class="line">java-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environment </span><br><span class="line">java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with full </span><br><span class="line">java-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full </span><br><span class="line">java-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentation </span><br><span class="line">java-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK API Documentation for packages </span><br><span class="line">java-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK API Documentation compressed in </span><br><span class="line">java-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK API Documentation </span><br><span class="line">java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle </span><br><span class="line">java-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle for packages with </span><br><span class="line">ldapjdk.noarch : The Mozilla LDAP Java SDK </span><br><span class="line">openprops.noarch : An improved java.util.Properties from OpenJDK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="选择自己需要的版本进行安装"><a href="#选择自己需要的版本进行安装" class="headerlink" title="选择自己需要的版本进行安装"></a>选择自己需要的版本进行安装</h5><p><code>yum install java-1.7.0-openjdk-devel.x86_64</code></p>
<h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p><code>[root@localhost ~]# vi /etc/profile</code></p>
<p>在profile文件中添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java environment </span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0-openjdk-1.7.0.75.x86_64（java的安装路径）</span><br><span class="line">JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre </span><br><span class="line">CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib </span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin </span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH </span><br></pre></td></tr></table></figure>

<h5 id="验证及查看版本"><a href="#验证及查看版本" class="headerlink" title="验证及查看版本"></a>验证及查看版本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">echo $JAVA_HOME</span><br><span class="line">echo $JRE_HOME</span><br><span class="line">echo $CLASSPATH</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<h3 id="安装Tomcat7"><a href="#安装Tomcat7" class="headerlink" title="安装Tomcat7"></a>安装Tomcat7</h3><h5 id="下载tomcat7的安装文件"><a href="#下载tomcat7的安装文件" class="headerlink" title="下载tomcat7的安装文件"></a>下载tomcat7的安装文件</h5><p><code>wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-7/v7.0.69/bin/apache-tomcat-7.0.69.tar.gz</code></p>
<p>解压并移到<code>/usr/local</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-7.0.57.tar.gz</span><br><span class="line">mv apache-tomcat-7.0.69&#x2F; &#x2F;usr&#x2F;local&#x2F;tomcat</span><br></pre></td></tr></table></figure>

<h5 id="配置tomcat环境变量和内存设置"><a href="#配置tomcat环境变量和内存设置" class="headerlink" title="配置tomcat环境变量和内存设置"></a>配置tomcat环境变量和内存设置</h5><p>在tomcat的bin目录下打开catalina.sh文件，<code>vi /usr/local/tomcat/bin/catalina.sh</code>，添加以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;&quot;-Xms512m -Xmx1024m -Xss1024K -XX:PermSize&#x3D;512m -XX:MaxPermSize&#x3D;1024m&quot;</span><br><span class="line">export TOMCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0-openjdk-1.7.0.141-2.6.10.1.el7_3.x86_64</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0-openjdk-1.7.0.141-2.6.10.1.el7_3.x86_64&#x2F;jre</span><br></pre></td></tr></table></figure>

<p>##### 启动、关闭Tomcat</p>
<p>启动<code>/usr/local/tomcat/bin/startup.sh</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Using CATALINA_BASE:   &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">Using CATALINA_HOME:   &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">Using CATALINA_TMPDIR: &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;temp</span><br><span class="line">Using JRE_HOME:        &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0-openjdk-1.7.0.141-2.6.10.1.el7_3.x86_64&#x2F;jre</span><br><span class="line">Using CLASSPATH:       &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;bootstrap.jar:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure>

<p>关闭<code>/usr/local/tomcat/bin/shutdown.sh</code></p>
<h3 id="手动部署web应用"><a href="#手动部署web应用" class="headerlink" title="手动部署web应用"></a>手动部署web应用</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>在conf目录的server.xml中的，找到<host>节点，添加如下标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;hello&quot; docBase&#x3D;&quot;&#x2F;root&#x2F;helloworld&quot; debug&#x3D;&quot;0&quot; privileged&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;&#x2F;Context&gt;</span><br></pre></td></tr></table></figure>

<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>在<code>conf/Catalina/localhost</code>目录下创建xml配置文件，文件容易如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context path&#x3D;&quot;&#x2F;hello&quot; docBase&#x3D;&quot;&#x2F;root&#x2F;helloworld&quot; debug&#x3D;&quot;0&quot; privileged&#x3D;&quot;true&quot;&gt;</span><br><span class="line">&lt;&#x2F;Context&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此法有个优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名。这个方法很方便的隐藏了项目的名称，对一些项目名称被固定不能更换，但外部访问时又想换个路径，非常有效。 </p>
</blockquote>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol>
<li><a href="http://www.imooc.com/article/16609" target="_blank" rel="noopener">Linux——CentOS7使用yum命令安装Java SDK</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>centos</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7密码策略及修改技巧</title>
    <url>/mysql5_7password/</url>
    <content><![CDATA[<p>mysql升级5.7版本以后，安全性大幅度上升。</p>
<p>MySQL5.7为root用户随机生成了一个密码，打印在error_log中，关于error_log的位置，如果安装的是RPM包，则默认是 /var/log/mysqld.log 。</p>
<p>于是我们可以在<code>mysqld.log</code>中找到初始密码串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fio4wcirdej310e09oacd.jpg" alt=""></p>
<p>用初始密码串登陆即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p&#39;s;*QJ6&#x2F;gX1et&#39;</span><br></pre></td></tr></table></figure>

<p>但是你会登陆之后会发现很多功能都不能用，只有修改密码才能进行正常操作：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fio4zizr71j314203gdg9.jpg" alt=""></p>
<p>于是我们修改密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD &#x3D; PASSWORD(&#39;123456&#39;); </span><br><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br><span class="line">mysql&gt; SET PASSWORD &#x3D; PASSWORD(&quot;root&quot;);</span><br><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<p>却又坑爹地说密码不满足策略要求。。。</p>
<p>那我们先看看数据库当前的密码策略是啥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt; show VARIABLES like &quot;%password%&quot;</span><br><span class="line">+---------------------------------------+---------+</span><br><span class="line">| Variable_name                         | Value   |</span><br><span class="line">|---------------------------------------+---------|</span><br><span class="line">| default_password_lifetime             | 0       |</span><br><span class="line">| disconnect_on_expired_password        | ON      |</span><br><span class="line">| log_builtin_as_identified_by_password | OFF     |</span><br><span class="line">| mysql_native_password_proxy_users     | OFF     |</span><br><span class="line">| old_passwords                         | 0       |</span><br><span class="line">| report_password                       |         |</span><br><span class="line">| sha256_password_proxy_users           | OFF     |</span><br><span class="line">| validate_password_dictionary_file     |         |</span><br><span class="line">| validate_password_length              | 8       |</span><br><span class="line">| validate_password_mixed_case_count    | 1       |</span><br><span class="line">| validate_password_number_count        | 1       |</span><br><span class="line">| validate_password_policy              | MEDIUM  |</span><br><span class="line">| validate_password_special_char_count  | 1       |</span><br><span class="line">+---------------------------------------+---------+</span><br></pre></td></tr></table></figure>

<p>根据官方文档可以发现策略为1，即MEDIUM</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fio55dh48kj30sw08274p.jpg" alt=""></p>
<blockquote>
<p>所以你更改密码必须满足：数字、小写字母、大写字母 、特殊字符、长度至少8位 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;</span><br><span class="line">或者</span><br><span class="line">SET password&#x3D;&#39;new_password&#39;;</span><br></pre></td></tr></table></figure>

<p>如此你便成功修改了密码，最后你还要设置一下过期时间，以防止密码失效。</p>
<p>在<code>/etc/my.cnf</code>配置文件中增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime&#x3D;0</span><br></pre></td></tr></table></figure>

<p>或者直接通过命令设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;script&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER</span><br></pre></td></tr></table></figure>

<p>以上便可以开心的mysql的世界里遨游了～～～</p>
<h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><p>但是有时候为了图方便，数据的安全性要求也不是很高的情况下，我们通常更希望设置一个简单的密码，比如<code>123456</code>&#8230;</p>
<h5 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h5><p>在<code>/etc/my.cnf</code>配置文件中增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">validate_password&#x3D;off</span><br></pre></td></tr></table></figure>

<p>然后<code>service mysqld restart</code>或者<code>systemctl restart mysqld.service</code>重启mysqld，通过SHOW PLUGINS;即可看到密码验证的插件被停止了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------+----------+-------------------+----------------------+-----+</span><br><span class="line">| validate_password | DISABLED | VALIDATE PASSWORD | validate_password.so | GPL |</span><br><span class="line">+-------------------+----------+-------------------+----------------------+-----+</span><br></pre></td></tr></table></figure>

<h5 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h5><blockquote>
<p>更改密码策略为LOW </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy&#x3D;0;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更改密码长度 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_length&#x3D;0;</span><br></pre></td></tr></table></figure>

<p>如此即可随意设置密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string&#x3D;password(&#39;123456&#39;) where user&#x3D;&#39;root&#39; and Host &#x3D; &#39;localhost&#39;;</span><br><span class="line">或者</span><br><span class="line">set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;123456&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="当然，我们还有一种办法，就是在最最开始的时候，不设置初始密码："><a href="#当然，我们还有一种办法，就是在最最开始的时候，不设置初始密码：" class="headerlink" title="当然，我们还有一种办法，就是在最最开始的时候，不设置初始密码："></a>当然，我们还有一种办法，就是在最最开始的时候，不设置初始密码：</h5><p>只需要在初始化时指定<code>--initialize-insecure</code>即可，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql --basedir&#x3D;&#x2F;usr --user&#x3D;mysql</span><br></pre></td></tr></table></figure>

<p>此时，SHOW VARIABLES LIKE &#8216;vali%&#8217;;也会为空，因为该插件没有被安装。</p>
<blockquote>
<p>【参考】</p>
</blockquote>
<blockquote>
<p><a href="http://blog.itpub.net/29773961/viewspace-2077579/" target="_blank" rel="noopener">MySQL 5.7 初始密码和密码复杂度问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你在centos7中安装mysql数据库</title>
    <url>/centos7_install_mysql/</url>
    <content><![CDATA[<h3 id="一、系统环境"><a href="#一、系统环境" class="headerlink" title="一、系统环境"></a>一、系统环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.3.1611 (Core)</span><br></pre></td></tr></table></figure>

<p>CentOS 7 版本将MySQL数据库软件从默认的程序列表中移除，用mariadb代替了。</p>
<p>所以要安装mysql有两种方法，一种是直接安装mariadb，另一种是从官网下载mysql手动安装</p>
<p>这里只介绍第二种方法。</p>
<h3 id="二、官网下载安装mysql-server"><a href="#二、官网下载安装mysql-server" class="headerlink" title="二、官网下载安装mysql-server"></a>二、官网下载安装mysql-server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh mysql-community-release-el7-5.noarch.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install mysql-community-server</span></span><br></pre></td></tr></table></figure>

<p>安装成功后重启mysql服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service mysqld restart</span><br></pre></td></tr></table></figure>

<p>初次安装mysql，root账户没有密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql -u root</span></span><br></pre></td></tr></table></figure>

<p>设置密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39; &#x3D;password(&#39;password&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="三、配置mysql"><a href="#三、配置mysql" class="headerlink" title="三、配置mysql"></a>三、配置mysql</h3><ol>
<li><p>编码</p>
<p>mysql配置文件为<code>/etc/my.cnf</code></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set =utf8</span><br></pre></td></tr></table></figure>

<ol start="2">
  <li>
    远程连接
  </li>
</ol>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;;  </span><br><span class="line">grant all privileges on *.* to root@&#39;%&#39;identified by &#39;password&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux私房菜</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用自己的语料训练word2vec模型</title>
    <url>/train_word2vec_model/</url>
    <content><![CDATA[<h1 id="使用自己的语料训练word2vec模型"><a href="#使用自己的语料训练word2vec模型" class="headerlink" title="使用自己的语料训练word2vec模型"></a>使用自己的语料训练word2vec模型</h1><h5 id="一、-准备环境和语料："><a href="#一、-准备环境和语料：" class="headerlink" title="一、 准备环境和语料："></a>一、 准备环境和语料：</h5><ul>
<li><p>新闻20w+篇（格式：<code>标题</code>。<code>正文</code>）</p>
<blockquote>
<p>【新闻可以自己从各大新闻网站爬取，也可以下载开源的新闻数据集，如</p>
<ul>
<li><a href="http://www.sogou.com/labs/resource/t.php" target="_blank" rel="noopener">互联网语料库(SogouT)</a></li>
<li><a href="http://thuctc.thunlp.org/" target="_blank" rel="noopener">中文文本分类数据集THUCNews</a></li>
<li><a href="http://www.datatang.com/data/11968" target="_blank" rel="noopener">李荣陆英文文本分类语料</a></li>
<li><a href="http://www.datatang.com/data/11970" target="_blank" rel="noopener">谭松波中文文本分类语料</a></li>
<li>等</li>
</ul>
</blockquote>
</li>
<li><p><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴分词</a></p> </p>
</li>
<li><p><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="noopener">word2vec</a></p>
</li>
</ul>
<h5 id="二、分词"><a href="#二、分词" class="headerlink" title="二、分词"></a>二、分词</h5><p>先对新闻文本进行分词，使用的是结巴分词工具，将分词后的文本保存在<code>seg201708.txt</code>，以备后期使用。</p>
<blockquote>
<p>安装jieba工具包：pip install jieba </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="comment"># 加载自己的自己的金融词库</span></span><br><span class="line">jieba.load_userdict(<span class="string">"financialWords.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> io.open(<span class="string">'news201708.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> content:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">            seg_list = jieba.cut(line)</span><br><span class="line"><span class="comment">#           print '/'.join(seg_list)</span></span><br><span class="line">            <span class="keyword">with</span> io.open(<span class="string">'seg201708.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> output:</span><br><span class="line">                output.write(<span class="string">' '</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h5 id="三、训练word2vec模型"><a href="#三、训练word2vec模型" class="headerlink" title="三、训练word2vec模型"></a>三、训练word2vec模型</h5><p>使用python的gensim包进行训练。</p>
<blockquote>
<p>安装gemsim包：pip install gemsim </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> word2vec</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    num_features = <span class="number">300</span>    <span class="comment"># Word vector dimensionality</span></span><br><span class="line">    min_word_count = <span class="number">10</span>   <span class="comment"># Minimum word count</span></span><br><span class="line">    num_workers = <span class="number">16</span>       <span class="comment"># Number of threads to run in parallel</span></span><br><span class="line">    context = <span class="number">10</span>          <span class="comment"># Context window size</span></span><br><span class="line">    downsampling = <span class="number">1e-3</span>   <span class="comment"># Downsample setting for frequent words</span></span><br><span class="line">    sentences = word2vec.Text8Corpus(<span class="string">"seg201708.txt"</span>)</span><br><span class="line"></span><br><span class="line">    model = word2vec.Word2Vec(sentences, workers=num_workers, \</span><br><span class="line">            size=num_features, min_count = min_word_count, \</span><br><span class="line">            window = context, sg = <span class="number">1</span>, sample = downsampling)</span><br><span class="line">    model.init_sims(replace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 保存模型，供日後使用</span></span><br><span class="line">    model.save(<span class="string">"model201708"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以在加载模型之后使用另外的句子来进一步训练模型</span></span><br><span class="line">    <span class="comment"># model = gensim.models.Word2Vec.load('/tmp/mymodel')</span></span><br><span class="line">    <span class="comment"># model.train(more_sentences)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明</li>
</ul>
<blockquote>
<ul>
<li>sentences：可以是一个·ist，对于大语料集，建议使用BrownCorpus,Text8Corpus或ineSentence构建。</li>
<li>sg： 用于设置训练算法，默认为0，对应CBOW算法；sg=1则采用skip-gram算法。</li>
<li>size：是指特征向量的维度，默认为100。大的size需要更多的训练数据,但是效果会更好. 推荐值为几十到几百。</li>
<li>window：表示当前词与预测词在一个句子中的最大距离是多少</li>
<li>alpha: 是学习速率</li>
<li>seed：用于随机数发生器。与初始化词向量有关。</li>
<li>min_count: 可以对字典做截断. 词频少于min_count次数的单词会被丢弃掉, 默认值为5</li>
<li>max_vocab_size: 设置词向量构建期间的RAM限制。如果所有独立单词个数超过这个，则就消除掉其中最不频繁的一个。每一千万个单词需要大约1GB的RAM。设置成None则没有限制。</li>
<li>sample: 高频词汇的随机降采样的配置阈值，默认为1e-3，范围是(0,1e-5)</li>
<li>workers参数控制训练的并行数。</li>
<li>hs: 如果为1则会采用hierarchica·softmax技巧。如果设置为0（defau·t），则negative sampling会被使用。</li>
<li>negative: 如果&gt;0,则会采用negativesamp·ing，用于设置多少个noise words</li>
<li>cbow_mean: 如果为0，则采用上下文词向量的和，如果为1（defau·t）则采用均值。只有使用CBOW的时候才起作用。</li>
<li>hashfxn： hash函数来初始化权重。默认使用python的hash函数</li>
<li>iter： 迭代次数，默认为5</li>
<li>trim_rule： 用于设置词汇表的整理规则，指定那些单词要留下，哪些要被删除。可以设置为None（min_count会被使用）或者一个接受()并返回RU·E_DISCARD,uti·s.RU·E_KEEP或者uti·s.RU·E_DEFAU·T的</li>
<li>sorted_vocab： 如果为1（defau·t），则在分配word index 的时候会先对单词基于频率降序排序。</li>
<li>batch_words：每一批的传递给线程的单词的数量，默认为10000</li>
</ul>
</blockquote>
<h5 id="四、word2vec应用"><a href="#四、word2vec应用" class="headerlink" title="四、word2vec应用"></a>四、word2vec应用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Word2Vec.load(<span class="string">'model201708'</span>)      <span class="comment">#模型讀取方式</span></span><br><span class="line">model.most_similar(positive=[<span class="string">'woman'</span>, <span class="string">'king'</span>], negative=[<span class="string">'man'</span>]) <span class="comment">#根据给定的条件推断相似词</span></span><br><span class="line">model.doesnt_match(<span class="string">"breakfast cereal dinner lunch"</span>.split()) <span class="comment">#寻找离群词</span></span><br><span class="line">model.similarity(<span class="string">'woman'</span>, <span class="string">'man'</span>) <span class="comment">#计算两个单词的相似度</span></span><br><span class="line">model[<span class="string">'computer'</span>] <span class="comment">#获取单词的词向量</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>word2vector</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Merge Two Sorted Lists 合并两个排好序的链表</title>
    <url>/merge-two-sorted-lists/</url>
    <content><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fhx2hv987hj30sg0jqtb5.jpg" alt=""></p>
<p><strong>链接</strong>：<a href="https://leetcode.com/problems/merge-two-sorted-lists/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/#/description</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：21. Merge Two Sorted Lists</p>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>翻译</strong>：合并两个排好序的链列，并将其作为新链表返回。新链表应通过将前两个列表的节点拼接在一起。</p>
<p><strong>思路一</strong>：新建一个头指针指向0的临时链表，比较l1和l2的当前值的大小，把临时链表的next节点指向较小的节点，l1或者l2的指针后移一位，依次往下，直到l1或者l2为空，则把临时链表的next节点指向最后那段非空的链表，返回临时链表的第二个节点（头一个节点为0）。</p>
<p><strong>参考代码一（Java）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode newList = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode nextList = newList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &amp;lt; l2.val)&#123;</span><br><span class="line">                nextList.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextList.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            nextList = nextList.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextList.next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nextList.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newList.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>思路二</strong>：使用递归法。构造一个临时链表，当l1当前节点的值大于l2当前节点的值时，我们把l2这个较小的值赋给临时链表的下一个节点，并将l2的下一个节点的值和l1当前节点的值放到下一次做对比，依次递归下去。</p>
<p><strong>参考代码二（Java）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &amp;gt; l2.val) &#123;</span><br><span class="line">            ListNode tmp = l2;</span><br><span class="line">            tmp.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode tmp = l1;</span><br><span class="line">            tmp.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Valid Parentheses 验证括号是否有效闭合</title>
    <url>/valid-parentheses/</url>
    <content><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhvdo0qvujj30k009g0t0.jpg" alt=""></p>
<p><strong>链接</strong>：<a href="https://leetcode.com/problems/valid-parentheses/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/#/description</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：20. Valid Parentheses</p>
<p>Given a string containing just the characters &#8216;(&#8216;, &#8216;)&#8217;, &#8216;{&#8216;, &#8216;}&#8217;, &#8216;[&#8216; and &#8216;]&#8217;, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, &#8220;()&#8221; and &#8220;()[]{}&#8221; are all valid but &#8220;(]&#8221; and &#8220;([)]&#8221; are not.</p>
<p><strong>翻译</strong>：给定一个仅包含字符&#8217;（&#8217;，&#8217;）&#8217;，’{&#8216;，&#8217;}&#8217;，’[&#8216;和&#8217;]&#8217;的字符串，确定输入字符串是否有效。括号必须以正确的顺序关闭，“（）”和“（）[] {}”都是有效的，但“（]”和“（[）]”不是。</p>
<p><strong>思路</strong>：用数据结构——栈就可以实现。遍历字符串，把左括号压栈，碰到右括号就把栈的顶部元素拿出来与右括号匹配，匹配成功则顶部元素出栈，进入下一次循环，匹配不成功或者栈中无元素，则字符串不是有效闭合。直到所有元素遍历完，栈中无元素，即为有效闭合；如果所有元素遍历完了，栈中还有元素，则不是有效闭合。</p>
<p><strong>基础概念</strong></p>
<blockquote>
<p>在 Java 中 Stack 类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：</p>
</blockquote>
<blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhv5iprwkbj30jk07qjrf.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>Stack 通过五个操作对 Vector 进行扩展，允许将向量视为堆栈。这个五个操作如下：</p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhv5j929plj30dc0580ss.jpg" alt=""> </p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Create the Stack instance and add a couple of elements to it</span><br><span class="line">Stack stack &#x3D; new Stack();</span><br><span class="line">String s1 &#x3D; &quot;element 1&quot;;</span><br><span class="line">String s2 &#x3D; &quot;element 2&quot;;</span><br><span class="line">stack.push(s1);</span><br><span class="line">stack.push(s2);</span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line">&#x2F;&#x2F;element 2</span><br><span class="line">&#x2F;&#x2F;Find position of a certain element</span><br><span class="line">int pos &#x3D; stack.search(&quot;element 1&quot;);</span><br><span class="line">System.out.println(pos);</span><br><span class="line">&#x2F;&#x2F;2</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">&#x2F;&#x2F;element 2</span><br><span class="line">&#x2F;&#x2F;element 1</span><br><span class="line">System.out.println(stack.empty());</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<p><strong>参考代码</strong>：</p>
<p>Java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        if(s&#x3D;&#x3D;null || s.length()&#x3D;&#x3D;0)</span><br><span class="line">            return false;</span><br><span class="line">        Stack&lt;Character&gt; parentheses &#x3D; new Stack&lt;Character&gt;(); </span><br><span class="line">        for (int i &#x3D; 0; i&lt; s.length(); i++)&#123;</span><br><span class="line">            char c &#x3D; s.charAt(i); </span><br><span class="line">            if(c&#x3D;&#x3D;&#39;(&#39; || c&#x3D;&#x3D;&#39;[&#39; || c &#x3D;&#x3D;&#39;&#123;&#39;)</span><br><span class="line">                parentheses.push(c);</span><br><span class="line">            else&#123;</span><br><span class="line">                if (parentheses.empty())</span><br><span class="line">                    return false;</span><br><span class="line">                if (c &#x3D;&#x3D; &#39;)&#39; &amp;&amp; parentheses.peek() !&#x3D; &#39;(&#39;)</span><br><span class="line">                    return false;</span><br><span class="line">                if (c &#x3D;&#x3D; &#39;]&#39; &amp;&amp; parentheses.peek() !&#x3D;&#39;[&#39;)</span><br><span class="line">                    return false;</span><br><span class="line">                if (c &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; parentheses.peek() !&#x3D;&#39;&#123;&#39;)</span><br><span class="line">                    return false;</span><br><span class="line">                parentheses.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return parentheses.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考资料</strong></p>
<p><a href="http://outofmemory.cn/code-snippet/2087/java-usage-Stack-class" target="_blank" rel="noopener">http://outofmemory.cn/code-snippet/2087/java-usage-Stack-class</a></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］ Longest Common Prefix 最长公共前缀</title>
    <url>/longest-common-prefix/</url>
    <content><![CDATA[<p><img src="http://photocdn.sohu.com/20150422/mp11922313_1429685272340_2.jpeg" alt=""></p>
<p><strong>链接</strong>：<a href="https://leetcode.com/problems/longest-common-prefix/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/#/description</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：14. Longest Common Prefix</p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p><strong>翻译</strong>：编写一个函数来查找给定字符串数组中最长的公共前缀。</p>
<p><strong>思路</strong>：取出给定字符串数组中长度最小的一个字符串（或者直接取出第一个字符串），以此为基准，遍历整个字符串数组，若基准字符串是其他所有字符串的子串，则基准字符串即为所求最长公共前缀，否则，将基准字符串截去最后一个字符，重新遍历整个字符串数组，依此类推，直到找到所有字符串数组都存在的子串为止。</p>
<p><strong>参考代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&amp;lt;strs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(prefix) != <span class="number">0</span>)&#123;</span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Roman to Integer 罗马数字转化成整数</title>
    <url>/roman-to-integer/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/roman-to-integer/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/#/description</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：13. Roman to Integer</p>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>翻译</strong>：将给定的罗马数字转化为整数，输入保证在1～3999之间</p>
<p><strong>概念</strong>：什么是罗马数字？</p>
<blockquote>
<p>罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）。按照下述的规则可以表示任意正整数。需要注意的是罗马数字中没有“0”，与进位制无关。一般认为罗马数字只用来记数，而不作演算。</p>
</blockquote>
<blockquote>
<p>重复数次：一个罗马数字重复几次，就表示这个数的几倍。</p>
</blockquote>
<blockquote>
<p>右加左减：</p>
</blockquote>
<blockquote>
<p>在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。</p>
</blockquote>
<blockquote>
<p>在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。</p>
</blockquote>
<blockquote>
<p>左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV</p>
</blockquote>
<blockquote>
<p>但是，左减时不可跨越一个位值。比如，99不可以用IC（100-1）表示，而是用XCIX（ [100-10]+[10-1]）表示。（等同于阿拉伯数字每位数字分别表示。）</p>
</blockquote>
<blockquote>
<p>左减数字必须为一位，比如8写成VIII，而非IIX。</p>
</blockquote>
<blockquote>
<p>右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）</p>
</blockquote>
<blockquote>
<p>加线乘千：</p>
</blockquote>
<blockquote>
<p>在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍。</p>
</blockquote>
<blockquote>
<p>同理，如果上方有两条横线，即是原数的1000000（ 1000^2）倍。</p>
</blockquote>
<blockquote>
<p>数码限制：</p>
</blockquote>
<blockquote>
<p>同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL。</p>
</blockquote>
<blockquote>
<p>例外：由于IV是古罗马神话主神朱庇特（即IVPITER，古罗马字母里没有J和U）的首字，因此有时用IIII代替IV。</p>
</blockquote>
<blockquote>
<p>——维基百科 </p>
</blockquote>
<p>tips: 3999范围内的罗马数字不会用到加上划线的字母</p>
<p><strong>思路</strong>：从最后一个字符开始，如果当前字符对应的数字比上一个数字小，那么就把结果减去当前字符对应的数字，否则加上当前字符对应数字。为了处理边界情况，在原字符串最后添加一个字符，该字符是原来的尾字符。</p>
<p><strong>参考代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&amp;lt;Character, Integer&amp;gt; m = <span class="keyword">new</span> HashMap&amp;lt;Character, Integer&amp;gt;();</span><br><span class="line">        m.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        m.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        m.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        m.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        m.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        m.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        m.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> result = m.get(s.charAt(length-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=length-<span class="number">2</span>; i&amp;gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.get(s.charAt(i))&amp;lt;m.get(s.charAt(i+<span class="number">1</span>)))</span><br><span class="line">                result -= m.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += m.get(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Palindrome Number回文</title>
    <url>/palindrome-number/</url>
    <content><![CDATA[<p><strong>链接</strong>：<a href="https://leetcode.com/problems/palindrome-number/#/description" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-number/#/description</a></p>
<p><strong>难度</strong>：Easy</p>
<p><strong>题目</strong>：Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:</p>
<p>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem &#8220;Reverse Integer&#8221;, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
<p><strong>翻译</strong>：确定一个整数是否是回文数。不能使用额外的空间。</p>
<p>一些提示：</p>
<p>负数能不能是回文数呢？（比如，-1）</p>
<p>如果你想将整数转换成字符串，但要注意限制使用额外的空间。</p>
<p>你也可以考虑翻转一个整数。</p>
<p>然而，如果你已经解决了问题&#8221;翻转整数&#8221;，</p>
<p>那么你应该知道翻转的整数可能会造成溢出。</p>
<p>你将如何处理这种情况？</p>
<p>这是一个解决该问题更通用的方法。</p>
<p><strong>思路</strong>：什么是回文？指的是“对称”的数，即将这个数的数字按相反的顺序重新排列后，所得到的数和原来的数一样。</p>
<p>这道题可以看成要计算一个数字是否是回文数字，我们其实就是将这个数字除以10，保留他的余数，下次将余数乘以10，加上这个数字再除以10的余数。依此类推，看能否得到原来的数。</p>
<p>注：负数不是回文数字，0是回文数字.</p>
<p><strong>参考代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp;lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &amp;gt; r) &#123;</span><br><span class="line">            r = r * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x /<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == r || x == r / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>［LeetCode］Reverse Integer题解</title>
    <url>/reverse-integer/</url>
    <content><![CDATA[<p>题目链接：7. <a href="https://leetcode.com/problems/reverse-integer/#/description" target="_blank" rel="noopener">Reverse Integer</a></p>
<p>难度：Easy</p>
<blockquote>
<p>Reverse digits of an integer.</p>
</blockquote>
<blockquote>
<p>Example1: x = 123, return 321</p>
</blockquote>
<blockquote>
<p>Example2: x = -123, return -321</p>
</blockquote>
<blockquote>
<p>Note:</p>
</blockquote>
<blockquote>
<p>The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. </p>
</blockquote>
<p><strong>要点</strong></p>
<p>本题考查的是整数相加的溢出处理，检查溢出有这么几种办法：</p>
<p>&#8211; 两个正数数相加得到负数，或者两个负数相加得到正数，但某些编译器溢出或优化的方式不一样</p>
<p>&#8211; 对于正数，如果最大整数减去一个数小于另一个数，或者对于负数，最小整数减去一个数大于另一个数，则溢出。这是用减法来避免加法的溢出。</p>
<p>&#8211; 使用long来保存可能溢出的结果，再与最大/最小整数相比较</p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (x !&#x3D; 0) &#123;</span><br><span class="line">            if (Math.abs(res) &gt; Integer.MAX_VALUE &#x2F; 10) return 0;</span><br><span class="line">            res &#x3D; res * 10 + x % 10;</span><br><span class="line">            x &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://segmentfault.com/a/1190000002993867" target="_blank" rel="noopener">[Leetcode] Reverse Integer 反转整数</a>　</p>
</blockquote>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>普林斯顿大学算法公开课笔记——插入排序</title>
    <url>/insertionsort/</url>
    <content><![CDATA[<blockquote>
<p><strong>插入排序</strong>(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。——极客学院 </p>
</blockquote>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2~5</li>
</ol>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol>
<li><p>时间复杂度：1/4 N^2的交换次数和比较次数 </p>
<ul>
<li><p>在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N &#8211; 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + &#8230; + (N &#8211; 1)，等差数列求和，结果为 N^2 / 2，所以最坏情况下的复杂度为 O(N^2)。</p>
</li>
<li><p>最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，时间是线性的，时间复杂度为O(N)。</p>
</li>
<li><p><strong>插入排序的速度大约是选择排序的两倍</strong></p>
<blockquote>
<p><strong>排序算法的稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>空间复杂度分析</p>
<p>算法所需的辅助空间是一个监视哨，辅助空间复杂度 S(n)=O(1)。是一个就地排序。</p> </p>
</li>
<li><p>直接插入排序的稳定性</p>
<p>直接插入排序是稳定的排序方法。</p>
</li>
</ol>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]，共有八个记录，排序过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[5]   6   3   1   8   7   2   4</span><br><span class="line">  ↑   │</span><br><span class="line">  └───┘</span><br><span class="line">[5, 6]   3   1   8   7   2   4</span><br><span class="line">↑        │</span><br><span class="line">└────────┘</span><br><span class="line">[3, 5, 6]  1   8   7   2   4</span><br><span class="line">↑          │</span><br><span class="line">└──────────┘</span><br><span class="line">[1, 3, 5, 6]  8   7   2   4</span><br><span class="line">           ↑  │</span><br><span class="line">           └──┘</span><br><span class="line">[1, 3, 5, 6, 8]  7   2   4</span><br><span class="line">            ↑    │</span><br><span class="line">            └────┘</span><br><span class="line">[1, 3, 5, 6, 7, 8]  2   4</span><br><span class="line">   ↑                │</span><br><span class="line">   └────────────────┘</span><br><span class="line">[1, 2, 3, 5, 6, 7, 8]  4</span><br><span class="line">         ↑             │</span><br><span class="line">         └─────────────┘</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Insertion</span><br><span class="line">&#123;</span><br><span class="line">    public static void sort(Comparable[] a)</span><br><span class="line">    &#123;</span><br><span class="line">        int N &#x3D; a.length;</span><br><span class="line">        for(int i&#x3D;1; i&lt;N; i++)</span><br><span class="line">            for(int j&#x3D;i; j&gt;0;j--)</span><br><span class="line">                if(less(a[j],a[j-1]))</span><br><span class="line">                    exch(a,j,j-1)</span><br><span class="line">                else break;</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean less(Comparable v, Comparable w)</span><br><span class="line">    &#123;</span><br><span class="line">        return v.compareTo(w)&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void exch(Comparable[] a, int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        Comparable swap &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[j];</span><br><span class="line">        a[j] &#x3D; swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><p><a href="http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/" target="_blank" rel="noopener">常见排序算法 &#8211; 插入排序 (Insertion Sort)</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/data-structure-sorting/insertion-sort.html" target="_blank" rel="noopener">直接插入排序</a></p>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>普林斯顿大学算法公开课笔记——选择排序</title>
    <url>/selectionsort/</url>
    <content><![CDATA[<blockquote>
<p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。——维基百科 </p>
</blockquote>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>简单选择排序的特点是交换移动次数很少（至多n-1次），其时间复杂度为 O(n²) （时间主要花在比较上，总的比较次数为N=(n-1)+(n-2)+&#8230;+1=n*(n-1)/2），与冒泡排序一样，但性能上优于冒泡。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Selection</span><br><span class="line">&#123;</span><br><span class="line">    public static void sort(Comparable[] a)&#123;</span><br><span class="line">        int N &#x3D; a.length;</span><br><span class="line">        for (int i&#x3D;0; i&lt;N; i++)&#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for (int j&#x3D;i+1; j&lt;N; j++ )</span><br><span class="line">                if(less(a[j], a[min]))</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean less(Comparable v, Comparable w)</span><br><span class="line">    &#123;</span><br><span class="line">        return v.compareTo(w)&lt;0;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void exch(Comparable[] a, int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        Comparable swap &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[j];</span><br><span class="line">        a[j] &#x3D; swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Python 赋值、浅复制（拷贝）与深度（复制）拷贝</title>
    <url>/python_deepcopy/</url>
    <content><![CDATA[<h4 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1.直接赋值"></a>1.直接赋值</h4><p><code>y = x</code></p>
<blockquote>
<p>传递原始对象的引用，而不是一个副本，即y与x指向同一个对象 </p>
</blockquote>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fdufic3aqzj31ec0jsjro.jpg" alt=""></p>
<h4 id="2-浅复制（拷贝）"><a href="#2-浅复制（拷贝）" class="headerlink" title="2.浅复制（拷贝）"></a>2.浅复制（拷贝）</h4><p><code>y = x.copy()</code></p>
<blockquote>
<p>浅复制（拷贝）产生的对象是新的，但是它的子对象只是对原对象的一个引用。即x 和 y 是两个独立的对象，但他们的子对象还是指向统一对象（是引用） </p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fdufhbog0xj30pj0ak0sq.jpg" alt=""></p>
<h4 id="3-深度复制（拷贝）"><a href="#3-深度复制（拷贝）" class="headerlink" title="3.深度复制（拷贝）"></a>3.深度复制（拷贝）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">y &#x3D; copy.deepcopy(x)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>深度复制（拷贝）,完全拷贝了原对象及其子对象，产生的是一个独立的新的对象，在新的对象上进行修改不会对原对象产生影响。 </p>
</blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fdufj7jvbmj31go0mswez.jpg" alt=""></p>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">x &#x3D; &#123;&#39;course&#39;:[&#39;python&#39;,&#39;linux&#39;]&#125;</span><br><span class="line">y1 &#x3D; x</span><br><span class="line">y2 &#x3D; x.copy()</span><br><span class="line">y3 &#x3D; copy.deepcopy(x)</span><br><span class="line">x[&#39;course&#39;].append(&#39;java&#39;)</span><br><span class="line">print x</span><br><span class="line">print y1</span><br><span class="line">print y2</span><br><span class="line">print y3</span><br><span class="line">----------------------------------------</span><br><span class="line">result:</span><br><span class="line">x  &#x3D;&gt;   &#123;&#39;course&#39;: [&#39;python&#39;, &#39;linux&#39;, &#39;java&#39;]&#125;</span><br><span class="line">y1 &#x3D;&gt;   &#123;&#39;course&#39;: [&#39;python&#39;, &#39;linux&#39;, &#39;java&#39;]&#125;</span><br><span class="line">y2 &#x3D;&gt;   &#123;&#39;course&#39;: [&#39;python&#39;, &#39;linux&#39;, &#39;java&#39;]&#125;</span><br><span class="line">y3 &#x3D;&gt;   &#123;&#39;course&#39;: [&#39;python&#39;, &#39;linux&#39;]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html" target="_blank" rel="noopener">Python 直接赋值、浅拷贝和深度拷贝解析</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 数值的整数次方</title>
    <url>/power/</url>
    <content><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ol>
<li><p>指数为负时，可以先对指数求绝对值，算出次方的结果后再取倒数</p>
</li>
<li><p>当底数为0，指数为负时，会出现对0求倒数情况，要特殊处理</p>
</li>
<li><p>0的0次方在数学上没有意义，因此无论输出0还是1都是可以接受的</p>
</li>
<li><p>在计算次方的时候，除了简单的遍历，我们可以使用递归的思想，如下公式，来减少计算量：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsytgsuy9fj309m02da9v.jpg" alt=""></p>
</li>
</ol>
<h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 当指数为0底数为0时，没有意义，返回0或者返回1都可以</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent &amp;lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"分母不能为0"</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            n = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = PowerUnsignedExponent(base, n);</span><br><span class="line">        <span class="keyword">return</span> exponent&amp;lt;<span class="number">0</span>? <span class="number">1</span>/res: res;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">PowerUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">double</span> res = PowerUnsignedExponent(base, n/<span class="number">2</span>);</span><br><span class="line">        res *= res;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            res *= base;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h5><p>可以使用右移运算符代替除以2，用位与运算符代替求余运算符（%）来判断一个数是奇数还是偶数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">PowerUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">double</span> res = PowerUnsignedExponent(base, n&amp;gt;&amp;gt;<span class="number">1</span>);</span><br><span class="line">        res *= res;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">            res *= base;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 调整数组顺序使奇数位于偶数前面</title>
    <url>/reorderarray/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>最简单的方法就是把奇数和偶数按顺序挑出来，分别放到vector里，最后再把偶数的vector接到奇数vector的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        Vector&amp;lt;Integer&amp;gt; odd = <span class="keyword">new</span> Vector&amp;lt;Integer&amp;gt;();</span><br><span class="line">        Vector&amp;lt;Integer&amp;gt; even = <span class="keyword">new</span> Vector&amp;lt;Integer&amp;gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                even.add(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                odd.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.addAll(even);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;array.length;i++)&#123;</span><br><span class="line">            array[i] = odd.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不能开僻额外的空间，可以尝试有类似于冒泡排序的方法,如果当前的值为偶数，后一个值为奇数，则两个数对换位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &amp;lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&amp;lt;array.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>] % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 链表中倒数第k个结点</title>
    <url>/findkthtotail/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>经典的双指针法。定义两个指针，第一个指针从链表的头指针开始遍历向前走<code>k-1</code>步，第二个指针保持不动，从第<code>k</code>步开始，第二个指针也开始从链表的头指针开始遍历，由于两个指针的距离保持在<code>k-1</code>，当第一个指针到达链表的尾节点时，第二个指针刚好指向倒数第<code>k</code>个节点。</p>
<p>关注要点</p>
<ol>
<li><p>链表头指针是否为空，若为空则直接返回回null</p>
</li>
<li><p>k是否为0，k为0也就是要查找倒数第0个节点，由于计数一般是从1开始的，所有输入0没有实际意义，返回null</p>
</li>
<li><p>k是否超出链表的长度，如果链表的节点个数少于k，则在指针后移的过程中会出现next指向空指针的错误，所以程序中要加一个判断</p>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="comment">//判断k是否超过链表节点的个数，注意是 i &amp;lt; k - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &amp;lt; k-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next != <span class="keyword">null</span>)</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = head;</span><br><span class="line">        ListNode pB = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;k-<span class="number">1</span>; i++)</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        <span class="keyword">while</span>(pA.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，还有一种是用stack的方法，把链表按顺序压入stack,然后直接取出stack的第k个节点。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 反转链表</title>
    <url>/reverselist/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从<code>pre-&gt;head-&gt;next1-&gt;next2</code>变成<code>pre&lt;-head next1-&gt;next2</code>的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开</p>
<blockquote>
<p>需要注意的点：</p>
</blockquote>
<blockquote>
<p>1、如果输入的头结点是null，则返回null</p>
</blockquote>
<blockquote>
<p>2、链表断裂的考虑 </p>
</blockquote>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 合并两个排序的链表</title>
    <url>/mergelinklist/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>两种解法：递归和非递归</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode mergehead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &amp;lt;= list2.val)&#123;</span><br><span class="line">            mergehead = list1;</span><br><span class="line">            mergehead.next = Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergehead = list2;</span><br><span class="line">            mergehead.next = Merge(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode mergehead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &amp;lt;= list2.val)&#123;</span><br><span class="line">            mergehead = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergehead = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = mergehead;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &amp;lt;= list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            cur.next = list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            cur.next = list1;</span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 树的子结构</title>
    <url>/issubtree/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>递归思想，如果根节点相同则递归调用IsSubtree()，如果根节点不相同，则判断<code>root1</code>的左子树和<code>roo2</code>是否相同，再判断右子树和<code>root2</code>是否相同;</li>
<li>注意节点为空的条件，<code>HasSubTree</code>中，只要有树为空就返回<code>false</code>; <code>IsSubtree</code>中，要先判断<code>root2</code>，如果<code>root2</code>为空，则说明第二棵树遍历完了，即匹配成功。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsSubtree(root1, root2) || </span><br><span class="line">               HasSubtree(root1.left, root2) ||</span><br><span class="line">               HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//要先判断roo2, 不然&#123;8,8,7,9,2,#,#,#,#,4,7&#125;,&#123;8,9,2&#125;这个测试用例通不过。</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> IsSubtree(root1.left, root2.left) &amp;&amp; </span><br><span class="line">                IsSubtree(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉树的镜像</title>
    <url>/mirrortree/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><p>二叉树的镜像定义：</p>
<blockquote>
<pre><code>源二叉树 
    8
   /  \
  6   10
 / \  / \
5  7 9 11
镜像二叉树
    8
   /  \
  10   6
 / \  / \
11 9 7  5</code></pre></blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>通过对以上两棵树的观察，我们可以总结出这两棵树的根节点相同，但它们的左、右两个子节点交换了位置。所以我们可以得出求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶节点的左、右子节点之后，就得到了树的镜像。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前节点为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//当前节点没有叶子节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        <span class="comment">//递归交换叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 顺时针打印矩阵</title>
    <url>/printmatrix/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： <code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</code> 则依次打印出数字<code>1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</code>.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先得到矩阵的行和列数，然后依次旋转打印数据，一次旋转打印结束后，往对角分别前进和后退一个单位。</p>
<p>要注意单行和单列的情况。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; printMatrix(<span class="keyword">int</span> [][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = col - <span class="number">1</span>, top = <span class="number">0</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &amp;lt;= right &amp;&amp; top &amp;lt;= bottom)&#123;</span><br><span class="line">            <span class="comment">//上：从左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&amp;lt;=right; i++)</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            <span class="comment">//右：从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>; i&amp;lt;=bottom; i++)</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            <span class="comment">//下：从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(top != bottom)&#123;</span><br><span class="line">                <span class="comment">//防止单行情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right-<span class="number">1</span>; i&amp;gt;=left; i--)</span><br><span class="line">                    res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左：从下到上</span></span><br><span class="line">            <span class="keyword">if</span>(left != right)&#123;</span><br><span class="line">                <span class="comment">//防止单列情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>; i&amp;gt;top; i--)</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++; right--; top++; bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 包含min函数的栈</title>
    <url>/minstack/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用一个栈stack保存数据，用另外一个栈temp保存依次入栈最小的数</p>
<p>比如，stack中依次入栈</p>
<p><code>5, 3, 4, 10, 2, 12, 1, 8</code></p>
<p>则temp依次入栈</p>
<p><code>5, 3, 3，3, 2, 2, 1, 1</code></p>
<p>每次入栈的时候，如果入栈的元素比min中的栈顶元素小或等于则入栈，否则用最小元素入栈。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">    Stack&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(node &amp;lt; min)&#123;</span><br><span class="line">            temp.push(node);</span><br><span class="line">            min = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = stack.pop();</span><br><span class="line">        stack.push(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = temp.pop();</span><br><span class="line">        temp.push(m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 栈的压入、弹出序列</title>
    <url>/ispoporder/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>模拟堆栈操作的过程，将原数列依次压栈，把栈顶元素与所给出栈队列相比，如果相同则出栈，如果不同则继续压栈，直到原数列中所有数字压栈完毕。最后，检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则，说明出栈队列不能由原数列进行栈操作得到。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length != popA.length || </span><br><span class="line">               pushA.length == <span class="number">0</span> ||</span><br><span class="line">               popA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&amp;lt;Integer&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[index])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 从上往下打印二叉树</title>
    <url>/printfromtoptobottom/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>就是二叉树的层序遍历。借助一个队列就可以实现。</p>
<p>使用两个队列一个存放节点，一个存放值。先将根节点加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来。</p>
<p>注意<code>Queue</code>创建的方式：<code>Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</code></p>
<p>用<code>add</code>将元素添加到队列中，用<code>remove</code>来移除并返回队首元素。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;Integer&amp;gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&amp;lt;Integer&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//Queue is abstract; 不能用 new Queue&amp;lt;TreeNode&amp;gt;();</span></span><br><span class="line">        Queue&amp;lt;TreeNode&amp;gt; queue = <span class="keyword">new</span> LinkedList&amp;lt;TreeNode&amp;gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            root = queue.remove();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉搜索树的后序遍历序列</title>
    <url>/verifysquenceofbst/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote>
<p>二叉搜索树: 左子树&lt;根&lt;=右子树 </p>
</blockquote>
<p>对于后序遍历来说，序列数组的最后一个元素一定是根节点, 根据这个元素，将前面的数组分为左、右两个部分，左侧部分都比该元素小，右侧部分都比该元素大，如果右侧部分有比该根节点小的元素，那么就不是后序遍历，如此递归进行。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &amp;gt;= root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;lt; root &amp;&amp; sequence[i] &amp;lt; sequence[root])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&amp;lt;root; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&amp;lt;sequence[root])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (judge(sequence, start, i-<span class="number">1</span>)) &amp;&amp; (judge(sequence, i, root-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉树中和为某一值的路径</title>
    <url>/findpath/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用前序遍历的方式访问到某一结点时，把该结点添加到路径上，并用目标值减去该节点的值。如果该结点为叶结点并且目标值减去该节点的值刚好为0，则当前的路径符合要求，我们把加入res数组中。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父结点。因此我们在函数退出之前要在路径上删除当前结点，以确保返回父结点时路径刚好是从根结点到父结点的路径。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt; &amp;gt;();</span><br><span class="line">    ArrayList&amp;lt;Integer&amp;gt; temp = <span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        target -= root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&amp;lt;Integer&amp;gt;(temp));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            FindPath(root.left, target);</span><br><span class="line">            FindPath(root.right, target);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 复杂链表的复制</title>
    <url>/clonelink/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fswi3t9ba5j30ct0f0gmb.jpg" alt=""></p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//复制节点 A-&amp;gt;B-&amp;gt;C 变成 A-&amp;gt;A'-&amp;gt;B-&amp;gt;B'-&amp;gt;C-&amp;gt;C'</span></span><br><span class="line">        RandomListNode head = pHead;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">            head = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制random</span></span><br><span class="line">        head = pHead;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next.random = head.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : head.random.next;</span><br><span class="line">            head = head.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//折分</span></span><br><span class="line">        head = pHead;</span><br><span class="line">        RandomListNode chead = head.next;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node = head.next;</span><br><span class="line">            head.next = node.next;</span><br><span class="line">            node.next = node.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.next.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 二叉搜索树与双向链表</title>
    <url>/converttree/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目可能比较难理解，可以看如下的图，我们有一棵二叉搜索树，要求得右边的双向链表。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsy2vw7uxcj31660c0jsv.jpg" alt=""></p>
<p>在二叉搜索树中，左子结点的值总是小于父结点的值，右子节点的值总是大于父结点的值。因此我们在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子节点的指针调整为链表中指向后一个结点的指针。</p>
<p>因为中序遍历是按照从小到大的顺序遍历二叉搜索树，所以我们用中序遍历树中的每一个节点得到的正好是要求的排好序的。遍历过程如下：</p>
<p>每次遍历节点的左孩子、右孩子，把左孩子指向转换链表的尾节点，并把末尾指针的右孩子指向自己。右孩子指向节点的右孩子。如果没有右孩子就返回。这一过程可以用递归实现。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h5 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode end = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        ConvertSub(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = end;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        Stack&amp;lt;TreeNode&amp;gt; stack = <span class="keyword">new</span> Stack&amp;lt;&amp;gt;();</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = pre;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>[剑指offer] 字符串的排列</title>
    <url>/permutation/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><blockquote>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 </p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>刚看题目的时候，可能会觉得这个问题很复杂，不能一下子想出解决方案。那我们就要学会把复杂的问题分解成小问题。我们求整个字符串的排列，其实可以看成两步：</p>
<ul>
<li>第一步求所有可能出现在第一个位置的字符（即把第一个字符和后面的所有字符交换[相同字符不交换]）；</li>
<li>第二步固定第一个字符，求后面所有字符的排列。这时候又可以把后面的所有字符拆成两部分（第一个字符以及剩下的所有字符），依此类推。这样，我们就可以用递归的方法来解决。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&amp;lt;String&amp;gt; res = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&amp;lt;String&amp;gt; Permutation(String str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PermutationHelper(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(String.valueOf(str));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &amp;lt; str.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i &amp;&amp; str[i] == str[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">                PermutationHelper(str, i+<span class="number">1</span>);</span><br><span class="line">                swap(str, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法&amp;amp;数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>
